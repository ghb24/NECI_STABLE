<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Calc &mdash; NECI v0.1 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="NECI v0.1 documentation" href="../index.html" />
    <link rel="up" title="Input options" href="index.html" />
    <link rel="next" title="Integrals" href="integrals.html" />
    <link rel="prev" title="PreCalc" href="precalc.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="integrals.html" title="Integrals"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="precalc.html" title="PreCalc"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">NECI v0.1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Input options</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">Calc</a><ul>
<li><a class="reference external" href="#general-options">General options</a></li>
<li><a class="reference external" href="#method-options">Method options</a><ul>
<li><a class="reference external" href="#experimental-methods">Experimental methods</a></li>
</ul>
</li>
<li><a class="reference external" href="#walker-monte-carlo-options">Walker Monte Carlo options</a></li>
<li><a class="reference external" href="#return-path-monte-carlo-options">Return Path Monte Carlo options</a></li>
<li><a class="reference external" href="#perturbation-theory-options">Perturbation theory options</a></li>
<li><a class="reference external" href="#diagonalisation-options">Diagonalisation options</a></li>
<li><a class="reference external" href="#graph-morphing-options">Graph morphing options</a></li>
<li><a class="reference external" href="#monte-carlo-options">Monte Carlo options</a><ul>
<li><a class="reference external" href="#weighting-schemes">Weighting schemes</a></li>
</ul>
</li>
<li><a class="reference external" href="#experimental-options">Experimental options</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="precalc.html"
                                  title="previous chapter">PreCalc</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="integrals.html"
                                  title="next chapter">Integrals</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/input/calc.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="calc">
<span id="input-calc"></span><h1>Calc<a class="headerlink" href="#calc" title="Permalink to this headline">¶</a></h1>
<dl class="docutils">
<dt><strong>CALC</strong></dt>
<dd>Start calculation block.  This chooses what calculation to do.</dd>
</dl>
<p>[Calculation options&#8212;see below.]</p>
<dl class="docutils">
<dt><strong>ENDCALC</strong></dt>
<dd>End the calculation input block.</dd>
</dl>
<div class="section" id="general-options">
<h2>General options<a class="headerlink" href="#general-options" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><strong>ALLPATHS</strong></dt>
<dd>Choose all determinants (i.e. set NPATHS = -1).</dd>
<dt><strong>BETA</strong> [BETA]</dt>
<dd>Set <img class="math" src="../_images/math/fdb63b9e51abe6bbb16acfb5d7b773ddbb5bf4a8.png" alt="\beta"/>.</dd>
<dt><strong>BETAOVERP</strong> [BETAP]</dt>
<dd><p class="first">Default= 1.d-4.</p>
<p class="last">Set <img class="math" src="../_images/math/b9c673e6ea6a45e9ae9c02d9cc8106bf094f9f60.png" alt="\beta/P"/>.</p>
</dd>
<dt><strong>DELTABETA</strong> [DBETA]</dt>
<dd><p class="first">Set <img class="math" src="../_images/math/8a22a457108bfa7f10f7569ce521dac0e530b5b7.png" alt="\delta\beta"/>.  If given a negative value, calculate it exactly.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">What is this used for?</p>
</div>
</dd>
<dt><strong>DETINV</strong> [DETINV]</dt>
<dd>Specify the root determinant for which the complete vertex series is
worked out, using the determinant index obtained from a previous
calculation.  If <strong>DETINV</strong> is negative, the NPATHS calculations
are started at this determinant.</dd>
<dt><strong>EXCITE</strong> [ICILEVEL]</dt>
<dd><p class="first">Default 0.</p>
<p class="last">Excitiation level at which to truncate determinant list.  If ICILEVEL=0
then all determinants are enumerated.
This also works for FCIMC calculations.</p>
</dd>
<dt><strong>EXCITATIONS</strong> [<strong>OLD</strong> <strong>NEW</strong>]</dt>
<dd><p class="first">For generation of up to double excitations use the old (completely
reliable), or new (faster, but does not work for more than 2-vertex
level SUMS) routine</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You can now use the <strong>NEW</strong> routines for all methods, right?
What is the difference between <strong>NEW</strong> and <strong>OLD</strong>?  (If it doesn&#8217;t say, how else
can a user make an informed decision as to which to use?)</p>
</div>
</dd>
<dt><strong>EXCITATIONS</strong> [<strong>SINGLES</strong> <strong>DOUBLES</strong>]</dt>
<dd><p class="first">Default is to use all excitations.</p>
<p>Restricts determinants which are allowed to be connected to the
reference determinant to be either single or double excitations of
the reference determinant.</p>
<p class="last">Applies only to the <strong>VERTEX</strong> [<strong>SUM</strong> <strong>STAR</strong>] <strong>NEW</strong> methods.</p>
</dd>
<dt><strong>HAMILTONIAN</strong> [<strong>STAR</strong>]</dt>
<dd><p class="first">Store the Hamiltonian.  This is defaulted to ON if <strong>ENERGY</strong> is set,
but can be used without <strong>ENERGY</strong>.</p>
<dl class="last docutils">
<dt><strong>STAR</strong></dt>
<dd>Only the connections between the root determinant and its
excitations should be included in the Hamiltonian and not
off-diagonal elements between excited determinants.</dd>
</dl>
</dd>
<dt><strong>MAXVERTICES</strong> [MAXVERTICES]</dt>
<dd>Give the vertex level of the calculation.  Cannot be used in
conjunction with a <strong>METHODS</strong> block.</dd>
<dt><strong>CONSTRUCTNATORBS</strong></dt>
<dd>Calculates the 1 electron reduced density matrix (1-RDM) as a FCIMC
calculation progresses.  At the end of the iterations, this matrix
is diagonalised to get linear combinations of the HF orbitals which
approximate the natural orbitals.  The occupation numbers (e-values)
of these are printed in the OUTPUT file.
This is now a very old option, a much more efficient equivalent has
been added under the <strong>ROTATEORBS</strong> option.  See <strong>USECINATORBS</strong> in the
system file.</dd>
<dt><strong>METHOD</strong> [Method option(s)]</dt>
<dd><p class="first">Specify the method for a graph theory calculation.  See Method
options for the available methods.</p>
<p class="last">Can only be specified once if used outside of the methods block,
in which case the given method is applied to all vertex levels.</p>
</dd>
<dt><strong>METHODS</strong></dt>
<dd><p class="first">Begin a methods block.  This allows a different method for each vertex
level.  Each vertex level can contain <strong>EXCITATIONS</strong>, <strong>VERTICES</strong>,
<strong>CYCLES</strong> and <strong>CALCVAR</strong> keywords.
Each <strong>METHOD</strong> line and the options that follow it detail the calculation
type for the next vertex level, with the first <strong>METHOD</strong> line used for the
the second-vertex level, unless over-ridden with the <strong>VERTICES</strong> option.</p>
<p>The block terminates with <strong>ENDMETHODS</strong>.</p>
<p>For example:</p>
<div class="highlight-python"><pre>METHODS
   METHOD VERTEX SUM NEW
   EXCITATIONS DOUBLES
   METHOD VERTEX STAR POLY
   EXCITATIONS SINGLES
   VERTICES 2
ENDMETHODS</pre>
</div>
<p>sets the first method, at the two-vertex level, to be a complete 2-vertex
sum of only doubles, and the second method, overriden to be also at
the two-vertex level, to be a vertex star of singles.</p>
<p>Similarly:</p>
<div class="highlight-python"><pre>METHODS
   METHOD VERTEX SUM NEW
   METHOD VERTEX SUM MC
   [Monte Carlo options]
ENDMETHODS</pre>
</div>
<p class="last">performs a full sum at the two-vertex level and a Monte Carlo
calculation at the three-vertex level.</p>
</dd>
<dt><strong>ENDMETHODS</strong></dt>
<dd>Terminate a methods block.</dd>
<dt><strong>PATHS</strong> [option]</dt>
<dd><p class="first">Select the number of determinants taken to be the root of the graph.
Usually set to 1.  Valid options:</p>
<blockquote class="last">
<dl class="docutils">
<dt>NPATHS</dt>
<dd>Choose the first NPATHS determinants and calculate RHOPII etc.</dd>
<dt><strong>ALL</strong></dt>
<dd>Choos all determinants (same as ALLPATHS).</dd>
<dt><strong>ACTIVE</strong></dt>
<dd>Choose only the active space of determinants: the degenerate
set containing the highest energy electron.</dd>
<dt><strong>ACTIVE</strong> <strong>ORBITALS</strong> nDown nUp</dt>
<dd>Set the active space to be nDown and nUp orbitals respectively
from the Fermi level</dd>
<dt><strong>ACTIVE</strong> <strong>SETS</strong> nDown nUp</dt>
<dd>Set the active space to be nDown and nUp degenerate sets
respectively from the Fermi level</dd>
</dl>
</blockquote>
</dd>
<dt><strong>RHOEPSILON</strong> [RHOEPSILON]</dt>
<dd>Set the minimum significant value of an element in the <img class="math" src="../_images/math/bf4c63b0e04518f08e6142e6637bea99f478500a.png" alt="rho"/>
matrix as a fraction of the maximum value in the <img class="math" src="../_images/math/bf4c63b0e04518f08e6142e6637bea99f478500a.png" alt="rho"/> matrix.
Matrix elements below this threshold are set to be 0.</dd>
<dt><strong>STARCONVERGE</strong> [STARCONV]</dt>
<dd><p class="first">Default 1.d-3.</p>
<p class="last">Set the convergence criteria for whether a roots to the star graph
is significant.</p>
</dd>
<dt><strong>TROTTER</strong></dt>
<dd><p class="first">Default.</p>
<p class="last">Perform a Trotter decomposition to evaluate the <img class="math" src="../_images/math/bf4c63b0e04518f08e6142e6637bea99f478500a.png" alt="rho"/> matrix elements.</p>
</dd>
<dt><strong>TIMESTEPS</strong> [I_P]</dt>
<dd>Set P, the timesteps into which <img class="math" src="../_images/math/3ca5841c4a76deae4dde1467af4ae3cc3567b0d6.png" alt="e^{-\beta H}"/> is split.  Automatically
sets <img class="math" src="../_images/math/49d1431138a2a6ccd1e94005110f6d02cf655354.png" alt="\beta/P=0"/> (as required) but returns an error message if <strong>BETAOVERP</strong>
is also used.</dd>
<dt><strong>WORKOUT</strong> [NDETWORK]</dt>
<dd><p class="first">Sets the number of determinants which are worked out exactly.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">What is this used for?</p>
</div>
</dd>
<dt><strong>VERTICES</strong></dt>
<dd><p class="first">Only available inside a methods block.</p>
<p class="last">By default, each method takes a
number of vertices corresponding to its index within the methods
block, the first methods corresponding to the 2-vertex level, the
second to the 3-vertex level, and so on.  <strong>VERTICES</strong> overrides this,
and allows the vertex level of each method to be explicitly specified,
enabling, for example, the 2-vertex level to be split up and the
contributions from single and double excitations of the reference
determinant to be handled separately.</p>
</dd>
</dl>
</div>
<div class="section" id="method-options">
<h2>Method options<a class="headerlink" href="#method-options" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><strong>VERTEX SUM</strong> [<strong>OLD</strong> <strong>NEW</strong> <strong>HDIAG</strong>] [<strong>SUB2VSTAR</strong>] [<strong>LOGWEIGHT</strong>]</dt>
<dd><p class="first">Calculate the vertex sum approximation.</p>
<dl class="docutils">
<dt><strong>OLD</strong></dt>
<dd>Diagonalise the <img class="math" src="../_images/math/0027034d8a10372a06deaf4f4084c01956587479.png" alt="\rho"/> matrix using the original method.</dd>
<dt><strong>NEW</strong></dt>
<dd>Diagonalise the <img class="math" src="../_images/math/0027034d8a10372a06deaf4f4084c01956587479.png" alt="\rho"/> matrix using a more modern, more
efficient method.  Recommended.</dd>
<dt><strong>HDIAG</strong></dt>
<dd>Diagonalise the Hamiltonian matrix instead of the <img class="math" src="../_images/math/bf4c63b0e04518f08e6142e6637bea99f478500a.png" alt="rho"/> matrix
in order to calculate the weight and energy contribution of each graph.</dd>
<dt><strong>SUB2VSTAR</strong></dt>
<dd>Remove paths which were present in the 2-vertex
star for each graph.  If this is specified for ANY vertex level,
it applies to all <strong>SUM</strong> and MC vertex levels.</dd>
<dt><strong>LOGWEIGHT</strong></dt>
<dd>Form Q as a multiplication of factors from graphs.  This results
in the quantity <img class="math" src="../_images/math/4c61a56f304f280a401f95d69c7385579eb177db.png" alt="\operatorname{log} w"/> being used instead
of <img class="math" src="../_images/math/9ee4b825a2e36ae093ed7be5e4851ef453b34914.png" alt="w"/>, which also translates to the energy expression
only involving <img class="math" src="../_images/math/2b1307ee5ae475b35c4806a1cd01768feb63260b.png" alt="\tilde{E}"/> not weights.  Hopefully this
is size-consistent.</dd>
</dl>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><strong>SUB2VSTAR</strong> and <strong>LOGWEIGHT</strong> are experimental options.</p>
</div>
</dd>
<dt><strong>VERTEX</strong> [<strong>MC</strong> <strong>MCMETROPOLIS</strong> <strong>MCDIRECT</strong> <strong>MCMP</strong>] [<strong>HDIAG</strong>]</dt>
<dd><p class="first">Perform a Monte Carlo calculation.</p>
<dl class="last docutils">
<dt><strong>MCDIRECT</strong></dt>
<dd><p class="first">Perform direct stochastic sampling for the graph theory vertex sum
method, dividing each freshly generated graph by its normalized
generation probability.</p>
<p>If <strong>MULTIMCWEIGHT</strong> is specified then
the sampling generates graphs from all weighted levels using
the weighting - a single MC calculation is performed.</p>
<p>If <strong>MULTIMCWEIGHT</strong> is not specified (default), a separate
MC calculation is performed at each vertex level.  Combined
statistics are printed.</p>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><strong>MULTIMCWEIGHT</strong> is not documented.  Use with great caution.</p>
</div>
</dd>
<dt><strong>MCMP</strong></dt>
<dd>Perform direct stochastic sampling, as in <strong>MCDIRECT</strong>,
but for the Moller&#8211;Plesset method.</dd>
<dt><strong>MC</strong> or <strong>MCMETROPOLIS</strong></dt>
<dd><p class="first">Perform Metropolis Monte Carlo.</p>
<p>This may be performed in a number of ways. The way is
chosen by the location of the <strong>VERTEX</strong> <strong>MC</strong> command.</p>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<p>The following options appear in INPUT_DOC but, however, are incredibly
poorly documented.  In particular:</p>
<blockquote>
<ul class="simple">
<li>No detail on the arguments the options take (e.g. <strong>BIAS</strong>).</li>
<li>Some options documented don&#8217;t exist (e.g. <strong>SINGLE</strong>, <strong>BIAS</strong>, <strong>MULTI</strong>, <strong>STOCHASTICTIME</strong>).</li>
<li>Sufficient tests are not present in the test suite.</li>
</ul>
</blockquote>
<p>Do not use.</p>
<p>The &#8220;options&#8221; are:</p>
<div class="last highlight-python"><pre> **STOCHASTICTIME**
     may also be specified to perform stochastic
     time simulations with a given **BIAS**

**SINGLE**
    MC is performed at a single vertex level using a composite
    1-vertex graph containing a full sum previously performed.

**BIAS**
    is used to choose whether a step selects a composite
    (all lower levels) or a normal (this level) graph.  Stochastic
    time MC is performed. This can only be specified in the
    **METHODS** section, and only at the last vertex level.
    Uses **EXCITWEIGHTING** for excitation generation weighting
    and **IMPORTANCE** for graph generation weighting

**MULTI**
    MC is performed at a multiple vertex levels, but still
    using a composite 1-vertex graph containing a full sum
    previously performed. MULTI should be specified in all the
    (contiguous) vertex levels to be included (not composited)
    in the MC.  **BIAS** is used to choose whether a step
    selects a composite (all lower levels) or a normal (the
    **MULTI** levels) graph.  **MULTIMCWEIGHT** is specified
    for each **MULTI** level, and gives a relative weighting
    of selecting the vertex level graphs once a non-composite
    graph is chosen.  Stochastic time MC is performed.
    This can only be specified in the **METHODS** section.
    Once **MULTI** has been specified, it must be specified
    on all subsequent vertex levels in a **METHODS** section.
    Uses **EXCITWEIGHTING** for excitation generation weighting
    and **IMPORTANCE** for graph generation weighting

**FULL**
    Does  MC at all levels using BIAS to bias the levels,
    **EXCITWEIGHTING** for excitation generation, and
    **IMPORTANCE** to for graph generation weighting.  This is
    only available *WITHOUT* a **METHODS** section. If **HDIAG**
    is specified, the H-diagonalizing routine is used, otherwise,
    the rho-diagonalizer is used.  **HDIAG** is automatically
    specified for **MCMP**.</pre>
</div>
</div>
</dd>
</dl>
</dd>
<dt><strong>VERTEX</strong> <strong>SUM</strong> <strong>READ</strong></dt>
<dd>Read in from pre-existing MCPATHS file for that vertex level.
Only really useful in a <strong>METHODS</strong> section.</dd>
<dt><strong>VERTEX</strong> <strong>STAR</strong> [<strong>ADDSINGLES</strong> <strong>COUNTEXCITS</strong>] [star method] [<strong>OLD</strong> <strong>NEW</strong> [<strong>H0</strong>] ]</dt>
<dd><p class="first">Construct a single and double excitation star from all determinants
connected to the root (ignoring connections between those dets).
See <a class="reference external" href="../references.html#starpaper">[StarPaper]</a> for more details.</p>
<dl class="docutils">
<dt><strong>ADDSINGLES</strong></dt>
<dd><p class="first">Extend the star graph approach.</p>
<p>Add the single exctitaions which are en-route to each double
excitation to that double excitation as spokes, and prediagonalize
the mini-star centred on each double excitation.  For example,
if the double excitation is (ij-&gt;ab), then singles
(i-&gt;a),(i-&gt;b),(j-&gt;a) and (j-&gt;b) are created in a star with
(ij-&gt;ab), the result diagonalized, and the eigenvalues and
vectors used to create a new spoke of the main star graph.</p>
<p class="last">Only works with <strong>NEW</strong>.</p>
</dd>
<dt><strong>COUNTEXCITS</strong></dt>
<dd><p class="first">Run through all the symmetry allowed excitations
first and count the connected determinants on the star.  Enables the
memory requirements to be reduced as only connected determinants need
to be stored. However, the time taken is increased, as it is necessary
to run through all determinants in the star twice. Especially useful
for large systems with memory restraints, when density fitting has
necessarily turned off symmetry. Also useful if a <strong>RHOEPSILON</strong>
has been set to a large value so that many of the symmetry allowed
excitations  will be counted as disconnected.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Useful for periodic calculations?  Does it need just the
symmetry info or the transition matrix elements as well?</p>
</div>
</dd>
<dt><strong>OLD</strong></dt>
<dd>Use a pre-generated list of determinants using the excitation
routine version specified in <strong>EXCITATIONS</strong> <strong>OLD</strong> or
<strong>EXCITATIONS</strong> <strong>NEW</strong>.</dd>
<dt><strong>NEW</strong></dt>
<dd>Generate determinants on the fly without storing them, using
the <strong>NEW</strong> excitation routine.  Much more memory efficient.</dd>
<dt><strong>NEW H0</strong></dt>
<dd><p class="first">Use the zeroth order N-particle Hamiltonian (shifted such that
<img class="math" src="../_images/math/788d4a0f45f08d2a50f0e013b2e2ed7d88f6e49e.png" alt="H^0_{ii} = H_{ii}"/>) rather than the fully interacting
Hamiltonian to generate the roots of the polynomial.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">And you&#8217;d want to use <strong>NEW H0</strong> why exactly?</p>
</div>
</dd>
</dl>
<p>The available star methods are:</p>
<blockquote>
<dl class="docutils">
<dt><strong>DIAG</strong></dt>
<dd>Perform a complete diagonalization on the resultant matrix.  This can
be very slow. However, by specifying <strong>LANCZOS</strong> in the <strong>CALC</strong>
block, you can do a Lanczos diagonalisation, which scales much
better. <strong>EIGENVALUES</strong> can also be specify to only evaluate the
first few eigenvalues.</dd>
<dt><strong>POLY</strong></dt>
<dd><p class="first">Use the special properties of the matrix to find the roots of
the polynomial and uses them to calculate the relevant values.
This is order <img class="math" src="../_images/math/747e1bff1af8edd386f06de06199ae0ef116728d.png" alt="\text{Ngraph}^2"/>.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Ngraph==nDets?</p>
</div>
</dd>
<dt><strong>POLYMAX</strong></dt>
<dd>Similar to <strong>POLY</strong> but only finds the highest root of the polynomial, so
is order Ngraph.  It can be used when P is very large (i.e. <img class="math" src="../_images/math/fdb63b9e51abe6bbb16acfb5d7b773ddbb5bf4a8.png" alt="\beta"/>
is very large, e.g. 40).</dd>
<dt><strong>POLYCONVERGE</strong></dt>
<dd>Similar to <strong>POLY</strong> but adds i out of N <img class="math" src="../_images/math/f9092807df2606b64909623baacf32bf722daff7.png" alt="\lambda_i"/>
roots, such that <img class="math" src="../_images/math/f89156f217341f79f8fb908e735fc44894083364.png" alt="(N-i) \lambda_i^P &lt; 10^{-3}"/>, i.e. we
evaluate enough roots such that a very conservative error
estimate of the contribution of the remaining roots is
negligible.</dd>
<dt><strong>POLYCONVERGE2</strong></dt>
<dd>Similar to <strong>POLYCONVERGE</strong> but requires
<img class="math" src="../_images/math/79b59a9a534f61c65d6f39620c3c76b925d7fa01.png" alt="w(1..i) (N-i) \lambda_i^P &lt; 10^{-3}"/>, where
<img class="math" src="../_images/math/fa160198cdaac31e819db4367d084af1fa9f54b3.png" alt="w(1..i)"/> is the cumulative sum of <img class="math" src="../_images/math/4d2478c4902a83844a804bf79444f1d2bff74c91.png" alt="\lambda_i^P"/>,
which should be a better estimate of the convergence.</dd>
</dl>
</blockquote>
<p>The following are experimental star methods:</p>
<blockquote class="last">
<dl class="docutils">
<dt><strong>MCSTAR</strong></dt>
<dd><p class="first">Use a basic implementation of the spawning algorithm in
order to sample the star graph stochastically. The sampling uses
elements of the Hamiltonian matrix rather than the <img class="math" src="../_images/math/bf4c63b0e04518f08e6142e6637bea99f478500a.png" alt="rho"/> matrix,
so there will be some differences in the converged energy
compared to a <strong>VERTEX STAR NEW</strong> calculation.</p>
<p class="last">Many of the <strong>FCIMC</strong> options are also available with MCStar,
and there are also some extra one.</p>
</dd>
<dt><strong>NODAL</strong></dt>
<dd>Prediagonalise a completely connected set of virtuals for each
set of occupied (i,j) spin-orbitals. The diagonalised
excitations are then solved as a star graph. Must be used
with <strong>NEW</strong>.</dd>
<dt><strong>STARSTARS</strong></dt>
<dd>Use an approximation that the change of eigenvalues and the
first element of the eigenvectors of the star graph is linear with
respect to multiplying the diagonal elements by a constant. Once
this scaling is found, all stars of stars are prediagonalised,
and reattached to the original graph. This results in N^2 scaling,
where N is the number of excitations.</dd>
<dt><strong>TRIPLES</strong></dt>
<dd>Prediagonalise an excited star of triple excitations from each
double excitation, reattach the eigenvectors, and solves
the complete star. Currently only available with &#8216;<strong>NEW</strong>&#8216;,
&#8216;<strong>COUNTEXCITS</strong>&#8216; and &#8216;<strong>DIAG</strong>&#8216;.</dd>
</dl>
</blockquote>
</dd>
</dl>
<div class="section" id="experimental-methods">
<h3>Experimental methods<a class="headerlink" href="#experimental-methods" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><strong>VERTEX</strong> <strong>FCIMC</strong> [<strong>MCDIFFUSION</strong>] [<strong>RESUMFCIMC</strong>] [<strong>SERIAL</strong>]</dt>
<dd><p class="first">Perform Monte Carlo calculations over pure determinant space, which
is sampled using a series of &#8216;particles&#8217; (or &#8216;walkers&#8217;).</p>
<p>The walkers are not necessarily unique and must be sorted at every
iteration.  Each walker has its own excitation generator.</p>
<p><strong>MCDIFFUSION</strong> is a completely particle-conserving diffusion
algorithm and is much more experimental.</p>
<p><strong>FCIMC</strong> and <strong>MCDETS</strong> calculations share many of the same options
(see Walker Monte Carlo options, below).</p>
<p><strong>RESUMFCIMC</strong> creates graphs out of connected determinants, and applies
the H-matrix successively in order to achieve a local spawning algorithm.
This reduces to the original spawning algorithm when <strong>GRAPHSIZE</strong> is 2 and
<strong>HAPP</strong> is 1. Uses many of the same options as <strong>FCIMC</strong>.</p>
<p class="last"><strong>SERIAL</strong> will force NECI to run the serial FCIMC code (which differs
substantially from the parallel) even if the code was compiled in parallel.</p>
</dd>
<dt><strong>VERTEX</strong> <strong>CCMC</strong> [<strong>FCI</strong>] [<strong>EXACTCLUSTER</strong>] [<strong>AMPLITUDE</strong>] [<strong>EXACTSPAWN</strong>] [<strong>BUFFER</strong>]</dt>
<dd><p class="first">Perform Monte Carlo calculations over coupled cluster excitation space, which
is sampled using a series of &#8216;particles&#8217; (or &#8216;walkers&#8217;).</p>
<p>The walkers are not necessarily unique and must be sorted at every
iteration.  Each walker has its own excitation generator.
<strong>DIRECTANNIHILATION</strong> (in CALC) and <strong>NONUNIFORMRANDEXCITS</strong> (in the SYSTEM section)
must also be specified.</p>
<p>If <strong>FCI</strong> is specified, then the code runs an equivalent of the <strong>VERTEX</strong> <strong>FCIMC</strong>
for testing (by only allowing clusters of up to a single excitor, and using (1+T)|D_0&gt;
as the wavefunction rather than exp(T)|D_0&gt;</p>
<p><strong>EXACTCLUSTER</strong> is an exponentially scaling (with number of walkers) algorithm for testing
the stochastic sampling, and explicitly attempts spawning from all clusters in the space.</p>
<p><strong>AMPLITUDE</strong> will enumerate the whole of the allowed space, and assign a floating-point
amplitude to each excitor.  These amplitudes are stochastically sampled (<strong>INITWALKERS</strong>
times per MC cycle), and used to propagate the CCMC.</p>
<p><strong>EXACTSPAWN</strong> causes spawning to be done exactly - i.e. all allowed connected determinants
from a given cluster are spawned to.</p>
<dl class="docutils">
<dt><strong>BUFFER</strong> will accumulate all collapsed cluster selections in a buffer and then do spawnings from that.</dt>
<dd>When using <strong>EXACTCLUSTER</strong> this is much more efficient.</dd>
</dl>
<p class="last">Extremely experimental.</p>
</dd>
<dt><strong>VERTEX</strong> <strong>GRAPHMORPH</strong> [<strong>HDIAG</strong>]</dt>
<dd><p class="first">Set up an initial graph and systematically improve it, by applying the
<img class="math" src="../_images/math/bf4c63b0e04518f08e6142e6637bea99f478500a.png" alt="rho"/> matrix of the graph and its excitations as a propagator
on the largest eigenvector of the graph. From this, an improved graph
is stochastically selected, and the process is repeated, lowering
the energy. If <strong>HDIAG</strong> is specified, it is the hamiltonian matrix
elements which determine the coupling between determinants, and it
is the hamiltonian matrix which is diagonalised in each iteration
in order to calculate the energy.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>GRAPHMORPH</strong> has not been tested with complex wavefunctions.  It will
almost certainly not work for them.</p>
</div>
</dd>
<dt><strong>VERTEX</strong> <strong>MCDETS</strong></dt>
<dd><p class="first">Perform Monte Carlo calculations over pure determinant space, which
is sampled using a series of &#8216;particles&#8217; (or &#8216;walkers&#8217;).</p>
<p><strong>MCDETS</strong> is similar to <strong>FCIMC</strong> but maintains at most one
&#8216;particle&#8217; at each determinant, which may then contain subparticles
(which correspond to the individual &#8216;walkers&#8217; in <strong>FCIMC</strong>), in
a binary tree.  This makes some efficiency savings where the same
information about a determinant is not duplicated.</p>
<p class="last"><strong>FCIMC</strong> and <strong>MCDETS</strong> calculations share many of the same options
(see Walker Monte Carlo options, below).</p>
</dd>
<dt><strong>VERTEX</strong> <strong>RETURNPATHMC</strong></dt>
<dd><p class="first">Use a spawning algorithm which is constrained in three ways:</p>
<ol class="arabic simple">
<li>a particle can only be spawned where it will increase its
excitation level with respect to the reference determinant or
back to where it was spawned from.</li>
<li>they will spawn back to where their parents were spawned from
with probability PRet, which is specified using <strong>RETURNBIAS</strong>.</li>
<li>length of spawning chain must be less than the maximum length
given by <strong>MAXCHAINLENGTH</strong>.</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">How can a particle be restricted to spawning to spawning at most
back to where it was spawned from <em>and</em> have a probability of
spawning back to where its parent was spawed from?
Documentation <em>must</em> be clearer.</p>
</div>
<p>This attempts to circumvent any sign problem in the double
excitations and the HF, and hopefully this will result in a more stable
MC algorithm. It remains to be seen if this approach is useful.  Should
revert to the star graph in the limit of the return bias tending to 1 or
the length of the spawn chain tending to 1.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p><strong>FCIMC</strong>, <strong>GRAPHMORPH</strong>, <strong>MCDETS</strong> and <strong>RETURNPATHMC</strong> have not
been tested with complex wavefunctions.  It will almost certainly
not work for them.</p>
<p class="last">All four are experimental options under development.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="section" id="walker-monte-carlo-options">
<h2>Walker Monte Carlo options<a class="headerlink" href="#walker-monte-carlo-options" title="Permalink to this headline">¶</a></h2>
<p>The following options are applicable for both the <strong>FCIMC</strong> and <strong>MCDETS</strong> methods:</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>I have made some guesses on the following option names.  Clearly some keys are broken
on George&#8217;s keyboard.  Specifically:</p>
<div class="highlight-python"><pre>StepsSft --&gt; STEPSSHIFT
SftDamp  --&gt; SHIFTDAMP
DiagSft  --&gt; DIAGSHIFT</pre>
</div>
<p>I also had to guess about <strong>BINCANCEL</strong>.  It seems to be a <strong>FCIMC</strong>
option, but was placed with <strong>MCSTAR</strong> (and was with all the <strong>VERTEX STAR</strong>
methods).</p>
<p class="last">This section needs to be extended substantially.</p>
</div>
<dl class="docutils">
<dt><strong>DIAGSHIFT</strong> [DiagSft]</dt>
<dd>Set the initial value of the diagonal shift.</dd>
<dt><strong>INITWALKERS</strong> [nWalkers]</dt>
<dd><blockquote class="first">
Default 3000.</blockquote>
<p class="last">Set the initial population of walkers.
For CCMC Amplitude, this is the number of samples of the amplitude distribution taken each MC step</p>
</dd>
<dt><strong>NMCYC</strong> [NMCYC]</dt>
<dd>Set the total number of timesteps to take.</dd>
<dt><strong>SHIFTDAMP</strong>  [SftDamp]</dt>
<dd>Damping factor of the change in shift when it is updated.  &lt;1 means more damping.</dd>
<dt><strong>STEPSSHIFT</strong> [StepsSft]</dt>
<dd><p class="first">Default 100.</p>
<p class="last">Set the number of steps taken before the diagonal shift is updated.</p>
</dd>
<dt><strong>TAU</strong> [TIMESTEP]</dt>
<dd><p class="first">Default 0.0.</p>
<p class="last">For FCIMC, this can be considered the timestep of the simulation. It is a constant which
will increase/decrease the rate of spawning/death for a given iteration.</p>
</dd>
</dl>
<p>The following options are only available in <strong>FCIMC</strong> calculations:</p>
<dl class="docutils">
<dt><strong>READPOPS</strong></dt>
<dd>Read the initial walker configuration from the file POPSFILE.
<strong>DIAGSHIFT</strong> and <strong>INITWALKERS</strong> given in the input will be
overwritten with the values read in form POPSFILE.</dd>
<dt><strong>SCALEWALKERS</strong> [fScaleWalkers]</dt>
<dd>Scale the number of walkers by fScaleWalkers, after having read in data from POPSFILE.</dd>
<dt><strong>STARTMP1</strong></dt>
<dd>Set the initial configuration of walkers to be proportional to the MP1 wavefunction. The shift will also
now be set to the MP2 correlation energy.  This also works in CCMC Amplitude</dd>
<dt><strong>GROWMAXFACTOR</strong> [GrowMaxFactor]</dt>
<dd><p class="first">Default 9000.</p>
<p class="last">Set the factor by which the initial number of particles are allowed to grow before
they are culled.</p>
</dd>
<dt><strong>CULLFACTOR</strong> [CullFactor]</dt>
<dd><p class="first">Default 5.</p>
<p class="last">Set the factor by which the total number of particles is reduced once it reaches the GrowMaxFactor limit</p>
</dd>
<dt><strong>EQUILSTEPS</strong> [NEquilSteps]</dt>
<dd>Default 0
This indicates the number of cycles which have to
pass before the energy of the system from the doubles
population is counted</dd>
<dt><strong>SHIFTEQUILSTEPS</strong> [NShiftEquilSteps]</dt>
<dd>Default 1000
This gives the number of iterations after the shift is allowed to change before the shift
contributes to the average value printed in column 10.
The default is 1000 to simply leave out the first few values where the shift is dropping (usually from 0).</dd>
<dt><strong>RHOAPP</strong> [RhoApp]</dt>
<dd>This is for resummed FCIMC, it indicates the number of propagation steps
around each subgraph before particles are assigned to the nodes</dd>
<dt><strong>SIGNSHIFT</strong></dt>
<dd><p class="first">This is for FCIMC and involves calculating the change in shift depending on
the absolute value of the sum of the signs of the walkers.  This should
hopefully mean that annihilation is implicitly taken into account. Results
were not too good.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">details?  Why &#8220;not good&#8221;?</p>
</div>
</dd>
<dt><strong>HFRETBIAS</strong> [PRet]</dt>
<dd><p class="first">This is a simple guiding function for FCIMC - if we are at a double
excitation, then we return to the HF determinant with a probability PRet.
This is unbiased by the acceptance probability of returning to HF.</p>
<p class="last">This is not available in the parallel version.</p>
</dd>
<dt><strong>EXCLUDERANDGUIDE</strong></dt>
<dd><p class="first">This is an alternative method to unbias for the HFRetBias. It invloves
disallowing random excitations back to the guiding function (HF
Determinant).</p>
<p class="last">This is not available in the parallel version.</p>
</dd>
<dt><strong>PROJECTE-MP2</strong></dt>
<dd><p class="first">This will find the energy by projection of the configuration of walkers
onto the MP1 wavefunction.  DEVELOPMENTAL and possibly not bug-free.</p>
<p class="last">This is not available in the parallel version.</p>
</dd>
<dt><strong>FIXPARTICLESIGN</strong></dt>
<dd><p class="first">This uses a modified hamiltonian, whereby all the positive off-diagonal
hamiltonian matrix elements are zero. Instead, their diagonals are modified
to change the on-site death rate. Particles now have a fixed (positive)
sign which cannot be changed and so no annihilation occurs.  Results were
not good - this was intended for real-space MC, where large regions of connected
space were all of the same sign. This is not the case here.</p>
<p class="last">This is not available in the parallel version.</p>
</dd>
<dt><strong>STARTSINGLEPART</strong></dt>
<dd>This will start the simulation with a single positive particle at the HF,
and fix the shift at its initial value, until the number of particles gets
to the INITPARTICLES value.</dd>
<dt><strong>MEMORYFACPART</strong> [MemoryFacPart]</dt>
<dd><p class="first">Default 10.D0</p>
<p class="last">MemoryFacPart is the factor by which space will be made available for extra
walkers compared to InitWalkers.</p>
</dd>
<dt><strong>MEMORYFACANNIHIL</strong> [MemoryFacAnnihil]</dt>
<dd><p class="first">Default 10.D0</p>
<p class="last">MemoryFacAnnihil is a parallel FCIMC option - it is the factor by which space will be
made available for annihilation arrays compared to InitWalkers. This generally will need to be
larger than memoryfacpart, because the parallel annihilation may not be exactly load-balanced because of
non-uniformity in the wavevector and the hashing algorithm. This will tend to want to be larger
when it is running on more processors.</p>
</dd>
<dt><strong>MEMORYFACSPAWN</strong> [MemoryFacSpawn]</dt>
<dd><p class="first">Default 0.5</p>
<p class="last">A parallel FCIMC option for use with <strong>ROTOANNIHILATION</strong>. This is the factor by which space will be made
available for spawned particles each iteration. Several of these arrays are needed for the annihilation
process. With <strong>ROTOANNIHILATION</strong>, <strong>MEMORYFACANNIHIL</strong> is redundant, but <strong>MEMORYFACPART</strong> still need to be specified.</p>
</dd>
<dt><strong>ANNIHILATEONPROCS</strong></dt>
<dd><p class="first">Default false</p>
<p class="last">A Parallel FCIMC option. With this, particles are annihilated separately on each node.
This should mean less annihilation occurs, but it is effectivly running nProcessor
separate simulations. If there are enough particles, then this should be sufficient.
Less memory is required, since no hashes need to be stored. Also, no communication is
needed, so the routine should scale better as the number of walkers grows.</p>
</dd>
<dt><strong>ROTOANNIHILATION</strong></dt>
<dd><p class="first">Default false</p>
<p class="last">A parallel FCIMC option which is a different - and hopefully better scaling - algorithm.
This is substantially different to previously. It should involve much less memory.
<strong>MEMORYFACANNIHIL</strong> is no longer needed (<strong>MEMORYFACPART</strong> still is), and you will need
to specify a <strong>MEMORYFACSPAWN</strong> since newly spawned walkers are held on a different array each iteration.
Since the newly-spawned particles are annihilated initially among themselves, you can still
specify <strong>ANNIHILATEATRANGE</strong> as a keyword, which will change things.</p>
</dd>
<dt><strong>FIXSHELLSHIFT</strong> [ShellFix] [FixShift]</dt>
<dd><p class="first">Default 0,0.D0</p>
<p class="last">An FCIMC option. With this, the shift is fixed at a value given here,
but only for the excitation levels at a value of ShellFix or lower. This will
almost definitly give the wrong answers for both the energy and the shift,
but may be of use in equilibration steps to maintain particle density at
low excitations, before writing out the data and letting the shift change.</p>
</dd>
</dl>
<p><strong>FIXKIISHIFT</strong> FixedKiiCutoff FixShift</p>
<blockquote>
Another fixed shift based approximation method for FCIMC in parallel. However, rather
than fixing the shift based on an excitation level, it is now fixed according to the
Kii value. Determinants lower in energy than FixedKiiCutoff will have their shifts
fixed to the value given.</blockquote>
<dl class="docutils">
<dt><strong>FIXCASSHIFT</strong> [OccCASorbs] [VirtCASorbs] [FixShift]</dt>
<dd><p class="first">Default 0 0 0.D0</p>
<p class="last">A third fixed shift approximation method for FCIMC in parallel.  In this option, an active
space is chosen containing a number of highest occupied spin orbitals (OccCASorbs) and a
number of lowest unoccupied spin orbitals (VirtCASorbs).  The shift is then fixed (at FixShift)
for determinants with excitations within this space only.  I.e. determinants for which the spin
orbitals lower in energy than the active space are completely occupied and those higher in
energy are completely unoccupied.</p>
</dd>
<dt><strong>SINGLESBIAS</strong> [SinglesBias]</dt>
<dd><p class="first">Default 1.D0</p>
<p class="last">This represents the factor to which singles are biased towards over double excitations from a determinant.
This works with the NONUNIFORMRANDEXCITS excitation generators for FCIMC code. Normally, the
pDoubles is given by the number of doubles divided by the total excitations from HF. Now,
the number of singles in the total excitations term is multiplied by SinglesBias. Alternatively,
SinglesBias can be set to less than 1 to bias towards doubles.</p>
</dd>
<dt><strong>FINDGROUNDDET</strong></dt>
<dd><p class="first">Default=.false.</p>
<p class="last">A parallel FCIMC option. If this is on, then if a determinant is found with an energy lower
than the energy of the current reference determinant, the energies are rezeroed and the
reference changed to the new determinant. For a HF basis, this cannot happen, but with
rotated orbital may be important.</p>
</dd>
<dt><strong>DEFINEDET</strong> [DefDet(NEl)]</dt>
<dd><p class="first">Default=.false.</p>
<p class="last">A parallel FCIMC option.  This allows the reference determinant to be chosen based on that specified in
the input with this keyword - rather than the default HF determinant chosen according to the energies of
the orbitals.  The determinant is specified by a series of NEl integers (separated by spaces)
which represent the occupied spin orbitals.</p>
</dd>
<dt><strong>DIRECTANNIHILATION</strong></dt>
<dd><p class="first">Default=.false.</p>
<p class="last">A parallel FCIMC option. This annihilation algorithm has elements in common with rotoannihilation
and the default annihilation, but should be faster and better scaling than both of these, with
respect to the number of processors. There are no explicit loops over processors, and newly-spawned
particles are sent directly to their respective processors.</p>
</dd>
<dt><strong>ANNIHILATEEVERY</strong> [iAnnInterval]</dt>
<dd><p class="first">Default=1</p>
<p class="last">A parallel FCIMC option which can only be used with default annihilation algorihtm. This will
mean that annihilation will only occur every iAnnInterval iterations.</p>
</dd>
<dt><strong>ANNIHILATDISTANCE</strong> [Lambda]</dt>
<dd><p class="first">Default=0.D0</p>
<p class="last">A serial FCIMC option. Here, walkers i and j have the chance to annihilate each other
as long as they are on connected determinants. They will annihilate with probability
given by -Lambda*Hij*(Si*Sj). This is hoped to increase annihilation and allow fewer
particles to be needed to sample the space correctly. When Lambda=0.D0, it should be
equivalent to the original annihilation algorithm. Warning - this is much slower than
normal annihilation.</p>
</dd>
<dt><strong>ANNIHILATERANGE</strong> [<strong>OFF</strong>]</dt>
<dd><p class="first">Default=.true.</p>
<p class="last">A parallel FCIMC option. This is a slightly different annihilation algorithm, where only
one sort of the full set of particles is needed. This should greatly reduce the time needed
for annihilation of large numbers of particles. However, the load-balancing across processors
may not be so good. This option is now on by default and can only be switched off via the input
file by specifying <strong>OFF</strong> after the keyword.</p>
</dd>
</dl>
<p><strong>LOCALANNIHIL</strong> [Lambda]</p>
<blockquote>
<p>A parallel FCIMC option. An additional diagonal death rate is included at the annihilation
stage for particles which are only singly occupied. The probability of death is given by
Tau*EXP(-Lambda*ExcitDensity) where ExcitDensity is the approximate density of particles in
the excitation level of the particle. This should raise death through this local annihilation,
and hence keep the shift at a more resonable value in the undersampled regime. This will
hopefully mean that a more accurate energy value can be obtained by removing the random
killing of particles which arises from such a low shift value.</p>
<p>This is now commented out in the code</p>
</blockquote>
<dl class="docutils">
<dt><strong>UNBIASPGENINPROJE</strong></dt>
<dd><p class="first">Default false</p>
<p class="last">An FCIMC serial option. Here, the acceptance probabilities are not unbiased for
the probability of generating the excitation. Instead, the unbiasing occurs when the
walker contributes to the energy estimator. This should reduce the variance for the
energy estimator.</p>
</dd>
<dt><strong>GLOBALSHIFT</strong> <strong>OFF</strong></dt>
<dd><p class="first">Default true</p>
<p>This option can only be turned off by specifying <strong>OFF</strong></p>
<p class="last">A parallel FCIMC option. It is generally recommended to have this option on. This will
calculate the growth rate of the system as a simple ratio of the total walkers on all processors
before and after update cycle, rather than a weighted average. This however is incompatable with culling, and so
is removed for update cycles with this in. This should be more stable than the
default version and give a more reliable shift estimator for large systems.</p>
</dd>
<dt><strong>MAGNETIZE</strong> [NoMagDets] [BField]</dt>
<dd><p class="first">Default false</p>
<p class="last">This is a parallel FCIMC option. It chooses the largest weighted MP1 components and records their
sign. If then a particle occupies this determinant and is of the opposite sign, it energy,
i.e. diagonal matrix element is raised by an energy given by BField. First parameter is an
integer indicating the number of determinants to &#8216;magnetize&#8217;, and the second is a real
giving the amount the energy of a particle should be raised if it is of an opposite sign.</p>
</dd>
<dt><strong>MAGNETIZESYM</strong> [NoMagDets] [BField]</dt>
<dd><p class="first">Default false</p>
<p class="last">A parallel FCIMC option. Similar to the MAGNETIZE option (same arguments), but in addition to
the energy being raised for particles of the opposite sign, the energy is lowered by the same
amount for particles of &#8216;parallel&#8217; sign.</p>
</dd>
<dt><strong>GRAPHSIZE</strong> [NDets]</dt>
<dd>In ResumFCIMC, this is the number of connected determinants to form the
graph which you take as your sumsystem for the resummed spawning.  Must
have an associated RhoApp.</dd>
<dt><strong>HAPP</strong> [HApp]</dt>
<dd><p class="first">Default 1.</p>
<p class="last">In ResumFCIMC, this indicates the number of local applications of the
hamiltonian to random determinants before the walkers are assigned
according to the resultant vector.</p>
</dd>
<dt><strong>NOBIRTH</strong></dt>
<dd><p class="first">Force the off-diagonal <img class="math" src="../_images/math/b1902d279ba37d60bdce4e0e987b7cd19d48974e.png" alt="H"/> matrix elements to become zero,
and hence obtain an exponential decay of the initial populations
on the determinants, at a rate which can be exactly calculated and
compared against.</p>
<p class="last">This is no longer functional, but commented out in the
code.</p>
</dd>
<dt><strong>MCDIFFUSE</strong> [Lambda]</dt>
<dd><p class="first">Default 0.0.</p>
<p>Set the amount of diffusion compared to spawning in the <strong>FCIMC</strong>
algorithm.</p>
<p class="last">This is no longer functional and commented out in the code.</p>
</dd>
<dt><strong>FLIPTAU</strong> [FlipTauCyc]</dt>
<dd><p class="first">Default: off.</p>
<p>Cause time to be reversed every FlipTauCyc cycles in the <strong>FCIMC</strong>
algorithm. This might help with undersampling problems.</p>
<p class="last">This is no longer functional and commented out in the code.</p>
</dd>
<dt><strong>NON-PARTCONSDIFF</strong></dt>
<dd><p class="first">Use a seperate partitioning of the diffusion matrices, in which
the antidiffusion matrix (+ve connections) create a net increase of
two particles.</p>
<p class="last">This is no longer functional and commented out in the code.</p>
</dd>
<dt><strong>FULLUNBIASDIFF</strong></dt>
<dd><p class="first">Fully unbias for the diffusion process by summing over all connections.</p>
<p class="last">This is no longer functional and commented out in the code.</p>
</dd>
<dt><strong>NODALCUTOFF</strong> [NodalCuttoff]</dt>
<dd><p class="first">Constrain a determinant to be of the same sign as the MP1
wavefunction at that determinant, if the normalised component of
the MP1 wavefunction is greater than the NodalCutoff value.</p>
<p class="last">This is no longer functional and commented out in the code.</p>
</dd>
<dt><strong>NOANNIHIL</strong></dt>
<dd>Remove the annihilation of particles on the same
determinant step.</dd>
<dt><strong>REGENDIAGHELS</strong></dt>
<dd>Default .false.
This is a parallel FCIMC option, which means that the diagonal hamiltonian matrix
element for each particle is calculated on the fly, rather than stored with the
particle. This will free up more memory, but will probably lead to slightly slower
calculations.</dd>
<dt><strong>REGENEXCITGENS</strong></dt>
<dd>This option will regenerate the excitation generator for each particle, every time a
new random excitation is wanted. This is MUCH slower for the same number of particles
(10x?). However, this frees up a lot more memory to store more particles.</dd>
<dt><strong>PRINTDOMINANTDETS</strong> [NoDeterminants] [MinExcLevel] [MaxExcLevel]</dt>
<dd><p class="first">Default=.false.</p>
<p class="last">This is a parallel FCIMC option.  With this keyword, at the end of a calculation a DOMINANTDETS file
is printed containing the NoDeterminants most populated determinants between excitation
levels of MinExcLevel and MaxExcLevel (inclusive).  This must be used with rotoannihilation.</p>
</dd>
<dt><strong>PRINTDOMSPINCOUPLED</strong> [OFF]</dt>
<dd><p class="first">Default=.true.</p>
<p class="last">This a parallel FCIMC option to go with the one above.  It takes the list of dominant determinants
chosen based on their populations and adds to the list all the spin coupled determinants that
are not already there.  This prevents any spin contamination when we truncate the available
determinants.  This is automatically on, but can be turned off using this keyword followed by OFF.</p>
</dd>
<dt><strong>SPAWNDOMINANTONLY</strong></dt>
<dd><p class="first">Default=.false.</p>
<p class="last">This is a parallel FCIMC option.  It takes a DOMINANTDETS file (printed using the above keywords)
and reads it in at the beginning of the calculation.  During the calculation, if a walker is
to be spawned with an excitation level of those printed in DOMINANTDETS, this is only allowed if
the determinant is in the list of dominant determinants.  This does not allow truncation of
the doubles, and must be used with rotoannihilation.</p>
</dd>
<dt><strong>STARMINORDETERMINANTS</strong></dt>
<dd><p class="first">Default=.false.</p>
<p class="last">This is a parallel FCIMC option.  It goes along with the <strong>SPAWNDOMINANTONLY</strong> keyword.  If this
is present, spawning to determinants not in the dominant list is done with a star approximation.
That is, spawning onto minor determinants is allowed, but these walkers are only allowed
to spawn back to the parent from which they came.  The walkers undergo death and annihilation
like usual (however, the walkers for annihilation are chosen randomly as they differ depending
on their parent).</p>
</dd>
<dt><strong>FINDGUIDINGFUNCTION</strong> [iGuideDets]</dt>
<dd><p class="first">Default=.false. [100]</p>
<p class="last">This is a parallel FCIMC option.  At the end of a spawning calculation, the iGuideDets most populated
determinants are found and these and their final walker populations (with sign) are printed out
(in order of their bit strings) to a file named GUIDINGFUNC to be used in the subsequent calculation.</p>
</dd>
<dt><strong>USEGUIDINGFUNCTION</strong> [iInitGuideParts]</dt>
<dd><p class="first">Default=.false.</p>
<p class="last">This is a parallel FCIMC option.  This option takes the GUIDINGFUNC file produced in a previous calculation
and reads in the guiding (or annihilating) function from it.  The population on the HF determinant in this
guiding function is then set to be iInitGuideParts, and the remaining determinants are populated based on
their occupations from the previous calculation (in GUIDINGFUNC) relative to the HF determinant.
The function of this guiding function is then to sit in the background of a calculation, able to annihilate
walkers, but unable to itself spawn of have its walkers die.
Assuming the GUIDINGFUNC from the previous calculation has the correct nodal structure, this guiding function
should serve to instantly remove walkers spawned with the incorrect sign.</p>
</dd>
<dt><strong>TRUNCATECAS</strong> [OccCASOrbs] [VirtCASOrbs]</dt>
<dd>This is a parallel FCIMC option, whereby the space will be truncated according to the specified CAS.
The arguments indicate the active electrons, and then the number of active virtual orbitals.
These values can be dynamically updated throughout the simulation via use of the CHANGEVARS facility.</dd>
<dt><strong>TRUNCINITIATOR</strong></dt>
<dd>This is a parallel FCIMC option.  The keyword requires an initiator space to first be defined (usually
via <strong>TRUNCATECAS</strong>, but could be by <strong>EXCITE</strong>).
This is then a variation on a kind of CAS-star approach.  Spawning is subject to the contraint
that walkers spawned from determinants outside the active space only live if they are being spawned onto
determinants that are already occupied.  If walkers spawned on a new determinant have non-initiator parents,
these spawns are &#8216;aborted&#8217;.  A special case is if in the same iteration walkers are spawned on a new
determinant both from inside and outside the active space - in this case we treat the active space to have
spawned a second earlier, the determinant is then treated as occupied and the non-active space walkers are
allowed to live (providing they are the same sign of course).
NOTE: This is currently only possible using <strong>DIRECTANNIHILATION</strong>.</dd>
<dt><strong>DELAYTRUNCINITIATOR</strong> [IterTruncInit]</dt>
<dd>This goes with the above.  This allows us to first start with an active space only calculation and then at some
iteration (given by IterTruncInit), to expand to the <strong>TRUNCINITIATOR</strong> method.  The beginning of the
<strong>TRUNCINITIATOR</strong> method may also be started dynamically by putting TRUNCINITIATOR in the CHANGEVARS file.
At the moment, when this happens, tau is also reduced by a factor of 10.  This should maybe be played with at
some stage though.</dd>
<dt><strong>KEEPDOUBSPAWNS</strong></dt>
<dd>This keyword goes along with the above <strong>TRUNCINITIATOR</strong>.  This is an extra exception which means that if
two determinant spawn on the same determinant with the same sign, they are allowed to live no matter where they
came from.  This is different from the original case where if both of these had come from non-initiator
determinants, they would have both been killed.</dd>
<dt><strong>ADDTOINITIATOR</strong> [InitiatorWalkerNo]</dt>
<dd>This is again an addition to the above few options.  In this case, if a determinant outside the initiator space
builds up a significant population (greater than InitiatorWalkerNo), it is treated as being in the initiator
space and may spawn on occupied or unoccupied determinants as it likes.  This is reassessed at each iteration
however, so determinant may move in and out of the initiator space as the populations vary.</dd>
<dt><strong>INCLDOUBSINITIATOR</strong></dt>
<dd>This keyword also goes with <strong>TRUNCINITIATOR</strong>, and is a parallel FCIMC option.  When it is present, all doubly
excited determinants are included in the initiator space, and are allowed to spawn as usual.</dd>
</dl>
<p>The following option are only available in <strong>MCSTAR</strong> calculations:</p>
<dl class="docutils">
<dt><strong>BINCANCEL</strong></dt>
<dd>This is a seperate method to cancel down to find the residual
walkers from a list, involving binning the walkers into their
determinants. This has to refer to the whole space, and so is
much slower.  See also the <strong>WAVEVECTORPRINT</strong> and <strong>POPSFILE</strong>
options in the <strong>LOGGING</strong> block.</dd>
<dt><strong>STARORBS</strong> [iStarOrbs] [<strong>NORETURN</strong> | <strong>ALLSPAWNSTARDETS</strong>]</dt>
<dd><p class="first">Default=.false. , NORETURN = OFF</p>
<p class="last">A parallel FCIMC option. Star orbs means that determinants which
contain these orbitals can only be spawned at from the HF determinant,
and conversly, can only spawn back at the HF determinant. iStarOrbs is
the integer variable which decides how many orbitals are in this high-
energy space, and take the iStarOrbs number of highest energy orbitals
to construct it. <strong>NORETURN</strong> is an optional keyword specifier. If it
is specified, then any excitations from the HF to these high-energy
determinants (doubles) are left to die and cannot respawn back to the
HF determinant. <strong>ALLSPAWNSTARDETS</strong> is another optional keyword, which
means that all particles can spawn at determinants with star orbitals, and
once there, annihilation can occur. However, they cannot respawn anywhere
else and are left there to die.</p>
</dd>
<dt><strong>EXCITETRUNCSING</strong> [iHightExcitsSing]</dt>
<dd><p class="first">Default=.false.</p>
<p class="last">This is a parallel FCIMC option, where excitations between determinants where
at least one of the determinants is above iHighExcitsSing will be restricted to be single excitations.</p>
</dd>
<dt><strong>EXPANDFULLSPACE</strong> [iFullSpaceIter]</dt>
<dd><p class="first">Default=0</p>
<p class="last">This is a parallel FCIMC option. When this is set, the space initially is truncated at excitation level of ICIlevel,
set by the value of the EXCITE parameter, or the CAS space given by TRUNCATECAS. If EXPANDFULLSPACE is set, then the
system will continue to be truncated, but will
expand to the full space after iteration iFullSpaceIter.
Hopefully expanding the space in this way will allow quicker
convergence, without needing to do this dynamically through the use of CHANGEVARS which may be difficult for
long/queued jobs.</p>
</dd>
</dl>
<p><strong>INITAMPLITUDE</strong> dInitAmplitude</p>
<blockquote>
For CCMC Amplitude, this is the initial amplitude in the Hartree-Fock determinant, and normalization factor for the wavefunction.
Default 1.0</blockquote>
<p><strong>CLUSTERSIZEBIAS</strong> dProbSelNewExcitor</p>
<blockquote>
For CCMC Amplitude, this is the probability that the cluster selection algorithm terminates after each addition of an excitor.
Larger values will bias towards smaller cluster.
Default 0.7 (Range 0-1)</blockquote>
<p><strong>NSPAWNINGS</strong> nSpawnings</p>
<blockquote>
For CCMC, this is the number of spawnings attempted from each cluster (unless <strong>EXACTSPAWN</strong> is specified).  Default 1</blockquote>
<dl class="docutils">
<dt><strong>SPAWNPROP</strong></dt>
<dd>For Amplitude CCMC use NSPAWNINGS as a total number of spawnings, and distribute them according to the Amplitudes of clusters.</dd>
</dl>
</div>
<div class="section" id="return-path-monte-carlo-options">
<h2>Return Path Monte Carlo options<a class="headerlink" href="#return-path-monte-carlo-options" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><strong>MAXCHAINLENGTH</strong> [CLMAX]</dt>
<dd>Set the maximum allowed chain length before a particle is forced to
come back to its origin.</dd>
<dt><strong>RETURNBIAS</strong> [PRet]</dt>
<dd>Set the bias at any point to spawn at the parent determinant.</dd>
</dl>
</div>
<div class="section" id="perturbation-theory-options">
<h2>Perturbation theory options<a class="headerlink" href="#perturbation-theory-options" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><strong>MPTHEORY</strong> [<strong>ONLY</strong>]</dt>
<dd><p class="first">In addition to doing a graph theory calculation, calculate the Moller&#8211;Plesset
energy to the same order as the maximum vertex level from the
reference determinant (e.g. with 2-vertex sum the MP2 energy is
obtained, with 3-vertex the MP3 energy etc.  Within the <strong>VERTEX SUM</strong>
hierarchy, this will only work with <strong>VERTEX SUM HDIAG</strong>.
In the <strong>VERTEX MC</strong> hierarchy, do a Moller&#8211;Plesset calculation
instead of a path-integral one.  Requires <strong>HDIAG</strong>, and <strong>BIAS**=0.D0.
Can be used without a **METHODS</strong> section.  If a <strong>METHODS</strong> section is
needed to specify different numbers of cycles at each level, then
<strong>MCDIRECTSUM</strong> must also be set, either in the main block of the <strong>CALC</strong>,
or by using <strong>VERTEX MCDIRECT</strong> instead of <strong>VERTEX MC</strong>.
Note that the MP2 energy
can be obtained in conjunction with a <strong>VERTEX STAR</strong> calculation.</p>
<dl class="last docutils">
<dt><strong>ONLY</strong></dt>
<dd><p class="first">Run only a MP2 calculation.  This is only available when
compiled in parallel.  The only relevant <strong>CALC</strong> options are the
<strong>EXCITATIONS</strong> options: all other <strong>CALC</strong> keywords are ignored
or over-ridden.  No <strong>LOGGING</strong> options are currently applicable.</p>
<p>Whilst in principle integrals are only used once, this optimal
algorithm is not currently implemented.  The speed of a <strong>CPMD</strong>-based
calculation thus benefits from having a <strong>UMatCache</strong> of non-zero size.</p>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It is currently assumed that the calculation is restricted.</p>
</div>
</dd>
</dl>
</dd>
<dt><strong>EPSTEIN-NESBET</strong></dt>
<dd>Apply Epstein&#8211;Nesbet perturbation theory, rather than
Moller&#8211;Plesset.  Only works for <strong>VERTEX SUM NEW</strong> and <strong>VERTEX
SUM HDIAG</strong> and only at the 2-vertex level.</dd>
<dt><strong>LADDER</strong></dt>
<dd>Use ladder diagram perturbation theory, rather than Moller&#8211;Plesset.
The energy denominator is <img class="math" src="../_images/math/074a66f869ce67a51ae0772b0210c30c65fba5f8.png" alt="E_0-E_I+|H_{0I}|^2"/>.  Only works
for <strong>VERTEX SUM NEW</strong> and <strong>VERTEX SUM HDIAG</strong> and only at the
2-vertex level.</dd>
<dt><strong>MODMPTHEORY</strong></dt>
<dd>Perform a hybrid of Epstein&#8211;Nesbet and Moller&#8211;Plesset theory,
which includes only the <img class="math" src="../_images/math/a694a368326cf8167b27d023c785bc5f091468d4.png" alt="\bra ij||ij ket +\bra ab||ab ket"/>
terms in the denominator.  Only works for <strong>VERTEX SUM NEW</strong> and
<strong>VERTEX SUM HDIAG</strong> and only at the 2-vertex level.</dd>
</dl>
</div>
<div class="section" id="diagonalisation-options">
<h2>Diagonalisation options<a class="headerlink" href="#diagonalisation-options" title="Permalink to this headline">¶</a></h2>
<p>Options for performing a full diagonalisation in the space of the full
basis of spin orbitals.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This quickly becomes prohibitively expensive as system size increases.</p>
</div>
<dl class="docutils">
<dt><strong>ACCURACY</strong> [B2L]</dt>
<dd>Desired level of accuracy for Lanczos routine.</dd>
<dt><strong>BLOCK</strong> [<strong>ON</strong> <strong>OFF</strong>]</dt>
<dd><p class="first">Default off.</p>
<p class="last">Determines whether the Hamiltonian is calculated for each block
or not.  This only works for <strong>COMPLETE</strong>.</p>
</dd>
<dt><strong>BLOCKS</strong> [NBLK]</dt>
<dd>Set number of blocks used in Lanczos diagonalisation.</dd>
<dt><strong>COMPLETE</strong></dt>
<dd>Perform a full diagonalisation working out all eigenvectors
and eigenvalues.  if <strong>HAMILTONIAN</strong> is <strong>OFF</strong>, discard the
eigenvectors and eigenvalues after having used them for calculation.
Relevant options are <strong>HAMILTONIAN</strong> and <strong>BLOCK</strong>.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When would it be advantageous to save the eigenvalues and -vectors
are a diagonalisation?</p>
</div>
<dl class="docutils">
<dt><strong>EIGENVALUES</strong> [NEVAL]</dt>
<dd>Required number of eigenvalues.</dd>
<dt><strong>ENERGY</strong></dt>
<dd><p class="first">Calculate the energy by diagonalising the Hamiltonian matrix.
Requires one of <strong>COMPLETE</strong>, <strong>LANCZOS</strong>, or <strong>READ</strong> to be set.</p>
<p>Exact E(Beta) is printed out as:</p>
<div class="math">
<p><img src="../_images/math/b52180a1b9b1f31e6986cbe22598751ce073eae8.png" alt="\text{E(Beta)} = \frac{ \sum_{\alpha} E_{\alpha} e^{-\beta E_{\alpha}} } { \sum_{\alpha} e^{-\beta E_{\alpha}} }" /></p>
</div><p>The result will, of course, change depending upon the symmetry subspace
chosen for diagonalization for finite temperatures.</p>
<p>The diagonalization procedure creates a list of determinants, which
is printed out to the DETS file.</p>
<p>The weight, <img class="math" src="../_images/math/2f9bebd47a65cbf03bb3d4fdb77c8c59cc60b6f7.png" alt="w_{\veci}"/> and weighted energy, <img class="math" src="../_images/math/8d621fdec547ece7a904ffb59253d8fd0c942d38.png" alt="w_{\veci}
\tilde{E}_{\veci}"/> are also calculated for all NPATH determinants.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p><strong>ENERGY</strong> was documented twice in the INPUT_DOC file.  This is not
particularly helful...</p>
<p class="last">I have (hopefully) combined them correctly.</p>
</div>
</dd>
</dl>
<p><strong>JUSTFINDDETS</strong></p>
<blockquote>
This is an option to be used in conjunction with <strong>ENERGY</strong> and exact diagonalization methods.
If specified, the diagonalization routines will just enumerate all the determinants and will
not try to form the hamiltonian or diagonalize it. No energy will therefore be found, but
enumerating all the determinants can be useful for histogramming methods in FCIMC methods.</blockquote>
<dl class="docutils">
<dt><strong>KRYLOV</strong> [NKRY]</dt>
<dd>Set number of Krylov vectors.</dd>
<dt><strong>LANCZOS</strong></dt>
<dd><p class="first">Perform a Lanczos block diagonalisation on the Hamiltonian matrix.</p>
<p class="last">Relevant parameters are <strong>BLOCKS</strong>, <strong>KRYLOV</strong>, <strong>ACCURACY</strong>,
<strong>STEPS</strong> and <strong>EIGENVALUES</strong>.</p>
</dd>
<dt><strong>READ</strong></dt>
<dd>Read in eigenvectors and eigenvalues of the Hamiltonian matrix from a previous calculation.</dd>
<dt><strong>STEPS</strong> [NCYCLE]</dt>
<dd>Set the number of steps used in the Lanzcos diagonalisation.</dd>
</dl>
</div>
<div class="section" id="graph-morphing-options">
<h2>Graph morphing options<a class="headerlink" href="#graph-morphing-options" title="Permalink to this headline">¶</a></h2>
<p>A new approach developed by George Booth.  Take an initial starting graph
and over many iterations allow the determinants contained within the
graph to change, so that the resultant graph is a better approximation
to the true ground state.</p>
<dl class="docutils">
<dt><strong>GRAPHBIAS</strong> [GraphBias]</dt>
<dd>If at each iteration the graph is being completely renewed, then this
bias specifies the probability that an excitation of the previous
graph is selected to try and be attached, rather than one of the
determinants in the previous graph.</dd>
<dt><strong>GRAPHSIZE</strong> [NDets]</dt>
<dd>Specify the number of determinants in the graph to morph.</dd>
<dt><strong>GROWGRAPHSEXPO</strong> [GrowGraphsExpo]</dt>
<dd><p class="first">Default is 2.D0.</p>
<p class="last">The exponent to which the components of the excitations vector
and the eigenvector are raised in order to turn them into
probabilities. The higher the value, the more that larger weighted
determinants will be favoured, though this might result in the graph
growing algorithm getting stuck in a region of the space.</p>
</dd>
<dt><strong>GROWINITGRAPH</strong></dt>
<dd>Grow the initial graph non-stochastically from the excitations of
consecutive determinants.</dd>
<dt><strong>INITSTAR</strong></dt>
<dd><p class="first">Set up the completely connected two-vertex star graph, and use as
the starting point for the morphing.</p>
<p class="last">Automatically changes the NDets parameter to reflect the number of
double excitations in the system.</p>
</dd>
<dt><strong>ITERATIONS</strong> [Iters]</dt>
<dd>The number of graph morphing iterations to perform.</dd>
<dt><strong>MAXEXCIT</strong> [iMaxExcitLevel]</dt>
<dd>Limit the size of the excitation space by only allowing excitations
out to iMaxExcitLevel away from HF reference determinant.</dd>
<dt><strong>MCEXCITS</strong> [NoMCExcits]</dt>
<dd>Stochastically sample the space of excitations from each determinant in the
graph with NoMCExcits determinants chosen per determinant.
For the FCIMC code, this represents the number of attempted spawns per iteration
in the spawning step.</dd>
<dt><strong>MOVEDETS</strong> [NoMoveDets]</dt>
<dd>Grow the graphs using an alternative Monte Carlo, where a number
of determiants are deleted from the previous graph and reattached
elsewhere in the graph in a stochastic manner, according to the
probabilities given by the application of the <img class="math" src="../_images/math/bf4c63b0e04518f08e6142e6637bea99f478500a.png" alt="rho"/> propagator
to the eigenvector of the previous graph.</dd>
<dt><strong>NOSAMEEXCIT</strong></dt>
<dd>Ignore the connections between determinants which are of the
same excitation level in comparison to the reference determinant.
Currently only available in conjunction with <strong>INITSTAR</strong>, so the
starting graph is simply the doubles star graph (with no cross
connections).</dd>
<dt><strong>ONEEXCITCONN</strong></dt>
<dd>Grow the graph by attaching only determinants which differ by one
excitation level to the connecting vertex in the previous graph.
Currently not implemented with MoveDets.</dd>
<dt><strong>SINGLESEXCITSPACE</strong></dt>
<dd>Restrict the space into which the current graph is allowed to morph
to just single excitations of the determinants in the current graph.
This should reduce the scaling of the algorithm.</dd>
</dl>
</div>
<div class="section" id="monte-carlo-options">
<h2>Monte Carlo options<a class="headerlink" href="#monte-carlo-options" title="Permalink to this headline">¶</a></h2>
<p>Options for performing a Monte Carlo calculation on a vertex sum (as
specified in the <strong>METHODS</strong> section).</p>
<p>The Monte Carlo routines have only ever been tested for molucular and
model systems and probably are not currently functional for <strong>CPMD</strong>
or <strong>VASP</strong> based calculations.</p>
<p>See the reports by Ramin Ghorashi (<a class="reference external" href="../references.html#rgptiii">[RGPtIII]</a>) and George Booth
(<a class="reference external" href="../references.html#ghbcpgs">[GHBCPGS]</a>).</p>
<dl class="docutils">
<dt><strong>CALCVAR</strong></dt>
<dd><p class="first">Only available for performing full vertex sums using the <strong>HDIAG</strong>
formulation to evaluate the thermal density matrix elements.</p>
<p class="last">Calculate a theoretical approximation to the expected variance if a
non-stochastic MC run were to be performed, with the parameters given,
at the chosen vertex level.  Currently the expected variance is sent
to STOUT as a full variance for the total energy ratio.  Causes the
calculation to take longer since the generation probabilities of
the graphs must all be calculated.  The sum over graphs of the
generation probabilities is also printed out for each vertex
level. This should equal 1, since we are working with normalised
probabilities.</p>
</dd>
<dt><strong>POSITION</strong> [IOBS JOBS KOBS]</dt>
<dd>Sets the position of the reference particle.</dd>
<dt><strong>CIMC</strong></dt>
<dd>Perform a configuration interation space Monte Carlo.</dd>
<dt><strong>BETAEQ</strong> [BETAEQ]</dt>
<dd><p class="first">Default is set to be <img class="math" src="../_images/math/fdb63b9e51abe6bbb16acfb5d7b773ddbb5bf4a8.png" alt="\beta"/>, as set above.</p>
<p>Set <img class="math" src="../_images/math/fdb63b9e51abe6bbb16acfb5d7b773ddbb5bf4a8.png" alt="\beta"/> to have a different value for the equilibriation steps.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">What are the equilibriation steps?</p>
</div>
</dd>
<dt><strong>BIAS</strong> [G_VMC_FAC]</dt>
<dd><p class="first">Default 16.</p>
<p>Vertex level bias for <strong>FULL</strong> <strong>MC</strong>. Positive values bias toward
larger graphs, negative values towards smaller graphs.</p>
<p>For <strong>SINGLE</strong> and <strong>MULTI</strong> level MC (using a composite 1-vertex
graph containing a full sum previously performed), this is the
probability of generating a graph which is not the composite graph.
The default is invalid, and this must be set manaully.  Stochastic
time MC is used.  If BIAS is negative, then | BIAS | is used, but
stochastic-time MC is not performed.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">BIAS seems to do two very different things if it is set to a negative value.
Please clarify.</p>
</div>
</dd>
<dt><strong>DETSYM</strong> [MDK(I), I=1,4]</dt>
<dd><p class="first">The symmetry of the <strong>CIMC</strong> determinant.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Specify the symmetry how?</p>
</div>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If any if the <strong>CIMC</strong> options are set without <strong>CIMC</strong> being
specified, the code will return an error and exit.**</p>
</div>
</dd>
<dt><strong>EQSTEPS</strong> [IEQSTEPS]</dt>
<dd>The number of equilibriation sets for the CI space Monte Carlo routine.</dd>
<dt><strong>GRAPHEPSILON</strong> [GRAPHEPSILON]</dt>
<dd><p class="first">Default 0.0.</p>
<p>The minimum significant value of the weight of a graph.</p>
<p class="last">Ignore the contributions to the weight and <img class="math" src="../_images/math/2b1307ee5ae475b35c4806a1cd01768feb63260b.png" alt="\tilde{E}"/> of all
graphs with a weight that is smaller in magnitude than GRAPHEPSILON.</p>
</dd>
<dt><strong>IMPORTANCE</strong> [G_VMC_PI]</dt>
<dd><p class="first">Ddefault 0.95.</p>
<p class="last">Set the generation probability for the MC routine.  This is the
probability that new determinants are excitations of the pivot, i.</p>
</dd>
<dt><strong>MCDIRECTSUM</strong></dt>
<dd>Perform Monte Carlo on graphs summing in energies weighted with the
weight/generation probability of the graph.</dd>
<dt><strong>PGENEPSILON</strong> [PGENEPSILON]</dt>
<dd><p class="first">Default 0.0.</p>
<p>Set the minimum significant value of the generation probability of a graph.</p>
<p>Because for larger graphs, the calculation of the generation
probability is subject to numerical truncation errors, generation
probabilities which are lower than a certain value are unreliable,
and can cause the Monte Carlo algorithm to get stuck: if a graph had a
very small generation probability, it would be difficult for a Monte
Carlo run to accept a move to a different graph.  If the magnitude
of the generation probability of a graph is smaller than PGENEPSILON,
then a new graph is generated.</p>
<p class="last">Setting this too high could cause problems in the graph generation phase,
so NECI will exit with an error if it generates 10000 successive
graphs each with generation probabilities below PGENEPSILON.</p>
</dd>
<dt><strong>SEED</strong> [G_VMC_SEED]</dt>
<dd><p class="first">Default -7.</p>
<p class="last">Set the random seed required for the Monte Carlo calculations.</p>
</dd>
<dt><strong>STEPS</strong> [IMCSTEPS]</dt>
<dd>Set the number of steps for the CI space Monte Carlo routine.</dd>
<dt><strong>VVDISALLOW</strong></dt>
<dd>Disallow V-vertex to V&#8217;-vertex transitions in stochastic time Monte
Carlo: i.e. allow only transitions to graphs of the same size.</dd>
</dl>
<div class="section" id="weighting-schemes">
<h3>Weighting schemes<a class="headerlink" href="#weighting-schemes" title="Permalink to this headline">¶</a></h3>
<p>By default the vertex sum Monte Carlo algorithm selects excitations
with no bias.  The variance of a Monte Carlo calculation can be reduced
by preferentially selecting for certin types of excitation.</p>
<dl class="docutils">
<dt><strong>EXCITWEIGHTING</strong> [g_VMC_ExcitFromWeight g_VMC_ExcitToWeight G_VMC_EXCITWEIGHT] [g_VMC_ExcitToWeight2]</dt>
<dd><p class="first">Default 0.d0 (unweighted) for all values.</p>
<p>A weighting factor for the generation of random excitations in the
vertex sum Monte Carlo.  A parameter set to zero has a corresponding
weighting factor of 1.</p>
<p>For generating an excitation from occupied spin orbitals i and j to
unoccupied spin orbitals k and l:</p>
<blockquote class="last">
<ul>
<li><dl class="first docutils">
<dt>the probability of choosing pair (ij) is proportional to</dt>
<dd><div class="first last math">
<p><img src="../_images/math/ac758a50d659a7cd31dd5ec1b5523dc0c7e0f8ec.png" alt="e^{(E_i+E_j) \text{g\_VMC\_ExcitFromWeight} }." /></p>
</div></dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>the probability of choosing pair (kl) is proportional to</dt>
<dd><div class="first last math">
<p><img src="../_images/math/e6f6a1500eca675eca5bb54e1b7fef1f5b57f18e.png" alt="e^{-(E_k+E_l) \text{g\_VMC\_ExcitToWeight}} e^{|\bra ij|U|kl\ket|*\text{G\_VMC\_EXCITWEIGHT}} |E_i+E_j-E_k-E_l|^{\text{g\_VMC\_ExcitToWeight2}}." /></p>
</div></dd>
</dl>
</li>
</ul>
</blockquote>
</dd>
<dt><strong>POLYEXCITWEIGHT</strong> [g_VMC_ExcitFromWeight g_VMC_PolyExcitToWeight1 g_VMC_PolyExcitToWeight2 G_VMC_EXCITWEIGHT]</dt>
<dd><p class="first">Default 0.0 for all values (i.e. unweighted: all weighting factors
are set to 1).</p>
<p>Weighting system for the choice of virtual orbitals in
the excitations.</p>
<p>The probability of choosing the pair of spin orbitals, kl, to excite
to is set to be constant for <img class="math" src="../_images/math/1a523ba5583de65e21c51f68e6c5ee55d242fefe.png" alt="E_k+E_l"/> is less than
g_VMC_PolyExcitToWeight1.  For higher energy virtual orbitals,
the weighting applied is a decaying polynomial which goes as:</p>
<blockquote>
<div class="math">
<p><img src="../_images/math/d12d2b534c04d1f80b788a16c54046cf799e8066.png" alt="(E_k+E_l-\text{g\_VMC\_PolyExcitToWeight1}+1)^{-\text{g\_VMC\_PolyExcitToWeight2}}" /></p>
</div></blockquote>
<p class="last">g_VMC_PolyExcitToWeight1 is constrained to be not more than the
energy of the highest virtual orbital.</p>
</dd>
<dt><strong>POLYEXCITBOTH</strong> [g_VMC_PolyExcitFromWeight1 g_VMC_PolyExcitFromWeight2 g_VMC_PolyExcitToWeight1 g_VMC_PolyExcitToWeight2 G_VMC_EXCITWEIGHT]</dt>
<dd><p class="first">Identical to <strong>POLYEXCITWEIGHT</strong>, except that the polynomial weighting
function applies also to the occupied orbitals.  This means that there
is another variable, since now the &#8216;ExcitFrom&#8217; calculation also needs
a value for sigma, and for the exponent.  The sigma variables are
now both under similar constraints as specified above, which means
that they cannot be larger or smaller than the highest and lowest
energy orbital respectivly.  This prevents the PRECALC block from
getting stuck, or from finding local variance minima.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">What is sigma?</p>
</div>
</dd>
<dt><strong>CHEMPOTWEIGHTING</strong> [g_VMC_PolyExcitFromWeight2 g_VMC_PolyExcitToWeight2 G_VMC_EXCITWEIGHT]</dt>
<dd>Weighting is of the same form as POLYEXCITBOTH, but sigma is
now constrained to be at the chemical potential of the molecule.
Has only two parameters with which to minimise the expected variance.</dd>
<dt><strong>CHEMPOT-TWOFROM</strong> [g_VMC_ExcitWeights(1) g_VMC_ExcitWeights(2) g_VMC_ExcitWeights(3) G_VMC_EXCITWEIGHT]</dt>
<dd><blockquote class="first">
When choosing the electron to excite, use a a increasing polynomial
up to the chemical potential and a decaying polynomial for spin orbitals
above the chemical potential, in order to encourage mixing of
the configurations around the HF state. Contains three adjustable
parameters and testing needs to be done to see if this is
beneficial. Expected to make more of a difference as the vertex
level increases.</blockquote>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">What is the actual weighting form of <strong>CHEMPOT-TWOFROM</strong>?</p>
</div>
</dd>
<dt><strong>UFORM-POWER</strong></dt>
<dd>New power form for the U-matrix element weighting using the
appropriate <strong>EXCITWEIGHT</strong> element, which is believed to be
better. This uses the form <img class="math" src="../_images/math/1a7f95be2993b4bacddf19a33ab2c1fbec963c2c.png" alt="W=1+|U|^{\text{EXCITWEIGHT}}"/>, rather than the
exponential form.</dd>
<dt><strong>STEPEXCITWEIGHTING</strong> [g_VMC_ExcitWeights(1) g_VMC_ExcitWeights(2) G_VMC_EXCITWEIGHT]</dt>
<dd><p class="first">This excitation weighting consists of a step function between the HF virtual and occupied electon manifold (i.e. step is at the chemical potential)
When choosing an electron to move, the weight for selecting the electron is increased by 1 if the electron oribital has energy above the chemical potential
and by g_VMC_ExcitWeights(1,1) if below. This occurs for both electrons. When choosing where to excite to, the situation is reversed, and the weight of selecting the
unoccupied orbital is increased by 1 if the orbital is a hole in the occupied manifold and g_VMC_ExcitWeights(2,1) if a virtual orbital in the occupied manifold.
Bear in mind that the parameters are NOT probabilities. If we are at a higher excitation level w.r.t. HF, then more electrons will be in the virtual manifold,
which will alter the normalisation, and mean that when selecting electrons to excite, there will be an increasingly small probability of selecting them from the
occupied manifold. The opposite is true when choosing where to put them.</p>
<p>Simply put, if the parameters are both &lt; 1, then the biasing will preferentially generate excitations which reduce the excitation level.</p>
<p class="last">U-weighting is the third parameter as before.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="experimental-options">
<h2>Experimental options<a class="headerlink" href="#experimental-options" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">More documentation on these options needed.</p>
</div>
<dl class="docutils">
<dt><strong>EXCITATIONS</strong> <strong>FORCEROOT</strong></dt>
<dd>Force all excitations in <strong>VERTEX</strong> [<strong>SUM</strong> <strong>STAR</strong>] <strong>NEW</strong>
calculations to come from the root.</dd>
<dt><strong>EXCITATIONS</strong> <strong>FORCETREE</strong></dt>
<dd>Disallow any excitations in a <strong>VERTEX</strong> <strong>SUM</strong> <strong>NEW</strong> which are
connected to another in the graph, forcing a tree to be produced.
Not all trees are produced however.</dd>
<dt><strong>FULLDIAGTRIPS</strong></dt>
<dd>An option when creating a star of triples, to do a
full diagonalisation of the triples stars, without any
prediagonalisation. Very very slow...</dd>
<dt><strong>LINEPOINTSSTAR</strong> [LinePoints]</dt>
<dd>Set the number of excited stars whose eigenvalues are evaluated when
using StarStars, in order to determine linear scaling.</dd>
<dt><strong>NOTRIPLES</strong></dt>
<dd>Disallow triple-excitations of the root determinant as the 3rd vertex
in <strong>HDIAG</strong> calculations at the third vertex level and higher.</dd>
</dl>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="integrals.html" title="Integrals"
             >next</a> |</li>
        <li class="right" >
          <a href="precalc.html" title="PreCalc"
             >previous</a> |</li>
        <li><a href="../index.html">NECI v0.1 documentation</a> &raquo;</li>
          <li><a href="index.html" >Input options</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2010, Alavi Group.
      Last updated on Feb 20, 2010.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.4.
    </div>
  </body>
</html>