! Copyright (c) 2013, Ali Alavi unless otherwise noted.
! This program is integrated in Molpro with the permission of George Booth and Ali Alavi
 
module mcpathshdiag
     implicit none

!C.. 29/6/06  Based on FMCPR3B.
!C.. This function does not calculate RHO elements, but instead calculates
!C.. H elements.  These are then sent to a different diagonalizer, which allows
!C.. a range of different values of beta to be used.

!C.. A function to loop recursively over each node set choosing a different
!C.. node for each set.  All nodes are distinct.  Paths IJIKJI etc.
!C.. are generated by permutation from IJKI, and summed up to length I_HMAX
!C.. using the appropriate weightings (Z-sums) from CALCPATH7.(26/01/04).

!C.. This version doesn't need to generate excitation lists, so 
!C.. calculates excitations on the fly.  Overheads are bigger, but
!C.. scaling should be better. (9/3/05)

!C.. Various flags are available in NWHTAY
!C.. Bit 8 (512).  If set the lowest 8 bits of NWHTAY correspond to freezing data.
!C..                  (which is no longer implemented)
!C.. Bit 0 (1).  If 0, then allow connections to anywhere in a graph
!C..             If 1, then only allow connections to the root
!C.. Bit 1 (2).  If 0 allow all topologies.
!C..             If 1, disallow a det if it's already connected to one in the graph
!C.. Bit 3 (8).  If 0 allow all types of excitations
!C..             If 1 only allow singles.
!C.. Bit 4 (16)  If 0 allow all types of excitations
!C.,             If 1, only allow doubles.
   contains
      RECURSIVE FUNCTION FMCPR3B2(NI,BETA,I_P,IPATH,I_V,NEL,         &
     &   NBASISMAX,G1,NBASIS,BRR,NMSH,FCK,NMAX,ALAT,UMAT,NTAY,       &
     &   RHOEPS,I_VIND,HIJ,NWHTAY,I_HMAX,LOCTAB,                     &
     &   ILOGGING,TSYM,ECORE,DBETA,DLWDB,HIJS,L,LT,IFRZ,FSCALE,MP2E, &
     &   NTOTAL,I_VMAX,EREF,VARSUM,WREF) RESULT (FMCPR3B2RES)
         Use Determinants, only: get_helement
         use constants, only: dp 
         USE LoggingData , only : G_VMC_LOGCOUNT
         use CalcData , only : TVARCALC,TMPTHEORY,TMODMPTHEORY
         use CalcData , only : lNoTriples,GraphEpsilon
         use SystemData, only: BasisFN
         use mcpathsdata, only: EGP
         use sym_mod, only: getsym
         use util_mod, only: NECI_ICOPY
         IMPLICIT NONE
         TYPE(BasisFN) G1(*),ISYM
         INTEGER I_V,NEL,I_P,nBasisMax(5,*),NBASIS,BRR(*),NMSH,NMAX
         INTEGER NTAY(2),I_VIND,NWHTAY,ILOGGING,J,I_VMAX,II
         INTEGER I
         complex(dp) FCK(*)
         HElement_t UMAT(*)
         real(dp) ALAT(*),ECORE
         real(dp) TOTAL,FMCPR3B2RES,Prob
         real(dp) CALCPATHS_N
         INTEGER IPATH(NEL,0:I_V)
         real(dp) RHOII(0:I_V)
         real(dp) DLWDB,DLWDB2,EREF,WREF
         HElement_t HIJ(0:I_V,0:I_V),RH
         INTEGER INODE(NEL)
         INTEGER NI(NEL),NJ(NEL)
         INTEGER I_HMAX
         real(dp) BETA,RHOEPS
         LOGICAL TSYM
         LOGICAL TLOG,TLOG2,TLOG3,TLOG4,TLOG5,TLOG6
         real(dp) DBETA
         HElement_t HIJS(0:I_V)
         INTEGER ICLS
         INTEGER,pointer :: NMEM(:)

         INTEGER, target :: NMEMLEN(1)
         INTEGER, pointer :: OGEN(:)
         INTEGER, pointer :: CURGEN(:)
         TYPE(EGP) LOCTAB(:)
         TYPE(EGP) LOCTAB2(I_V)
         LOGICAL TFAIL,TNEXT,T
         INTEGER L,LT,IVLEVEL,IEXFROM,IVLMAX,IVLMIN
         INTEGER ICMPDETS
         INTEGER IC
         INTEGER DUMMY(0:I_V)
         INTEGER IFRZ(0:NBASIS,I_V),IFRZ2(0:NBASIS)
         INTEGER EX(2,2),ICIL,ICILMAX
         INTEGER STORE(6)
         real(dp) FSCALE,FSC2
         real(dp) MP2E(2:i_VMax),MPEs(2:i_VMax),NTOTAL,MPEn
         INTEGER EXFLAG

         LOGICAL ISCONNECTEDDET
         real(dp) VARSUM,SumX,SumY,SumXY,SumXsq,SumYsq,SumP
         DATA SumP/0.0_dp/
         SAVE SumX,SumY,SumXY,SumXsq,SumYsq,SumP

         integer iGetExcitLevel
         RHOII(:)=0
            
            SELECT CASE (IAND(NWHTAY,24))
            CASE(0)
!C.. Allow both singles and doubles
                EXFLAG=3
            CASE(8)
!C.. only singles
                EXFLAG=1
            CASE(16)
                EXFLAG=2
            CASE(24)
                STOP "Invalid combination of flags in NWHTAY"
            END SELECT
         IF(I_VIND.EQ.0) THEN
!C.. 1st time in
            IFRZ(0:(NBASIS),1:I_V) =0
            IF(IAND(NWHTAY,8).NE.0) THEN
!C.. Force freexing
               IFRZ(0,1)=NWHTAY
            ELSE
               IFRZ(0,1)=0
            ENDIF
         ENDIF
         IFRZ2(0:NBASIS) =0
         CALL NECI_ICOPY(NBASIS+1,IFRZ(0,I_VIND+1),1,IFRZ2,1)
         
!C            DO I=0,NBASIS
!C               WRITE(10,"(I2)",advance='no'),IFRZ2(I)
!C            ENDDO
!         WRITE(6,*) "V_",I_VIND
!C.. LOCTAB(1)%p is the address of the generator used to create node 1 in
!C.. the path (i.e. J).  LOCTAB(1)%l is the length of the generator (i.e. 
!C.. the amount of memory used to store it)
         TLOG=BTEST(ILOGGING,0)
         TLOG6=BTEST(ILOGGING,2)
         TLOG2=BTEST(ILOGGING,3)
         TLOG3=BTEST(ILOGGING,12)
         TLOG4=BTEST(ILOGGING,9)
         TLOG5=BTEST(ILOGGING,6)
         TLOG=TLOG.AND..NOT.TLOG4
         TOTAL=0.0_dp
         LT=LT+1
!C.. This is the current node (set by our parent)         
         CALL NECI_ICOPY(NEL,IPATH(1:NEL,I_VIND),1,INODE,1)
         rh = get_helement(INODE, INODE, 0)
         HIJ(I_VIND,I_VIND)=RH
!C.. we note that if this node has rho_II=0 (i.e. RH=0) then we just return
         IF(.not.abs(RH).gt.0.0_dp) THEN
            FMCPR3B2RES=0.0_dp
            RETURN
         ENDIF
         IF(I_VIND.EQ.(I_V-1)) THEN
!C.. If we're at the last node we call CALCPATHS to generate all 
!C.. the paths for it
            CALL NECI_ICOPY(NEL,NI,1,IPATH(1:NEL,I_V),1) 
            IF(TLOG6) THEN
               IF(.NOT.TLOG3) THEN
                  CALL WRITEPATH(10,IPATH,I_V,NEL,.FALSE.)
               ELSE
                  CALL WRITEPATHEX(10,IPATH,I_V,NEL,.FALSE.)
               ENDIF
            ENDIF
            IF(TLOG2) CALL WRITERHOMAT(10,HIJ,I_V,.TRUE.)
!C.. 
            ICLS=0
            RHOII(0)=0
            RHOII(1)=BETA
            TOTAL=TOTAL+                                                &
     &         CALCPATHS_N(RHOII,HIJ,I_V,I_HMAX,               &
     &         I_P,FSCALE,DBETA,DLWDB2,HIJS,ICLS)
            NTOTAL=NTOTAL+TOTAL
!C.. Sum up the components of <D|H exp(-b H)|D>
            DLWDB=DLWDB+DLWDB2
!            WRITE(18,*) IPATH
!            WRITE(18,*) TOTAL
!            WRITE(18,*) (DLWDB2/TOTAL)-EREF
!C.. Calculate the MP2 Energy
!C.. NMAX has ARR hidden in it.
!               CALL ADDMP2E(HIJS,NMAX,NBASIS,IPATH,NEL,TLOG,MP2E)
            IF(tMPTheory) THEN
               IF(tModMPTheory) then
!NBasisMax(2,3) is ISpinSkip
                  CALL ModMPDiagElement(Hij(i_V-1,i_V-1),iPath(1,0),       &
     &             iPath(1,i_V-1),NEL)
               Endif
               MPEs=(0.0_dp)
               CALL AddMPEnergy(Hij,i_V,i_vmax,NMAX,nBasis,iPath,nEl,tLog,ECORE,MPEs)
               MPEn=0.0_dp
               DO i=2,i_VMax
                  MP2E(i)=MP2E(i)+MPEs(i)
                  MPEn=MPEn+MPEs(i)
               ENDDO
            ENDIF
                
                   !WRITE(43,*) DLWDB2, EREF
                   !CALL neci_flush(43)
!        write (6,*) "from mcpathshdiag, EREF=",EREF
!            IF (TVARCALC(I_V)) THEN
!                CALL WRITEPATH(43,IPATH,I_V,NEL,.TRUE.)
!            ENDIF
            
            
            IF (TVARCALC(I_V)) THEN             
              J=0
              IF(tLog5) J=10
              
              IF(tMPTheory) THEN
! When we do MC on MP, we sum MPEn/pgen in the numerator and 1 in the denominator
                 
                Call CalcWriteGraphPGen(J,IPATH,I_V,nEl,G1,         &
     &                   nBasisMax,NMAX,nBasis,Prob,DUMMY)
                 SumX  =SumX   + (MPEn)
                 SumY  =SumY   + (Prob)
                 SumXsq=SumXsq + (MPEn*MPEn/Prob)
                 SumYsq=SumYsq + (Prob)
                 SumXY =SumXY  + (MPEn)
              ELSE
              !Variance given by ((w*E)**2)/P, but DLWDB2 is E*w and want deltas
                !X are terms in the numerator, Y are the terms in the denominator
              ENDIF
              IF(TLOG5) WRITE(10,"(3E25.16, I7)") TOTAL,Prob,DLWDB2,ICLS
            ELSEIF(TLOG5) THEN
!  Log XIJS (usually for debugging), and the pgen
!  NMAX has Arr hidden in it
              CALL CalcWriteGraphPGen(10,IPATH,I_V,nEl,G1,       &
     &            nBasisMax,NMAX,nBasis,Prob,DUMMY)
                  WRITE(10,"(3E25.16, I7)") TOTAL,Prob,DLWDB2,ICLS
            ELSE
               IF(TLOG) WRITE(10,"(2E25.16, I7)") TOTAL,DLWDB2,ICLS
            ENDIF
!            IF((.not.TPREVAR).and.(I_V.eq.3)) THEN
!                
!               CALL WriteGraphEnergies(IPATH, I_V,nEl,nBasis,NMAX,TOTAL)
!            ENDIF
!            IF((.not.TPREVAR).and.(I_V.eq.3)) THEN
!                CALL GetGraphstats(IPATH,I_V,NEL,NBASIS,NMAX,TOTAL,
!     &              NBASISMAX,DLWDB2)
!            ENDIF
            L=L+1
            FMCPR3B2RES=TOTAL
            IF(TLOG4.AND.MOD(L,G_VMC_LOGCOUNT).EQ.0) THEN
!C.. log every 1000
               WRITE(10,"(I10,3E25.16)") L,NTOTAL,DLWDB,MP2E(2)
               CALL neci_flush(10)
            ENDIF
            RETURN
         ENDIF
!C.. We recurse over all possibilities for the next node:
!C..  1) Nodes connected to us (excluding those connected to previous nodes)
!C..     We perform this exclusion by looking at whether a newly
!C..     generated node connected to us is connected to a previous node
!C..     which existed before the one we were generated from.  (If we are
!C..     connected to a node created after the one we were created from,
!C..     we have been specifically excluded from that node's excitation
!C..     list because we were connected to a prior node, so we, now being
!C...    generated from that prior node, now need to be counted)
!C..  2) Nodes connected to previous (i.e. before the one we're connected to )
!C..         nodes which have not yet been processed
!C..        (excluding those which are connected to further previous nodes. 
!C..         NB: These may be connected to us, but will have been excluded
!C..         in 1 as they are connected to previous nodes to 1
!C..  3) Further recursions down the (direct) line from us back to I.  Previous 
!C..        completed lines will have been entirely processed, so we don't
!C..        need to attempt to add nodes to them (but we do need to ensure
!C..        that new nodes don't connect to them)
!C.. 
!C..   All of this boils down to looking at all previous nodes (irrespective
!C..   of which line they're in), and attempting to attach nodes to the
!C..   positions after the parts which have been processed.

!C.. We start by creating an excitation generator connected to the
!C.. current node

!C.. Initialiaze the excitation generators
         CALL GETSYM(INODE,NEL,G1,NBASISMAX,ISYM)
         STORE(1)=0
         CALL GENSYMEXCITIT2(INODE,NEL,G1,NBASIS,             &
     &         .TRUE.,NMEMLEN,NJ,IC,STORE,EXFLAG)
         allocate(NMEM(NMEMLEN(1)))
         NMEM(1)=0
         CALL GENSYMEXCITIT2(INODE,NEL,G1,NBASIS,             &
     &         .TRUE.,NMEM,NJ,IC,STORE,EXFLAG)
!C.. I_VIND is the node that has just been chosen (so LOCTAB(I_VIND) is a
!C.. generator for that node.  We need to generate from that node, so we
!C.. store at I_VIND+1

!C.. We now choose the next node, attempting to generate from all the
!C.. nodes in the direct line back to I

!C.. We do this by taking a copy of LOCTAB (excluding the generator
!C.. from this node, which we haven't put in yet)
         IF(I_VIND>0) LOCTAB2(1:I_VIND)=LOCTAB(1:I_VIND)
!         CALL NECI_ICOPY(I_VIND*3*2,LOCTAB,1,LOCTAB2,1)
!C.. Now start at this node, and work backwards along the path to I.
!C.. (This is equivalent to working through all previous nodes in the
!C.. path, as those which are not on our direct route back to I will have 
!C.. their generators exhausted, and thus a zero-entry in the LOCTAB.
         
         IF(IAND(NWHTAY,1).EQ.0) THEN
!C.. Either a normal graph sum or a chain/star sum

!C.. start the iterator at "us" (i.e. get all excitations connected to
!C.. us) and then work back down the direct tree to the root.
!C.. allow chain graphs
            IVLMAX=I_VIND+1
            IVLMIN=0
         ELSE
!C.. only stars start at what remains from the iterator the last one
!C.. was generated from (or just the root if there is none) 
            IVLMAX=I_VIND
            IF(IVLMAX.LT.1) IVLMAX=1
            IVLMIN=IVLMAX-1
         ENDIF
         IVLEVEL=IVLMAX

!C.. Set these just in case
         CURGEN=>NMEM
         LOCTAB(I_VIND+1)%l=NMEMLEN(1)
         LOCTAB(I_VIND+1)%v=IVLEVEL-1
         
         DO WHILE (IVLEVEL.GT.IVLMIN)
!C.. If we're at I_VIND+1, then we don't need to create a new copy of the 
!C.. generator, as no other sub-recursion is using it yet
            TNEXT=.FALSE.
            CALL NECI_ICOPY(NBASIS+1,IFRZ(0,IVLEVEL),1,IFRZ2,1)
            IF(IVLEVEL.LE.I_VIND) THEN
!C.. create a copy

               nullify(CURGEN)
               allocate(CURGEN(LOCTAB2(IVLEVEL)%l))
               OGEN=>LOCTAB2(IVLEVEL)%p
               CURGEN(1:LOCTAB2(IVLEVEL)%l)=OGEN(1:LOCTAB2(IVLEVEL)%l)
               I_VIND=I_VIND+1
               I_VIND=I_VIND-1
               IF(IAND(IFRZ(0,I_VIND+1),8).NE.0) THEN
!C.. We need to reset the generator if we're only generating stars.
!C.. Because we now have some frozen orbitals, the original excitation
!C.. will not be re-generated.
                  CALL RESETEXIT2(CURGEN)
               ENDIF
               LOCTAB2(I_VIND+1)%l=LOCTAB(IVLEVEL)%l
               LOCTAB2(I_VIND+1)%v=LOCTAB(IVLEVEL)%v
            ELSE
               CURGEN=>NMEM
               LOCTAB2(I_VIND+1)%l=NMEMLEN(1)
               LOCTAB2(I_VIND+1)%v=IVLEVEL-1
            ENDIF
            IEXFROM=LOCTAB2(I_VIND+1)%v
            LOCTAB2(I_VIND+1)%p=>CURGEN
            DO WHILE(.NOT.TNEXT)
!C.. Now use the generator to make the next node,NJ
               CALL GENSYMEXCITIT2(IPATH(1,IEXFROM),NEL,G1,NBASIS,  &
     &         .FALSE.,CURGEN,NJ,IC,STORE,EXFLAG)
!C.. Check to see it's actually been generated
               IF(NJ(1).EQ.0) THEN
                  TFAIL=.TRUE.
                  TNEXT=.TRUE.
               ELSE
                  TFAIL=.FALSE.
               ENDIF
!C.. Now make sure it's not already in the path
               IF(.NOT.TFAIL) THEN
                  DO J=0,I_VIND
                     IF(ICMPDETS(NJ,IPATH(1,J),NEL).EQ.0) THEN
                        TFAIL=.TRUE.
                     ENDIF
                  ENDDO
               ENDIF
                  
               IF(.NOT.TFAIL) THEN
!C.. see if we're connected to what we were excited from
                 RH = get_helement (iPath(:, iExFrom), nJ, ic)
                  IF(.NOT.(abs(RH).GE.RHOEPS)) THEN
!C.. if we're not connected to this node, we fail now
                     RH=0.0_dp
                     TFAIL=.TRUE.
                  ENDIF
#ifdef __CMPLX
                  HIJ(I_VIND+1,IEXFROM)=conjg(RH)
#else
                  HIJ(I_VIND+1,IEXFROM)=(RH)
#endif
                  HIJ(IEXFROM,I_VIND+1)=RH
               ENDIF
           
               IF(lNoTriples.AND.I_VIND.EQ.1) Then
                  IF(iGetExcitLevel(nI,nJ,nEl).NE.3) THEN
                  ELSE
                     TFAIL=.TRUE.
                  ENDIF
               Endif 
!C.. Work out the connectivity of the new node
               DO II=0,I_VIND
!C.. we don't need to calc the connection to the node we excited from
!C.. because we've just done that
                  IF(.NOT.TFAIL.AND.II.NE.IEXFROM) THEN
                     rh = get_helement(iPath(:, iI), nJ)
                     IF(.NOT.(abs(RH).GE.RHOEPS)) RH=0.0_dp
#ifdef __CMPLX
                     HIJ(I_VIND+1,II)=conjg(RH)
#else
                     HIJ(I_VIND+1,II)=(RH)
#endif
                     HIJ(II,I_VIND+1)=RH
                     IF(II<I_VIND) then
                   IF(IsConnectedDet(IPATH(1,II),NJ)) THEN
!if rhoeps is zero then always set TFAIL.  if rhoeps isn't zero, then set TFAIL if Rh isn't zero (i.e. we've included it before)
                     IF(RH.NE.0.0_dp.OR.RHOEPS.EQ.0.0_dp) THEN
!C.. If the node to which this node (NJ) is attached was known about at
!C.. the time of node II, we are allowed to have a connection between
!C.. node NJ and II.  Otherwise, this node must not be attached to II, as
!C.. it will've already been counted as one of those attached to II
!    If we excluded it through a rhoeps cutoff, we ARE allowed to connect to it

!C.. We disallow this connection if IAND(IFRZ2(0),2) to require that there are
!C.. no loops
                        IF(IAND(NWHTAY,2).NE.0.OR.IEXFROM.GT.II) THEN
!C.. we're not allowed to count this node
                           TFAIL=.TRUE.                  
                        ENDIF
                       ENDIF
                      ENDIF
                     ENDIF
                  ENDIF
               ENDDO
               IF(.NOT.TFAIL) THEN
!C.. If we've got a node we're allowed to count
!C.. Deal with freezing orbitals if we have to
!C..
                  ICIL=0
                  ICILMAX=1
                  FSC2=FSCALE
                  DO WHILE(ICIL.LT.ICILMAX)
                   IF(IAND(NWHTAY,8).NE.0.AND.I_VIND.LT.(I_V-2)) THEN
                     IF(ICIL.EQ.0) THEN
                        EX(1,1)=2
                        CALL GETEXCITATION(IPATH(1,IEXFROM),NJ,NEL,EX,T)
                        ICILMAX=2
                        IF(EX(1,2).NE.0) ICILMAX=ICILMAX+1
                     ENDIF
!C.. We freeze the orbitals we're exciting from and to
                     CALL NECI_ICOPY(NBASIS+1,IFRZ2,1,IFRZ(0,I_VIND+1),1)
!C.. freeze full orbitals
!C.. 0) second excited full (if there is one)
!C.. 1) first excited full 
!C.. 2) both excited full (and set to subtract this contrib)
                     IF(ICIL.EQ.ICILMAX-3) THEN
                        IFRZ(EX(1,2),I_VIND+1)=1
                     ELSEIF(ICIL.EQ.ICILMAX-2) THEN
                        IFRZ(EX(1,1),I_VIND+1)=1
                     ELSEIF(ICIL.EQ.ICILMAX-1) THEN
                        IFRZ(EX(1,1),I_VIND+1)=1
                        IF(EX(1,2).NE.0) IFRZ(EX(1,2),I_VIND+1)=1
                        FSC2=-FSC2
                     ENDIF
!C.. freeze the empties
                     IFRZ(EX(2,1),I_VIND+1)=1
                     IF(EX(2,2).NE.0) IFRZ(EX(2,2),I_VIND+1)=1
                     CALL NECI_ICOPY(NBASIS+1,IFRZ(0,I_VIND+1),1,IFRZ(0,I_VIND+2),1)
                   ELSE
                     CALL NECI_ICOPY(NBASIS+1,IFRZ(0,I_VIND+1),1,IFRZ(0,I_VIND+2),1)
                   ENDIF
!C.. Add it to the path, and recurse
                   CALL NECI_ICOPY(NEL,NJ,1,IPATH(1,I_VIND+1),1)
!C.. Get the H element so we can calculate the energy
                   HIJS(I_VIND+1)=HIJ(0,I_VIND+1)
                   TOTAL=TOTAL+                                               &
     &                  FMCPR3B2(NI,BETA,I_P,IPATH,I_V,NEL,NBASISMAX,         &
     &                     G1,NBASIS,BRR,NMSH,FCK,NMAX,ALAT,UMAT,             &
     &                     NTAY,RHOEPS,I_VIND+1,HIJ,NWHTAY,                   &
     &                     I_HMAX,LOCTAB2,ILOGGING,TSYM,ECORE,                &
     &                     DBETA,DLWDB,HIJS,L,LT,IFRZ,FSC2,MP2E,NTOTAL,       &
     &                    I_VMAX,EREF,VARSUM,WREF)
!                   WRITE(43,*) WREF, NTOTAL
                   ICIL=ICIL+1
                  ENDDO
               ENDIF
            ENDDO
            IF(IVLEVEL.LE.I_VIND) THEN
!C.. free the copy
               deallocate(CURGEN)
               nullify(CURGEN)
               nullify(LOCTAB2(IVLEVEL)%p)
            ENDIF
!C.. for the next iterator, we want to find the node to which we are
!C.. connected, and continue from after where this node was excited
            IVLEVEL=LOCTAB2(IVLEVEL)%v
         ENDDO
         deallocate(NMEM)
!         nullify(LOCTAB(I_VIND+1)%p)
         FMCPR3B2RES=TOTAL

        If (TVARCALC(I_V).and.(I_VIND.eq.0)) Then
        
        
                 SumYsq=SumYsq+(2*WREF*SumY)+(((WREF)**2)*SumP)
                 SumY=SumY+(WREF*SumP)
                 SumXY=SumXY+(WREF*SumX)

!           write(6,"A, 5G26.15") "Terms in estimated variance:",
!     &        SumX, SumY, SumXsq, SumYsq, SumXY

          write(6,"(2A,I3,A,G23.16)") "Expected MC Variance for ratio ",      &
     &       "vertex level", I_V," is ", (SumX/SumY)**2*(SumXsq/SumX**2       &
     &                      +SumYsq/SumY**2-2*SumXY/(SumX*SumY))

          write(6,"(2A,G24.16)") "Sum of Pgens of graphs included", " in variance is ", SumP
          SumP=0.0_dp
          VARSUM=0.0_dp
          SumX=0.0_dp
          SumY=0.0_dp
          SumXsq=0.0_dp
          SumYsq=0.0_dp
          SumXY=0.0_dp
    
        End If
        
         RETURN
      END function

end module

      Subroutine WriteGraphEnergies(IPATH, I_V, nEl,nBasis,Arr,Weight)
         use constants, only: dp
         Integer I_V, nEl, nBasis, IPATH(nEl,0:I_V), EX(2,2)
         real(dp) Arr(nBasis, 2),Energyfromnew
         real(dp) Energyfromold
         real(dp) totWeight,avWeight
         real(dp) Weight
         LOGICAL T
         INTEGER g
         DATA g/0/
         DATA totWeight/0.0_dp/
!         DATA Energytoold/0.0_dp/
         DATA Energyfromold/0.0_dp/
         SAVE g,Energyfromold,totWeight
         OPEN(56,FILE="WEIGHTDATA",STATUS="UNKNOWN")
         EX(1,1)=2
         Call GetEXCITATION(IPATH(1:NEL,0),IPATH(1:NEL,1),NEL,EX,T)
         If(Ex(1,2).eq.0) Then !we have a single excitation
!             Write(56, "5G25.16") Weight, Arr(EX(1,1),2), 0,
!     &                                 Arr(EX(2,1),2), 0
!            Energytonew=Arr(EX(2,1),2)
            Energyfromnew=Arr(Ex(1,1),2)
         Else
!            Write(56, "5G25.16") Weight, Arr(EX(1,1),2), Arr(EX(1,2),2),
!     &                                 Arr(EX(2,1),2), Arr(EX(2,2),2)
!             Energytonew=Arr(EX(2,1),2)+Arr(EX(2,2),2)
             Energyfromnew=Arr(EX(1,1),2)+Arr(EX(1,2),2)
         End If
         IF (Energyfromnew.eq.Energyfromold) THEN
             totWeight=totWeight+Weight
             g=g+1
         ELSE
             avWeight=totWeight/g
             Write(56, "(G25.16,I9,G25.16)") avWeight,g, Energyfromold
             avWeight=0.0_dp
             totWeight=Weight
             g=1
         ENDIF
             Energyfromold=Energyfromnew
!             Write(56, "3G25.16") Weight,Energyfrom,Energyto 
         
         End
         Subroutine GetGraphstats(IPATH, I_V, nEl,nBasis,Arr,Weight,NBASISMAX,DLWDB2)
         use constants, only: dp,int64
         USE UMatCache , only : GTID
         use SystemData, only: BasisFN
         use procedure_pointers, only: get_umat_el
         IMPLICIT NONE
         Integer I_V,nEl,nBasis,IPATH(nEl,0:I_V),EX(2,2)
         real(dp) ARR(nBasis,2),EnergyTo,EnergyFrom
         INTEGER I,J,K,L,ISS,IDI,IDJ,IDL,IDK,nBasisMax(5,*)
         INTEGER EXCITLEV
         real(dp) Weight,DLWDB2
         HElement_t ME
         LOGICAL AREDETSEXCITS,CONNECT23, T
         integer c
         integer(int64) SINGLE,DOUBLE,histogram(-20:3)
         SAVE c,SINGLE,DOUBLE,histogram
         DATA histogram/24*0/
         DATA c/0/
         DATA SINGLE/0/
         DATA DOUBLE/0/
         
         write (6,*) 'Warning: c has been changed from integer(int64) to *4'
         IF(I_V.eq.2) THEN
            EX(1,1)=2
            OPEN(56,FILE="GRAPHSTATS",STATUS="UNKNOWN")
            CALL GetEXCITATION(IPATH(1:NEL,0),IPATH(1:NEL,1),NEL,EX,T)
         
            IF((EX(1,2).eq.0).and.(Weight.gt.0.0_dp)) THEN
!               Energy=Arr(Ex(1,1),2)
                STOP 'Should not be here for 2v graphs'
                RETURN
            ELSEIF(EX(1,2).ne.0) THEN   !only consider doubles
                ISS=NBASISMAX(2,3)
                I=EX(1,1)
                J=EX(1,2)
                K=EX(2,1)
                L=EX(2,2)
                IDI = GTID(I)
                IDJ = GTID(J)
                IDK = GTID(K)
                IDL = GTID(L)
                ME=get_umat_el(IDI,IDJ,IDK,IDL)
                EnergyFrom=Arr(EX(1,1),2)+Arr(EX(1,2),2)
                EnergyTo=Arr(EX(2,1),2)+Arr(EX(2,2),2)
            ENDIF
            WRITE(56,"(3G25.16)") Weight,Energyto,ME
        ELSEIF(I_V.eq.3) THEN
            c=c+1
            
!            EXCITLEV=IGETEXCITLEVEL_(IPATH(1:NEL,1),
!     &                           IPATH(1:NEL,2),NEL)
!            IF(EXCITLEV.ge.3) RETURN
            IF(c.eq.1) THEN
                OPEN(56,FILE="GRAPHSTAT57_1",STATUS="UNKNOWN")
                OPEN(57,FILE="GRAPHSTAT57_2",STATUS="UNKNOWN")
                OPEN(58,FILE="GRAPHSTAT57_3",STATUS="UNKNOWN")
                OPEN(59,FILE="GRAPHSTAT6_1",STATUS="UNKNOWN")
                OPEN(60,FILE="GRAPHSTAT6_2",STATUS="UNKNOWN")
                OPEN(61,FILE="GRAPHSTAT6_3",STATUS="UNKNOWN")
            ENDIF
            IF((MOD(c,75).eq.0).or.(MOD(c,75).eq.25).or.(MOD(c,75).eq.50)) THEN
                
                CONNECT23=AREDETSEXCITS(IPATH(1:NEL,1),IPATH(1:NEL,2),NEL,EXCITLEV)
                EX(1,1)=2
                
                IF(CONNECT23) THEN  !Nodes 2&3 connected
                    CALL GetEXCITATION(IPATH(1:NEL,1),IPATH(1:NEL,2),NEL,EX,T)
                    IF(EX(1,2).ne.0) THEN
                        DOUBLE=DOUBLE+1
                        ISS=NBASISMAX(2,3)
                        I=EX(1,1)
                        J=EX(1,2)
                        K=EX(2,1)
                        L=EX(2,2)
                        IDI = GTID(I)
                        IDJ = GTID(J)
                        IDK = GTID(K)
                        IDL = GTID(L)
                     ME=get_umat_el(IDI,IDJ,IDK,IDL)
                        EnergyFrom=Arr(EX(1,1),2)+Arr(EX(1,2),2)
                        EnergyTo=Arr(EX(2,1),2)+Arr(EX(2,2),2)
                        IF(MOD(c,75).eq.0) THEN
                            WRITE(56,"(4G25.16,I3,G25.16)") Weight,           &
     &                       DLWDB2,EnergyFrom,EnergyTo,EXCITLEV,ME
                        ELSEIF(MOD(c,75).eq.25) THEN
                            WRITE(57,"(4G25.16,I3,G25.16)") Weight,           &
     &                       DLWDB2,EnergyFrom,EnergyTo,EXCITLEV,ME
                        ELSEIF(MOD(c,75).eq.50) THEN
                            WRITE(58,"(4G25.16,I3,G25.16)") Weight,           &
     &                       DLWDB2,EnergyFrom,EnergyTo,EXCITLEV,ME
                        ENDIF
                    ELSEIF(EX(1,2).eq.0) THEN
                        SINGLE=SINGLE+1
                        !Histogramming
!                       WRITE(124,"30I3") IPATH(1:NEL,0),IPATH(1:NEL,1),
!     &                      IPATH(1:NEL,2)
!                        hist=NINT(log10(Weight))
!                        IF(Weight.lt.1D-20) hist=-20
!                            do p=-20,3
!                                IF(hist.eq.p) THEN
!                                    histogram(p)=histogram(p)+1
!                                ENDIF
!                            enddo
!                         ENDIF
!                        IF(c.gt.16157864) THEN
!                           write(125,"24I9") histogram
!                           write(125,*) ""
!                           write(125,*) ""
!                        ENDIF
                            
                    ENDIF
                ELSE    !We have a class 6 graph where nodes 2&3 are disconnected

                    CALL GetEXCITATION(IPATH(1:NEL,0),IPATH(1:NEL,2),NEL,EX,T)
                    IF(EX(1,2).eq.0) THEN
                        STOP 'Should not be single excits here'
                    ELSE
                        DOUBLE=DOUBLE+1
                        ISS=NBASISMAX(2,3)
                        I=EX(1,1)
                        J=EX(1,2)
                        K=EX(2,1)
                        L=EX(2,2)
                        IDI = GTID(I)
                        IDJ = GTID(J)
                        IDK = GTID(K)
                        IDL = GTID(L)
                     ME=get_umat_el(IDI,IDJ,IDK,IDL)
                        EnergyFrom=Arr(EX(1,1),2)+Arr(EX(1,2),2)
                        EnergyTo=Arr(EX(2,1),2)+Arr(EX(2,2),2)
                        IF(MOD(c,75).eq.0) THEN
                            WRITE(59,"(4G25.16,I3,G25.16)") Weight,        &
     &                        DLWDB2,EnergyFrom,EnergyTo,EXCITLEV,ME
                        ELSEIF(MOD(c,75).eq.25) THEN
                            WRITE(60,"(4G25.16,I3,G25.16)") Weight,        &
     &                       DLWDB2,EnergyFrom,EnergyTo,EXCITLEV,ME
                        ELSEIF(MOD(c,75).eq.50) THEN
                            WRITE(61,"(4G25.16,I3,G25.16)") Weight,        &
     &                       DLWDB2,EnergyFrom,EnergyTo,EXCITLEV,ME
                        ENDIF
                    ENDIF
                ENDIF
! Looks like debug output...
!                IF((MOD(c,100000).eq.0)) THEN
!                    Percendoub=((DOUBLE+0.0_dp)/(DOUBLE+SINGLE+0.0_dp))*100
!                    WRITE(124,*) c,(SINGLE+DOUBLE),Percendoub
!                ENDIF
            ENDIF
        ENDIF
        RETURN
         
         END Subroutine
