#include "macros.h"

MODULE FciMCMod
use SystemData , only : NEl,Alat,Brr,ECore,G1,nBasis,nBasisMax,nMsh,Arr
use CalcData , only : InitWalkers,NMCyc,G_VMC_Seed,DiagSft,Tau,SftDamp,StepsSft
use CalcData , only : TReadPops,ScaleWalkers,TStartMP1
use CalcData , only : GrowMaxFactor,CullFactor,TMCDets
use CalcData , only : TNoAnnihil
use CalcData , only : NEquilSteps,TSignShift,THFRetBias,PRet
use CalcData , only : TProjEMP2,TFixParticleSign,TStartSinglePart,MemoryFacPart,TRegenExcitgens,TUnbiasPGeninProjE
use CalcData , only : iPopsFileNoRead,iPopsFileNoWrite
use Determinants, only: FDet, get_helement, GetH0Element3, write_det
USE DetCalcData , only : NMRKS,ICILevel
use IntegralsData , only : fck,NMax,UMat
USE global_utilities
USE Logging , only : iWritePopsEvery,TPopsFile,TZeroProjE,TWriteDetE,MaxHistE,NoHistBins, tIncrementPops
use constants, only: dp
use DetBitOps, only: EncodeBitDet
use constants, only: dp
use FciMCData, only: ExcitGenerator, HFExcit, fcimcstats_unit, &
                     excitgenerator_init, excitgenerator_destroy
use sort_mod
IMPLICIT NONE
SAVE

TYPE(ExcitGenerator) , ALLOCATABLE , TARGET :: WalkVecExcits(:),WalkVec2Excits(:)   !This will store the excitation generators for the particles on each node
INTEGER , ALLOCATABLE , TARGET :: WalkVecDets(:,:),WalkVec2Dets(:,:)    !Contains determinant list
LOGICAL , ALLOCATABLE , TARGET :: WalkVecSign(:),WalkVec2Sign(:)        !Contains sign list
INTEGER , ALLOCATABLE , TARGET :: WalkVecIC(:),WalkVec2IC(:)            !Contains excit level list
REAL*8 , ALLOCATABLE , TARGET :: WalkVecH(:,:),WalkVec2H(:,:)       !First element is diagonal hamiltonian element - second is the connection to HF determinant
REAL*8 , ALLOCATABLE , TARGET :: WalkVecPGen(:), WalkVec2PGen(:)        !This stores the generation probabilities of the walkers when TUnbiasPGeninProjE is on
INTEGER :: WalkVecDetsTag=0,WalkVec2DetsTag=0,WalkVecSignTag=0,WalkVec2SignTag=0
INTEGER :: WalkVecICTag=0,WalkVec2ICTag=0,WalkVecHTag=0,WalkVec2HTag=0,WalkVecPgenTag=0,WalkVec2PGenTag=0
!Pointers to point at the correct arrays for use
INTEGER , POINTER :: CurrentDets(:,:), NewDets(:,:)
LOGICAL , POINTER :: CurrentSign(:), NewSign(:)
INTEGER , POINTER :: CurrentIC(:), NewIC(:)
REAL*8 , POINTER :: CurrentH(:,:), NewH(:,:)
REAL*8 , POINTER :: CurrentPGen(:), NewPGen(:)
TYPE(ExcitGenerator) , POINTER :: CurrentExcits(:), NewExcits(:)

INTEGER , ALLOCATABLE :: HFDet(:)       !This will store the HF determinant
INTEGER :: HFDetTag=0

INTEGER :: Seed,MaxWalkers,TotWalkers,TotWalkersOld,TotSign,TotSignOld,PreviousNMCyc,Iter,NoComps
INTEGER :: exFlag=3

!This is information needed by the thermostating, so that the correct change in walker number can be calculated, and hence the correct shift change.
!NoCulls is the number of culls in a given shift update cycle for each variable
INTEGER :: NoCulls=0
!CullInfo is the number of walkers before and after the cull (elements 1&2), and the third element is the previous number of steps before this cull...
!Only 10 culls/growth increases are allowed in a given shift cycle
INTEGER :: CullInfo(10,3)

!The following variables are calculated at the end of each update cycle, are combined to the root processor
REAL*8 :: GrowRate,DieRat,ProjectionE,SumENum
REAL*8:: SumNoatHF      !This is the sum over all previous cycles of the number of particles at the HF determinant
REAL*8 :: AvSign           !This is the average sign of the particles over all iterations
INTEGER :: SumWalkersCyc    !This is the sum of all walkers over an update cycle on each processor
REAL*8 :: MeanExcitLevel
INTEGER :: MinExcitLevel
INTEGER :: MaxExcitLevel
INTEGER :: NoatDoubs,Annihilated,Acceptances,ConnAnnihil
REAL*8 :: AccRat
INTEGER :: PreviousCycles   !The number of previous cycles performed before the POPSFILE is read in
INTEGER :: NoatHF           !This is the number at HF for a given Iteration
REAL*8 :: SumConnections
INTEGER :: NoDied           !This is the number of particles which have died (on-site death) in the last update cycle
INTEGER :: NoBorn           !This is the number of particles which have been born in the last update cycle

!These values are used to calculate the energy when TProjEMP2 is set
REAL*8 :: SumOverlapMP2     !This is the overlap of the walker distribution with the MP2 wavefunction, summed over all iterations
REAL*8 :: SumHOverlapMP2    !This is the overlap of the excitations of the walkers with MP2, summed over all iterations
REAL*8 :: ProjectionMP2     !This is the energy calculated by <Psi_MP1|H|Psi>/<Psi_MP1|Psi>

HElement_t :: rhii,FZero
REAL*8 :: Hii,Fii

LOGICAL :: TSinglePartPhase                 !This is true if TStartSinglePart is true, and we are still in the phase where the shift is fixed and particle numbers are growing

INTEGER*8 , ALLOCATABLE :: EHistBins(:,:)   !This is to histogram the determinant energies..
INTEGER :: EHistBinsTag=0

TYPE(timer) :: Walker_time, Annihil_time


contains

SUBROUTINE FciMC(Weight,Energyxw)
use soft_exit, only: test_SOFTEXIT
real(dp) :: Weight,Energyxw
LOGICAL :: TIncrement

Walker_time%timer_name='Walker_time'
Annihil_time%timer_name='Annihil_time'

CALL InitFCIMCCalc()

WRITE(6,*) ""

!TotWalkersOld is the number of walkers last time the shift was changed
IF(TProjEMP2) THEN
    WRITE(6,*) "       Step     Shift   WalkerCng   GrowRate    TotWalkers  Annihil NoDied NoBorn   Proj.E        " &
        & //"Proj.MP2      NoatHF NoatDoubs  <s>          AccRat     AvConn         MeanEx  MinEx MaxEx"
    WRITE(fcimcstats_unit,*) "#       Step     Shift   WalkerCng   GrowRate    TotWalkers  Annihil NoDied NoBorn   " &
        & //"Proj.E        Proj.MP2      NoatHF NoatDoubs  <s>          AccRat     AvConn         MeanEx  MinEx MaxEx"
    WRITE(fcimcstats_unit,"(I12,G15.6,I7,G15.6,I10,3I7,2G15.6,2I9,4G14.6,2I6)") PreviousCycles+Iter,DiagSft, &
    &       TotWalkers-TotWalkersOld,GrowRate,TotWalkers,Annihilated,NoDied,NoBorn,   &
    &       ProjectionE,ProjectionMP2,NoatHF,NoatDoubs,AvSign,AccRat,0.D0,MeanExcitLevel,MaxExcitLevel,MinExcitLevel
    WRITE(6,"(I12,G15.6,I7,G15.6,I10,3I7,2G15.6,2I9,4G14.6,2I6)") PreviousCycles+Iter,DiagSft,TotWalkers-TotWalkersOld, &
    &       GrowRate,TotWalkers,Annihilated,NoDied,NoBorn,    &
    &       ProjectionE,ProjectionMP2,NoatHF,NoatDoubs,AvSign,AccRat,0.D0,MeanExcitLevel,MaxExcitLevel,MinExcitLevel
ELSE
    WRITE(6,*) "       Step     Shift   WalkerCng   GrowRate    TotWalkers  Annihil NoDied NoBorn   Proj.E        " &
    & //"NoatHF NoatDoubs  <s>          AccRat     AvConn         MeanEx     MinEx MaxEx"
    WRITE(fcimcstats_unit,*) "#      Step     Shift   WalkerCng   GrowRate    TotWalkers  Annihil NoDied NoBorn   " &
    & //"Proj.E        NoatHF NoatDoubs  <s>          AccRat     AvConn         MeanEx     MinEx MaxEx"
    WRITE(fcimcstats_unit,"(I12,G15.6,I7,G15.6,I10,3I7,G15.6,2I9,4G14.6,2I6)") PreviousCycles+Iter,DiagSft, &
    &           TotWalkers-TotWalkersOld,GrowRate,TotWalkers,Annihilated,NoDied,NoBorn,   &
    &           ProjectionE,NoatHF,NoatDoubs,AvSign,AccRat,0.D0,MeanExcitLevel,MaxExcitLevel,MinExcitLevel
    WRITE(6,"(I12,G15.6,I7,G15.6,I10,3I7,G15.6,2I9,4G14.6,2I6)") PreviousCycles+Iter,DiagSft,TotWalkers-TotWalkersOld, &
    &           GrowRate,TotWalkers,Annihilated,NoDied,NoBorn,    &
    &           ProjectionE,NoatHF,NoatDoubs,AvSign,AccRat,0.D0,MeanExcitLevel,MaxExcitLevel,MinExcitLevel
ENDIF

!Start MC simulation...
TIncrement=.true.   !If TIncrement is true, it means that when it comes out of the loop, it wants to subtract 1 from the Iteration count to get the true number of iterations
do Iter=1,NMCyc

    CALL PerformFCIMCyc()

    IF(mod(Iter,StepsSft).eq.0) THEN
        !This will find the new shift (and other parameters), and print out the needed values.
        CALL UpdateDiagSft()

        !Test that the file SOFTEXIT is present. If it is, then exit cleanly.
        IF(test_SOFTEXIT()) THEN
            TIncrement=.false.     !This is so that when the popsfile is written out before exit, it counteracts the subtraction by one.
            EXIT
        ENDIF

    ENDIF

    IF(TPopsFile.and.(mod(Iter,iWritePopsEvery).eq.0)) THEN
        !This will write out the configuration of walkers
        CALL WriteToPopsFile()
    ENDIF


    !End of MC cycle
enddo

!Write out popsfile
IF(TIncrement) Iter=Iter-1         !Subtract one, since Iter is a loop variable, and therefore incremented on exit of the loop
IF(TPopsFile) CALL WriteToPopsFile()

Weight=(0.D0)
Energyxw=(ProjectionE)

!Deallocate memory
CALL DeallocFCIMCMem()

CLOSE(fcimcstats_unit)

RETURN

END SUBROUTINE FciMC


!This is the heart of FCIMC, where the MC Cycles are performed
SUBROUTINE PerformFCIMCyc()
        !use GenRandSymExcitCSF, only: TestCSF123
        INTEGER :: VecSlot,j,l
        INTEGER :: nJ(NEl),IC,Child,iCount,TotWalkersNew
        REAL*8 :: Prob,rat,HDiag,UniformPGen
        INTEGER :: iDie             !Indicated whether a particle should self-destruct on DetCurr
        INTEGER :: ExcitLevel,iGetExcitLevel_2
        LOGICAL :: WSign
        HElement_t :: HDiagTemp,HOffDiag

!Set the timer for the walker loop - this should not be done always, as it will be time-consuming
        CALL set_timer(Walker_time,20)

!VecSlot indicates the next free position in NewDets
        VecSlot=1
        TotSign=0
!Reset the number at HF & doubs per iteration
        NoatHF=0
        NoatDoubs=0
        HOffDiag = 0

        do j=1,TotWalkers
            ! This is where you can call the CSF testing routine
            !call TestCSF123 (Currentdets(:,j))

!j runs through all current walkers

!Sum in any energy contribution from the determinant, including other parameters, such as excitlevel info
            CALL SumEContrib(CurrentIC(j),CurrentH(2,j),CurrentSign(j),j)

!Setup excit generators for this determinant (This can be reduced to an order N routine later for abelian symmetry.
            IF(.not.TRegenExcitgens) THEN
                CALL SetupExitgen(CurrentDets(:,j),CurrentExcits(j))
                CALL GenRandSymExcitIt3(CurrentDets(:,j),CurrentExcits(j)%ExcitData,nJ,Seed,IC,Prob,iCount)
            ELSE
                CALL GetPartRandExcit(CurrentDets(:,j),nJ,Seed,IC,Prob,iCount,CurrentIC(j))
            ENDIF

!                CALL TestGenRandSymExcitNU(nJ,1000000,0.97,Seed,3)
!                STOP

            IF(ICILevel.ne.0) THEN
!We are performing run in a truncated space
                IF(CurrentIC(j).eq.(ICILevel-1)) THEN
!The current walker is one below the excitation cutoff - if IC is a double, then could go over
                    IF(IC.eq.2) THEN
!Need to check excitation level of excitation
                        ExcitLevel=iGetExcitLevel_2(HFDet,nJ,NEl,ICILevel)
                        IF(ExcitLevel.gt.ICILevel) THEN
!Attempted excitation is above the excitation level cutoff - do not allow the creation of children
                            Child=0
                        ELSE
                            Child=AttemptCreate(CurrentDets(:,j),CurrentSign(j),nJ,Prob,IC)
                        ENDIF
                    ELSE
                        Child=AttemptCreate(CurrentDets(:,j),CurrentSign(j),nJ,Prob,IC)
                    ENDIF
                ELSEIF(CurrentIC(j).eq.ICILevel) THEN
!Walker is at the excitation cutoff level - all possible excitations could be disallowed - check the actual excitation level
                    ExcitLevel=iGetExcitLevel_2(HFDet,nJ,NEl,ICILevel)
                    IF(ExcitLevel.gt.ICILevel) THEN
!Attempted excitation is above the excitation level cutoff - do not allow the creation of children
                        Child=0
                    ELSE
                        Child=AttemptCreate(CurrentDets(:,j),CurrentSign(j),nJ,Prob,IC)
                    ENDIF
                ELSE
!Excitation cannot be in a dissallowed excitation level - allow it as normal
                    Child=AttemptCreate(CurrentDets(:,j),CurrentSign(j),nJ,Prob,IC)
                ENDIF

            ELSE
!Calculate number of children to spawn
                IF(TUnbiasPGeninProjE) THEN
!In this scheme, we do not unbias the acceptance probabilities due to the probability of generating the excitation.
!Instead, we unbias for this at the energy estimator, which has its contribution from this particle divided by PGen.
!However, we need to take into account that the determinants have different connectivity (mainly due to symmetry reasons)
!Therefore we need to accept, dividing the probability by the uniform probability of selecting a determinant (1/conn)
!This is then unbiased at the energy estimator again, so the PGen is divided by it...
                    UniformPGen=1.D0/REAL(iCount,dp)
                    Child=AttemptCreate(CurrentDets(:,j),CurrentSign(j),nJ,UniformPGen,IC)
                    Prob=Prob/UniformPGen
                ELSE
                    Child=AttemptCreate(CurrentDets(:,j),CurrentSign(j),nJ,Prob,IC)
                ENDIF

            ENDIF

            IF(Child.ne.0) THEN
                NoBorn=NoBorn+abs(Child)     !Increase the counter for the number of children born
                IF(Child.gt.25) THEN
                    WRITE(6,*) "LARGE PARTICLE BLOOM - ",Child," particles created in one attempt."
                    WRITE(6,*) "BEWARE OF MEMORY PROBLEMS"
!                        WRITE(6,*) "DETERMINANT CREATED IS: ",nJ
                    WRITE(6,*) "PROB IS: ",Prob
                    CALL FLUSH(6)
                ENDIF
!We want to spawn a child - find its information to store
                IF(Child.gt.0) THEN
                    WSign=.true.    !+ve child created
                ELSE
                    WSign=.false.   !-ve child created
                ENDIF
!Calculate excitation level, connection to HF and diagonal ham element
                ExcitLevel=iGetExcitLevel_2(HFDet,nJ,NEl,NEl)
                IF(ExcitLevel.eq.2) THEN
!Only need it for double excitations, since these are the only ones which contribute to energy
                    HOffDiag = get_helement(HFDet, nJ, 2)
                    HDiagTemp = get_helement (nJ, nJ, 0)
                    HDiag=(REAL(HDiagTemp,dp))-Hii
                ELSEIF(ExcitLevel.eq.0) THEN
!We know we are at HF - HDiag=0
                    HDiag=0.D0
                ELSE
                    HDiagTemp = get_helement (nJ, nJ, 0)
                    HDiag=(REAL(HDiagTemp,dp))-Hii
                ENDIF

                do l=1,abs(Child)
!Copy across children - cannot copy excitation generators, as do not know them
                    NewDets(:,VecSlot)=nJ(:)
                    NewSign(VecSlot)=WSign
                    IF(.not.TRegenExcitgens) NewExcits(VecSlot)%ExcitGenForDet=.false.
                    NewIC(VecSlot)=ExcitLevel
                    NewH(1,VecSlot)=HDiag      !Diagonal H-element-Hii
                    NewH(2,VecSlot)=REAL(HOffDiag,dp)       !Off-diagonal H-element
                    IF(TUnbiasPGeninProjE) NewPGen(VecSlot)=Prob
                    VecSlot=VecSlot+1
                enddo

                Acceptances=Acceptances+ABS(Child)  !Sum the number of created children to use in acceptance ratio

            ENDIF   !End if child created

!We now have to decide whether the parent particle (j) wants to self-destruct or not...
            iDie=AttemptDie(CurrentH(1,j))
!iDie can be positive to indicate the number of deaths, or negative to indicate the number of births

            NoDied=NoDied+iDie      !Increase the counter to indicated  number of particles that have died

            IF(iDie.le.0) THEN
!This indicates that the particle is spared and we may want to create more...copy them across to NewDets
!If iDie < 0, then we are creating the same particles multiple times. Copy accross (iDie+1) copies of particle

                do l=1,abs(iDie)+1    !We need to copy accross one more, since we need to include the original spared particle
                    NewDets(:,VecSlot)=CurrentDets(:,j)
                    NewSign(VecSlot)=CurrentSign(j)
!Copy excitation generator accross
                    IF(.not.TRegenExcitgens) CALL CopyExitgen(CurrentExcits(j),NewExcits(VecSlot))
                    NewIC(VecSlot)=CurrentIC(j)
                    NewH(:,VecSlot)=CurrentH(:,j)
                    IF(TUnbiasPGeninProjE) NewPGen(VecSlot)=CurrentPGen(j)
                    VecSlot=VecSlot+1
                enddo

            ELSEIF(iDie.gt.0) THEN
!This indicates that particles want to be killed. The first kill will simply be performed by not copying accross the original particle.
!Therefore, if iDie = 1, then we can simply ignore it.
!However, after that anti-particles will need to be created on the same determinant.

                do l=1,iDie-1
                    NewDets(:,VecSlot)=CurrentDets(:,j)
                    IF(CurrentSign(j)) THEN
!Copy accross new anti-particles
                        NewSign(VecSlot)=.FALSE.
                    ELSE
                        NewSign(VecSlot)=.TRUE.
                    ENDIF
!Copy excitation generator accross
                    IF(.not.TRegenExcitgens) CALL CopyExitgen(CurrentExcits(j),NewExcits(VecSlot))
                    NewIC(VecSlot)=CurrentIC(j)
                    NewH(:,VecSlot)=CurrentH(:,j)
                    IF(TUnbiasPGeninProjE) NewPGen(VecSlot)=CurrentPGen(j)
                    VecSlot=VecSlot+1
                enddo

            ENDIF   !To kill if

!Finish cycling over walkers
        enddo

!SumWalkersCyc calculates the total number of walkers over an update cycle on each process
        SumWalkersCyc=SumWalkersCyc+TotWalkers

!Since VecSlot holds the next vacant slot in the array, TotWalkers will be one less than this.
        TotWalkersNew=VecSlot-1
        rat=(TotWalkersNew+0.D0)/(MaxWalkers+0.D0)
        IF(rat.gt.0.9) THEN
            WRITE(6,*) "*WARNING* - Number of walkers has increased to over 90% of MaxWalkers"
        ENDIF

        CALL halt_timer(Walker_time)
        CALL set_timer(Annihil_time,20)

        IF(TNoAnnihil) THEN

            TotWalkers=TotWalkersNew    !Since there is no further cancellation of walkers

!However, we now need to swap around the pointers of CurrentDets and NewDets, since this was done previously explicitly in the annihilation routine
            IF(associated(CurrentDets,target=WalkVecDets)) THEN
                CurrentDets=>WalkVec2Dets
                CurrentSign=>WalkVec2Sign
                CurrentIC=>WalkVec2IC
                CurrentH=>WalkVec2H
                CurrentExcits=>WalkVec2Excits
                NewDets=>WalkVecDets
                NewSign=>WalkVecSign
                NewIC=>WalkVecIC
                NewH=>WalkVecH
                NewExcits=>WalkVecExcits
                IF(TUnbiasPGeninProjE) THEN
                    NewPGen=>WalkVecPGen
                    CurrentPGen=>WalkVec2PGen
                ENDIF
            ELSE
                CurrentDets=>WalkVecDets
                CurrentSign=>WalkVecSign
                CurrentIC=>WalkVecIC
                CurrentH=>WalkVecH
                CurrentExcits=>WalkVecExcits
                NewDets=>WalkVec2Dets
                NewSign=>WalkVec2Sign
                NewIC=>WalkVec2IC
                NewH=>WalkVec2H
                NewExcits=>WalkVec2Excits
                IF(TUnbiasPGeninProjE) THEN
                    NewPGen=>WalkVec2PGen
                    CurrentPGen=>WalkVecPGen
                ENDIF
            ENDIF

        ELSE

!This routine now cancels down the particles with opposing sign on each determinant
!This routine does not necessarily need to be called every Iter
            CALL AnnihilatePairs(TotWalkersNew)
            Annihilated=Annihilated+(TotWalkersNew-TotWalkers)
!            WRITE(6,*) "Number of annihilated particles= ",TotWalkersNew-TotWalkers,Iter,TotWalkers
        ENDIF

        CALL halt_timer(Annihil_time)

        IF(NoatHF.lt.0) THEN
!Flip the sign if we're beginning to get a negative population on the HF
            WRITE(6,*) "No. at HF < 0 - flipping sign of entire ensemble of particles..."
            CALL FlipSign()
        ENDIF
        IF(TotWalkers.eq.0) THEN
            CALL Stop_All("PerformFCIMCyc","All Walkers have died.")
        ENDIF

        IF(TSinglePartPhase) THEN
!Do not allow culling if we are still in the single particle phase.
            IF(TotWalkers.gt.InitWalkers) THEN
                WRITE(6,*) "Exiting the single particle growth phase - shift can now change"
                TSinglePartPhase=.false.
            ENDIF
        ELSE
!Check whether we need to cull particles
            IF(TotWalkers.gt.(InitWalkers*GrowMaxFactor)) THEN
!Particle number is too large - kill them randomly

!Log the fact that we have made a cull
                NoCulls=NoCulls+1
                IF(NoCulls.gt.10) THEN
                    WRITE(6,*) "Too Many Culls"
                    CALL FLUSH(6)
                    CALL Stop_All("FCIMC","Too Many Culls")
                ENDIF

                IF(TSignShift) THEN
!CullInfo(:,1) is walkers/residualsign before cull
                    CullInfo(NoCulls,1)=TotSign
                ELSE
                    CullInfo(NoCulls,1)=TotWalkers
                ENDIF
                IF(mod(Iter,StepsSft).eq.0) THEN
!CullInfo(:,3) is MC Steps into shift cycle before cull
!This is just before the calculation of the shift - we want the value to be equal to StepsSft
                    CullInfo(NoCulls,3)=StepsSft
                ELSE
                    CullInfo(NoCulls,3)=mod(Iter,StepsSft)
                ENDIF

                WRITE(6,"(A,F8.2,A)") "Total number of particles has grown to ",GrowMaxFactor," times initial number..."
                WRITE(6,"(A,I12,A)") "Killing randomly selected particles in cycle ", Iter," in order to reduce total number..."
                WRITE(6,"(A,F8.2)") "Population will reduce by a factor of ",CullFactor
                CALL ThermostatParticles(.true.)

            ELSEIF(TotWalkers.lt.(InitWalkers/2)) THEN
!Particle number is too small - double every particle in its current position

!Log the fact that we have made a cull
                NoCulls=NoCulls+1
                IF(NoCulls.gt.10) CALL Stop_All("PerformFCIMCyc","Too Many Culls")
                IF(TSignShift) THEN
!CullInfo(:,1) is walkers/residualsign before cull
                    CullInfo(NoCulls,1)=TotSign
                ELSE
                    CullInfo(NoCulls,1)=TotWalkers
                ENDIF
                IF(mod(Iter,StepsSft).eq.0) THEN
!CullInfo(:,3) is MC Steps into shift cycle before cull
!This is just before the calculation of the shift - we want the value to be equal to StepsSft
                    CullInfo(NoCulls,3)=StepsSft
                ELSE
                    CullInfo(NoCulls,3)=mod(Iter,StepsSft)
                ENDIF

                WRITE(6,*) "Doubling particle population to increase total number..."
                CALL ThermostatParticles(.false.)

            ENDIF

        ENDIF

        RETURN

    END SUBROUTINE PerformFCIMCyc



!    SUBROUTINE HFRetBiasIter(j,VecSlot)
!        LOGICAL :: SpawnBias,WSign,SameDet,TGenGuideDet
!        REAL*8 :: TotProb,Ran2,Prob,HDiag
!        INTEGER :: j,VecSlot,Child,iCount,IC,nJ(NEl),MaxExcits,ExcitLevel,iGetExcitLevel_2,iDie,l
!        HElement_t :: HOffDiag,HDiagTemp
!
!!We want the simplest guiding function - if we're at a double, attempt to spawn at HF with PRet probability
!        SpawnBias=.false.
!        TotProb=1.D0
!
!        IF(CurrentIC(j).eq.2) THEN
!!We are at a double - see if we are forced to return to HF
!            IF(Ran2(Seed).lt.PRet) THEN
!!Ensure that we try to spawn children at HF -   Modify prob of doing this to equal PRet
!                SpawnBias=.true.
!                IF(TExcludeRandGuide) THEN
!!In this method of unbiasing the Guiding function, we unbias completely at this stage
!                    Child=AttemptCreate(CurrentDets(:,j),CurrentSign(j),HFDet,PRet,2,CurrentH(2,j))
!                ELSE
!!No need to unbias here - divide by 1, not PRet
!                    Child=AttemptCreate(CurrentDets(:,j),CurrentSign(j),HFDet,1.D0,2,CurrentH(2,j))
!                ENDIF
!                IF(Child.ne.0) THEN
!                    IF(Child.gt.0) THEN
!                        WSign=.true. !We have successfully created at least one positive child at HF
!                    ELSE
!                        WSign=.false. !We have successfully created at least one negative child at HF
!                    ENDIF
!
!                    do l=1,abs(Child)
!!                                IF(abs(Child).gt.1) WRITE(6,*) "Multiple children created (returned)"
!!Copy across children to HF - can also copy across known excitation generator
!                        NewDets(:,VecSlot)=HFDet(:)
!                        NewSign(VecSlot)=WSign
!                        IF(.not.TRegenExcitgens) CALL CopyExitgen(HFExcit,NewExcits(VecSlot))
!                        NewIC(VecSlot)=0
!                        NewH(1,VecSlot)=0.D0
!                        NewH(2,VecSlot)=0.D0
!                        VecSlot=VecSlot+1
!                    enddo
!
!                    Acceptances=Acceptances+ABS(Child)  !Sum the number of created children to use in acceptance ratio
!
!                ENDIF   !End if child created
!
!            ELSE
!
!                TotProb=1.D0-PRet
!
!            ENDIF   !End if Spawning back at HF due to bias
!
!        ENDIF
!
!        IF(.not.SpawnBias) THEN
!!We are either at a double but have decided not to try to spawn back to HF, or we are not at a double
!
!!Setup excit generators for this determinant (This can be reduced to an order N routine later for abelian symmetry).
!            IF(.not.TRegenExcitgens) THEN
!                CALL SetupExitgen(CurrentDets(:,j),CurrentExcits(j))
!                CALL GenRandSymExcitIt3(CurrentDets(:,j),CurrentExcits(j)%ExcitData,nJ,Seed,IC,Prob,iCount)
!            ELSE
!                CALL GetPartRandExcit(CurrentDets(:,j),nJ,Seed,IC,Prob,iCount,CurrentIC(j))
!            ENDIF
!
!            !TESTS
!!            CALL GetSymExcitCount(CurrentExcits(j)%ExcitData,MaxExcits)
!!            IF(ABS((1.D0/MaxExcits)-Prob).gt.1.D-07) THEN
!!                WRITE(6,*) "PROBLEM WITH PGENS!"
!!                WRITE(6,*) MaxExcits,1.D0/MaxExcits,Prob
!!                CALL Stop_All("PerformFCIMCyc","Problem with PGens")
!!            ENDIF
!!            IF((CurrentIC(j).eq.2).and.(TotProb.ne.(1.D0-PRet))) WRITE(6,*) "PROBLEM HERE!!"
!!            IF((CurrentIC(j).ne.2).and.(TotProb.ne.1.D0)) WRITE(6,*) "PROBLEM HERE!"
!
!
!            IF(TExcludeRandGuide) THEN
!!We must not be allowed to generate a guiding determinant from a double excitation
!
!                IF(CurrentIC(j).eq.2) THEN
!
!                    IF(SameDet(HFDet,nJ,NEl)) THEN
!                        TGenGuideDet=.true.    !Have not generated a guiding determinant (HF)
!                    ELSE
!                        TGenGuideDet=.false.     !Have generated a guiding determinant (HF)
!                    ENDIF
!                    do while(TGenGuideDet)
!!Generate another randomly connected determinant in order to not generate a guiding determinant
!
!                        IF(.not.TRegenExcitgens) THEN
!                            CALL GenRandSymExcitIt3(CurrentDets(:,j),CurrentExcits(j)%ExcitData,nJ,Seed,IC,Prob,iCount)
!                        ELSE
!                            CALL GetPartRandExcit(CurrentDets(:,j),nJ,Seed,IC,Prob,iCount,CurrentIC(j))
!                        ENDIF
!                        IF(.not.(SameDet(HFDet,nJ,NEl))) TGenGuideDet=.false.
!
!                    enddo   !Have now definitely generated a non-HF determinant
!!Need to change the probabilities of generating these excitations, since there is now a determinant which is forbidden
!
!                    Prob=1.D0/(MaxExcits-1)      !Prob is now 1/(N-1) - do not allow excit weighting
!                    TotProb=TotProb*Prob
!
!                ELSE
!!We are not at a double - want to unbias with normal prob
!                    TotProb=Prob
!
!                ENDIF
!
!            ELSE
!!The other unbiasing method allows the guiding determinant to be generated, but we unbias it differently.
!
!                IF(CurrentIC(j).eq.2) THEN
!                    IF(SameDet(HFDet,nJ,NEl)) THEN
!!We are at a double, and have decided to randomly attempt a return to the guiding function HF determinant, so we need to change
!!the Pgen - it wants to be unbiased by dividing by just PGen, not PGen*(1-PRet).
!                        TotProb=Prob
!                    ELSE
!                        TotProb=TotProb*Prob    !TotProb should initially by 1, or 1-PRet if we are at a double
!                    ENDIF
!
!                ELSE
!
!                    TotProb=Prob
!
!                ENDIF
!
!            ENDIF !Choice of unbiasing methods
!
!!Calculate number of children to spawn
!! TODO: We want to have the iLut of any generated excitations by now.
!            Child=AttemptCreate(CurrentDets(:,j),CurrentSign(j),nJ,TotProb,IC)
!
!            IF(Child.ne.0) THEN
!!We want to spawn a child - find its information to store
!                IF(Child.gt.0) THEN
!                    WSign=.true.    !+ve child created
!                ELSE
!                    WSign=.false.   !-ve child created
!                ENDIF
!!Calculate excitation level, connection to HF and diagonal ham element
!                ExcitLevel=iGetExcitLevel_2(HFDet,nJ,NEl,NEl)
!                IF(ExcitLevel.eq.2) THEN
!!Only need it for double excitations, since these are the only ones which contribute to energy
!                    HOffDiag = get_helement(HFDet, nJ, 2)
!                ENDIF
!                IF(ExcitLevel.eq.0) THEN
!!We know we are at HF - HDiag=0
!                    HDiag=0.D0
!                ELSE
!                    HDiagTemp = get_helement (nJ, nJ, 0)
!                    HDiag=(REAL(HDiagTemp,dp))-Hii
!                ENDIF
!
!                do l=1,abs(Child)
!!Copy across children - cannot copy excitation generators, as do not know them
!                    NewDets(:,VecSlot)=nJ(:)
!                    NewSign(VecSlot)=WSign
!                    IF(.not.TRegenExcitgens) NewExcits(VecSlot)%ExcitGenForDet=.false.
!                    NewIC(VecSlot)=ExcitLevel
!                    NewH(1,VecSlot)=HDiag      !Diagonal H-element-Hii
!                    NewH(2,VecSlot)=REAL(HOffDiag,dp)       !Off-diagonal H-element
!                    VecSlot=VecSlot+1
!                enddo
!
!                Acceptances=Acceptances+ABS(Child)  !Sum the number of created children to use in acceptance ratio
!
!            ENDIF   !End if child created
!
!        ENDIF   !End if we are trying to create a child which isn't a returning spawn
!!We now have to decide whether the parent particle (j) wants to self-destruct or not...
!        iDie=AttemptDie(CurrentDets(:,j),CurrentH(1,j),CurrentIC(j))
!!iDie can be positive to indicate the number of deaths, or negative to indicate the number of births
!
!        IF(iDie.le.0) THEN
!!This indicates that the particle is spared and we may want to create more...copy them across to NewDets
!!If iDie < 0, then we are creating the same particles multiple times. Copy accross (iDie+1) copies of particle
!
!            do l=1,abs(iDie)+1    !We need to copy accross one more, since we need to include the original spared particle
!                NewDets(:,VecSlot)=CurrentDets(:,j)
!                NewSign(VecSlot)=CurrentSign(j)
!!Copy excitation generator accross
!                IF(.not.TRegenExcitgens) CALL CopyExitgen(CurrentExcits(j),NewExcits(VecSlot))
!                NewIC(VecSlot)=CurrentIC(j)
!                NewH(:,VecSlot)=CurrentH(:,j)
!                VecSlot=VecSlot+1
!            enddo
!
!        ELSEIF(iDie.gt.0) THEN
!!This indicates that particles want to be killed. The first kill will simply be performed by not copying accross the original particle.
!!Therefore, if iDie = 1, then we can simply ignore it.
!!However, after that anti-particles will need to be created on the same determinant.
!
!            do l=1,iDie-1
!                NewDets(:,VecSlot)=CurrentDets(:,j)
!                IF(CurrentSign(j)) THEN
!!Copy accross new anti-particles
!                    NewSign(VecSlot)=.FALSE.
!                ELSE
!                    NewSign(VecSlot)=.TRUE.
!                ENDIF
!!Copy excitation generator accross
!                IF(.not.TRegenExcitgens) CALL CopyExitgen(CurrentExcits(j),NewExcits(VecSlot))
!                NewIC(VecSlot)=CurrentIC(j)
!                NewH(:,VecSlot)=CurrentH(:,j)
!                VecSlot=VecSlot+1
!            enddo
!
!        ENDIF   !To kill if
!        RETURN
!    END SUBROUTINE HFRetBiasIter
!
!!This impliments a fixed sign approximation, whereby connections in the system which would flip the sign of the
!!particle are resummed into the diagonal matrix element contributing to the on-site death rate.
!!For a real-space analogue, see: D.F.B. ten Haaf, H.J.M. van Bemmel, J.M.J. van Leeuwen, W. van Saarloos, and D.M.
!!Ceperley, Phys. Rev. B 51, 13039 (1995)
!    SUBROUTINE FixParticleSignIter(Walker,VecSlot)
!        INTEGER :: Walker,VecSlot,nStore(6),nJ(NEl),IC,Child,ExcitLevel,iGetExcitLevel_2
!        INTEGER :: iDie,l
!        HElement_t :: HConn,HOffDiag,HDiagTemp
!        TYPE(ExcitGenerator) :: TempExcitgen
!        LOGICAL :: WSign
!        REAL*8 :: SpinFlipContrib,HConnReal,HDiag,DiagDeath
!
!!Setup excitgen
!        IF(.not.TRegenExcitgens) THEN
!            CALL SetupExitgen(CurrentDets(:,Walker),CurrentExcits(Walker))
!            CALL ResetExit2(CurrentDets(:,Walker),NEl,G1,nBasis,nBasisMax,CurrentExcits(Walker)%ExcitData,0) !Reset excitgen
!        ELSE
!            CALL SetupExitgen(CurrentDets(:,Walker),TempExcitgen)
!        ENDIF
!
!!Run through all excits
!        do while(.true.)
!            IF(TRegenExcitgens) THEN
!                CALL GenSymExcitIt2(CurrentDets(:,Walker),NEl,G1,nBasis,nBasisMax,.false.,TempExcitgen%ExcitData,nJ,IC,0,nStore,exFlag)
!            ELSE
!                CALL GenSymExcitIt2(CurrentDets(:,Walker),NEl,G1,nBasis,nBasisMax,.false.,CurrentExcits(Walker)%ExcitData,nJ,IC,0,nStore,exFlag)
!            ENDIF
!            IF(nJ(1).eq.0) EXIT
!            HConn = get_helement (CurrentDets(:,Walker), nJ, IC)
!            HConnReal=REAL(HConn,dp)
!            IF(HConnReal.lt.0.D0) THEN
!!Connection is negative, therefore attempt to create a particle there - we are running through all walkers, so Prob=1.D0
!                Child=AttemptCreate(CurrentDets(:,Walker),CurrentSign(Walker),nJ,1.D0,IC,HConnReal)
!
!                IF(Child.ne.0) THEN
!!We want to spawn a child - find its information to store
!                    IF(Child.gt.0) THEN
!                        WSign=.true.    !+ve child created
!                    ELSE
!                        WSign=.false.   !-ve child created
!                        IF(CurrentSign(Walker)) THEN
!                            CALL Stop_All("FixParticleSignIter","Particle of opposite sign created - this should not happen with FixParticleSign")
!                        ENDIF
!                    ENDIF
!!Calculate excitation level, connection to HF and diagonal ham element
!                    ExcitLevel=iGetExcitLevel_2(HFDet,nJ,NEl,NEl)
!                    IF(ExcitLevel.eq.2) THEN
!!Only need it for double excitations, since these are the only ones which contribute to energy
!                        HOffDiag = get_helement (HFDet, nJ, 2)
!                    ENDIF
!                    IF(ExcitLevel.eq.0) THEN
!!We know we are at HF - HDiag=0
!                        HDiag=0.D0
!                    ELSE
!                        HDiagTemp = get_helement (nJ, nJ, 0)
!                        HDiag=(REAL(HDiagTemp,dp))-Hii
!                    ENDIF
!
!                    do l=1,abs(Child)
!!Copy across children - cannot copy excitation generators, as do not know them
!                        NewDets(:,VecSlot)=nJ(:)
!                        NewSign(VecSlot)=WSign
!                        IF(.not.TRegenExcitgens) NewExcits(VecSlot)%ExcitGenForDet=.false.
!                        NewIC(VecSlot)=ExcitLevel
!                        NewH(1,VecSlot)=HDiag      !Diagonal H-element-Hii
!                        NewH(2,VecSlot)=REAL(HOffDiag,dp)       !Off-diagonal H-element
!                        VecSlot=VecSlot+1
!                    enddo
!
!                    Acceptances=Acceptances+ABS(Child)  !Sum the number of created children to use in acceptance ratio
!
!                ENDIF   !End if child created
!
!            ELSE
!!Sum in positive connections to a spin-flip term which modifies the diagonal death-rate
!                SpinFlipContrib=SpinFlipContrib+HConnReal
!
!            ENDIF
!
!        enddo   !End of searching through excits
!
!        IF(.not.TRegenExcitgens) CALL ResetExit2(CurrentDets(:,Walker),NEl,G1,nBasis,nBasisMax,CurrentExcits(Walker)%ExcitData,0) !Reset excitgen
!
!!Add the spin-flip contribution to the death-rate
!        DiagDeath=CurrentH(1,Walker)+SpinFlipContrib
!
!!We now have to decide whether the parent particle (Walker) wants to self-destruct or not...
!        iDie=AttemptDie(CurrentDets(:,Walker),DiagDeath,CurrentIC(Walker))
!!iDie can be positive to indicate the number of deaths, or negative to indicate the number of births
!
!        IF(iDie.le.0) THEN
!!This indicates that the particle is spared and we may want to create more...copy them across to NewDets
!!If iDie < 0, then we are creating the same particles multiple times. Copy accross (iDie+1) copies of particle
!
!            do l=1,abs(iDie)+1    !We need to copy accross one more, since we need to include the original spared particle
!                NewDets(:,VecSlot)=CurrentDets(:,Walker)
!                NewSign(VecSlot)=CurrentSign(Walker)
!!Copy excitation generator accross
!                IF(.not.TRegenExcitgens) CALL CopyExitgen(CurrentExcits(Walker),NewExcits(VecSlot))
!                NewIC(VecSlot)=CurrentIC(Walker)
!                NewH(:,VecSlot)=CurrentH(:,Walker)
!                VecSlot=VecSlot+1
!            enddo
!
!        ELSEIF(iDie.gt.0) THEN
!!This indicates that particles want to be killed. The first kill will simply be performed by not copying accross the original particle.
!!Therefore, if iDie = 1, then we can simply ignore it.
!!However, after that anti-particles will need to be created on the same determinant.
!
!            do l=1,iDie-1
!                NewDets(:,VecSlot)=CurrentDets(:,Walker)
!                IF(CurrentSign(Walker)) THEN
!!Copy accross new anti-particles
!                    NewSign(VecSlot)=.FALSE.
!                ELSE
!                    NewSign(VecSlot)=.TRUE.
!                ENDIF
!!Copy excitation generator accross
!                IF(.not.TRegenExcitgens) CALL CopyExitgen(CurrentExcits(Walker),NewExcits(VecSlot))
!                NewIC(VecSlot)=CurrentIC(Walker)
!                NewH(:,VecSlot)=CurrentH(:,Walker)
!                VecSlot=VecSlot+1
!            enddo
!
!        ENDIF   !To kill if
!
!        RETURN
!
!    END SUBROUTINE FixParticleSignIter
!
!!This routine creates, and allocates particles, according to a resummed graph.
!    SUBROUTINE ResumGraph(nI,WSign,VecSlot,VecInd,nIExcitGen)
!        INTEGER :: nI(NEl),VecSlot,VecInd,ExcitLevel,iGetExcitLevel_2,Create,i,j
!        TYPE(ExcitGenerator) , OPTIONAL :: nIExcitGen
!        HElement_t :: HOffDiag
!        LOGICAL :: WSign,ChildSign
!        REAL*8 :: Prob,rat,Ran2
!
!        IF(TRegenExcitgens) THEN
!            IF(present(nIExcitGen)) THEN
!                CALL Stop_All("ResumGraph","nIExcitGen present, but regenerating ExGens")
!            ENDIF
!            CALL CreateGraph(nI,Prob,VecInd)
!        ELSE
!            IF(.not.present(nIExcitGen)) THEN
!                CALL Stop_All("ResumGraph","nIExcitGen not present, but not regenerating ExGens")
!            ENDIF
!            CALL CreateGraph(nI,Prob,VecInd,nIExcitGen)      !Create graph with NDets distinct determinants
!        ENDIF
!
!        CALL ApplyRhoMat()   !Apply the rho matrix successive times
!
!!First find how many to create at the root determinant
!        Create=INT(abs(GraphVec(1)))
!        rat=abs(GraphVec(1))-REAL(Create,dp)
!        IF(rat.gt.Ran2(Seed)) Create=Create+1
!        IF(.not.WSign) Create=-Create
!        IF(GraphVec(1).lt.0.D0) Create=-Create
!        do j=1,abs(Create)
!            NewDets(:,VecSlot)=nI(:)
!            IF(Create.lt.0) THEN
!                NewSign(VecSlot)=.false.
!            ELSE
!                NewSign(VecSlot)=.true.
!            ENDIF
!            NewIC(VecSlot)=CurrentIC(VecInd)
!            NewH(:,VecSlot)=CurrentH(:,VecInd)
!            IF(.not.TRegenExcitgens) CALL CopyExitgen(CurrentExcits(VecInd),NewExcits(VecSlot))
!            VecSlot=VecSlot+1
!        enddo
!
!        do i=2,NDets
!!Now create the new particles according the the final vector GraphVec
!
!            GraphVec(i)=GraphVec(i)/((NDets-1)*Prob)    !Augment the component by the chances of picking that determinant
!
!            Create=INT(abs(GraphVec(i)))
!            rat=abs(GraphVec(i))-REAL(Create,dp)    !rat is now the fractional part, to be assigned stochastically
!            IF(rat.gt.Ran2(Seed)) Create=Create+1
!            IF(abs(Create).gt.0) THEN
!                IF(.not.WSign) Create=-Create
!                IF(GraphVec(i).lt.0.D0) Create=-Create
!!Find needed information out about the new particles
!!Calculate excitation level, connection to HF. Diagonal ham element info is already stored
!
!                ExcitLevel=iGetExcitLevel_2(HFDet,DetsinGraph(:,i),NEl,NEl)
!                IF(ExcitLevel.eq.2) THEN
!!Only need it for double excitations, since these are the only ones which contribute to energy
!                    HOffDiag = get_helement (HFDet, DetsInGraph(:,i), 2)
!                ENDIF
!                IF(Create.lt.0) THEN
!                    ChildSign=.false.
!                ELSE
!                    ChildSign=.true.
!                ENDIF
!
!!Now actually create the particles in NewDets and NewSign
!                do j=1,abs(Create)
!                    NewDets(:,VecSlot)=DetsInGraph(:,i)
!                    NewSign(VecSlot)=ChildSign
!                    NewIC(VecSlot)=ExcitLevel
!                    NewH(1,VecSlot)=GraphKii(i)       !Diagonal H El previously stored
!                    NewH(2,VecSlot)=REAL(HOffDiag,dp)
!                    IF(.not.TRegenExcitgens) NewExcits(VecSlot)%ExitGenForDet=.false.
!                    VecSlot=VecSlot+1
!                enddo
!
!            ENDIF
!
!        enddo
!
!        RETURN
!
!    END SUBROUTINE ResumGraph
!
!    SUBROUTINE CreateGraph(nI,Prob,VecInd,nIExcitGen)
!        INTEGER :: nI(NEl),VecInd,nJ(NEl),iCount,IC,i,j,Attempts
!        TYPE(ExcitGenerator) , OPTIONAL :: nIExcitGen
!        REAL*8 :: Prob,Kii,ExcitProb
!        LOGICAL :: SameDet,CompiPath
!        HElement_t :: Hamij,Hamii
!        integer :: iLutnJ(nel), iLutTmp(nel)
!
!        GraphRhoMat=0.d0
!
!!Do not need to put the root determinant in the first column of DetsinGraph -
!!just assume its there.
!
!        Kii=CurrentH(1,VecInd)      !This is now the Kii element of the root
!        GraphRhoMat(1,1)=1.D0-Tau*(Kii-DiagSft)
!
!        i=2
!        do while(i.lt.NDets)    !Loop until all determinants found
!
!            IF(TRegenExcitgens) THEN
!                CALL GetPartRandExcit(nI,nJ,Seed,IC,Prob,iCount,CurrentIC(VecInd))
!            ELSE
!                CALL GenRandSymExcitIt3(nI,nIExcitGen%ExcitData,nJ,Seed,IC,Prob,iCount)
!            ENDIF
!
!            SameDet=.false.
!            do j=2,(i-1)
!                IF(CompiPath(nJ,DetsinGraph(:,j),NEl)) THEN
!!Determinants are the same as already created determinant - ignore it
!
!                    SameDet=.true.
!                    Attempts=Attempts+1
!                    IF(Attempts.gt.100) CALL Stop_All("CreateGraphPar","More than 100 attempts needed to grow graph")
!                    EXIT
!                ENDIF
!            enddo
!
!            IF(.not.SameDet) THEN
!!Store the unbiased probability of generating excitations from this root - check that it is the same as other excits generated
!                IF(i.eq.2) THEN
!                    ExcitProb=Prob
!                ELSE
!                    IF(abs(Prob-ExcitProb).gt.1.D-07) THEN
!                        CALL Stop_All("CreateGraph","Excitation probabilities are not uniform - problem here...")
!                    ENDIF
!                ENDIF
!
!!Determinant is distinct - add it
!                DetsinGraph(:,i)=nJ(:)
!!First find connection to root
!                Hamij = get_helement(nI, nJ, IC)
!                GraphRhoMat(1,i)=-Tau*REAL(Hamij,dp)
!                GraphRhoMat(i,1)=GraphRhoMat(1,i)
!
!!Then find connection to other determinants
!                call EncodeBitDet (nJ, iLutnJ)
!                do j=2,(i-1)
!                    call EncodeBitDet (DetsInGraph(:,j), iLutTmp)
!                    Hamij = get_helement(nJ, DetsInGraph(:,j), iLutnJ,iLutTmp)
!                    GraphRhoMat(i,j)=-Tau*REAL(Hamij,dp)
!                    GraphRhoMat(j,i)=GraphRhoMat(i,j)
!                enddo
!
!!Find diagonal element - and store it for later on...
!                Hamii = get_helement (nJ, nJ, 0)
!                GraphKii(i)=REAL(Hamii,dp)-Hii                !Again, the root value is not stored
!                GraphRhoMat(i,i)=1.D0-Tau*(GraphKii(i)-DiagSft)
!
!                i=i+1
!
!            ENDIF
!        enddo
!
!        RETURN
!
!    END SUBROUTINE CreateGraph
!
!!This applies the rho matrix successive times to a root determinant. From this, GraphVec is filled with the correct probabilities for the determinants in the graph
!    SUBROUTINE ApplyRhoMat()
!        REAL*8 :: TempVec(NDets)
!        INTEGER :: i,j,k
!
!        GraphVec=0.d0
!        GraphVec(1)=1.D0        !Set the initial vector to be 1 at the root (i.e. for one walker initially)
!
!        do i=1,RhoApp
!
!            CALL DGEMV('n',NDets,NDets,1.D0,GraphRhoMat,NDets,GraphVec,1,0.D0,TempVec,1)
!            CALL DCOPY(NDets,TempVec,1,GraphVec,1)
!            TempVec=0.d0
!
!!            do j=1,NDets
!!                TempVec(j)=0.D0
!!                do k=1,NDets
!!                    TempVec(j)=TempVec(j)+GraphRhoMat(j,k)*GraphVec(k)
!!                enddo
!!            enddo
!!            GraphVec(:)=TempVec(:)
!
!        enddo
!
!        RETURN
!
!    END SUBROUTINE ApplyRhoMat

!This will flip the sign of all the particles.
    SUBROUTINE FlipSign()
        INTEGER :: i

        do i=1,TotWalkers
            CurrentSign(i)=.not.CurrentSign(i)
        enddo
        RETURN
    END SUBROUTINE FlipSign


!This routine looks at the change in residual particle number over a number of cycles, and adjusts the
!value of the diagonal shift in the hamiltonian in order to compensate for this
    SUBROUTINE UpdateDiagSft()
        IMPLICIT NONE
        INTEGER :: j,GrowthSteps
        REAL*8 :: AvConnection

        IF(NoCulls.eq.0) THEN
            IF(TSignShift) THEN
!                WRITE(6,*) TotSign,TotSignOld,TotWalkers,TotWalkersOld
                GrowRate=(ABS(TotSign)+0.D0)/(ABS(TotSignOld)+0.D0)
            ELSE
                GrowRate=(TotWalkers+0.D0)/(TotWalkersOld+0.D0)
            ENDIF
        ELSEIF(NoCulls.eq.1) THEN
!GrowRate is the sum of the individual grow rates for each uninterrupted growth sequence, multiplied by the fraction of the cycle which was spent on it
            IF(TSignShift) THEN
                GrowRate=((CullInfo(1,3)+0.D0)/(StepsSft+0.D0))*(ABS(CullInfo(1,1)+0.D0))/(ABS(TotSignOld+0.D0))
                GrowRate=GrowRate+(((StepsSft-CullInfo(1,3))+0.D0)/(StepsSft+0.D0))* &
                &   ((ABS(TotSign)+0.D0)/(ABS(CullInfo(1,2))+0.D0))

            ELSE
                GrowRate=((CullInfo(1,3)+0.D0)/(StepsSft+0.D0))*((CullInfo(1,1)+0.D0)/(TotWalkersOld+0.D0))
                GrowRate=GrowRate+(((StepsSft-CullInfo(1,3))+0.D0)/(StepsSft+0.D0))*((TotWalkers+0.D0)/(CullInfo(1,2)+0.D0))
            ENDIF

            NoCulls=0
            CullInfo=0
        ELSE
!More than one cull in this update cycle
            IF(TSignShift) THEN
                GrowRate=((CullInfo(1,3)+0.D0)/(StepsSft+0.D0))*((ABS(CullInfo(1,1))+0.D0)/(ABS(TotSignOld)+0.D0))
                do j=2,NoCulls

!This is needed since the steps between culling is stored cumulatively
                    GrowthSteps=CullInfo(j,3)-CullInfo(j-1,3)
                    GrowRate=GrowRate+((GrowthSteps+0.D0)/(StepsSft+0.D0))* &
                    &   ((ABS(CullInfo(j,1))+0.D0)/(ABS(CullInfo(j-1,2))+0.D0))

                enddo

                GrowthSteps=StepsSft-CullInfo(NoCulls,3)
                GrowRate=GrowRate+((GrowthSteps+0.D0)/(StepsSft+0.D0))*((ABS(TotSign)+0.D0)/(ABS(CullInfo(NoCulls,2))+0.D0))

            ELSE
                GrowRate=((CullInfo(1,3)+0.D0)/(StepsSft+0.D0))*((CullInfo(1,1)+0.D0)/(TotWalkersOld+0.D0))
                do j=2,NoCulls

!This is needed since the steps between culling is stored cumulatively
                    GrowthSteps=CullInfo(j,3)-CullInfo(j-1,3)
                    GrowRate=GrowRate+((GrowthSteps+0.D0)/(StepsSft+0.D0))*((CullInfo(j,1)+0.D0)/(CullInfo(j-1,2)+0.D0))

                enddo

                GrowthSteps=StepsSft-CullInfo(NoCulls,3)
                GrowRate=GrowRate+((GrowthSteps+0.D0)/(StepsSft+0.D0))*((TotWalkers+0.D0)/(CullInfo(NoCulls,2)+0.D0))
            ENDIF

            NoCulls=0
            CullInfo=0

        ENDIF

        IF(.not.TSinglePartPhase) THEN
            DiagSft=DiagSft-(log(GrowRate)*SftDamp)/(Tau*(StepsSft+0.D0))
        ENDIF
!        IF((DiagSft).gt.0.D0) THEN
!            WRITE(6,*) "***WARNING*** - DiagSft trying to become positive..."
!            STOP
!        ENDIF

        MeanExcitLevel=(MeanExcitLevel/(real(SumWalkersCyc,dp)))
        AvSign=AvSign/real(SumWalkersCyc,dp)
        ProjectionE=SumENum/SumNoatHF
        AccRat=(REAL(Acceptances,dp))/(REAL(SumWalkersCyc,dp))
        ProjectionMP2=((SumHOverlapMP2/SumOverlapMP2)-Hii)/2.D0
        AvConnection=SumConnections/REAL(SumWalkersCyc,dp)

!Write out MC cycle number, Shift, Change in Walker no, Growthrate, New Total Walkers...
        IF(TProjEMP2) THEN
            WRITE(fcimcstats_unit,"(I12,G15.6,I7,G15.6,I10,3I7,2G15.6,2I9,4G14.6,2I6)") PreviousCycles+Iter,DiagSft, &
            &   TotWalkers-TotWalkersOld,GrowRate,TotWalkers,Annihilated,NoDied,NoBorn,ProjectionE,  &
     &         ProjectionMP2,NoatHF,NoatDoubs,AvSign,AccRat,AvConnection,MeanExcitLevel,MinExcitLevel,MaxExcitLevel
            WRITE(6,"(I12,G15.6,I7,G15.6,I10,3I7,2G15.6,2I9,4G14.6,2I6)") PreviousCycles+Iter,DiagSft, &
            &    TotWalkers-TotWalkersOld,GrowRate,TotWalkers,Annihilated,NoDied,NoBorn,ProjectionE,   &
     &         ProjectionMP2,NoatHF,NoatDoubs,AvSign,AccRat,AvConnection,MeanExcitLevel,MinExcitLevel,MaxExcitLevel
        ELSE
            WRITE(fcimcstats_unit,"(I12,G15.6,I7,G15.6,I10,3I7,G15.6,2I9,4G14.6,2I6)") PreviousCycles+Iter,DiagSft, &
            &  TotWalkers-TotWalkersOld,GrowRate,TotWalkers,Annihilated,NoDied,NoBorn,ProjectionE,  &
     &         NoatHF,NoatDoubs,AvSign,AccRat,AvConnection,MeanExcitLevel,MinExcitLevel,MaxExcitLevel
            WRITE(6,"(I12,G15.6,I7,G15.6,I10,3I7,G15.6,2I9,4G14.6,2I6)") PreviousCycles+Iter,DiagSft,TotWalkers-TotWalkersOld, &
            &   GrowRate,TotWalkers,Annihilated,NoDied,NoBorn,ProjectionE,   &
     &         NoatHF,NoatDoubs,AvSign,AccRat,AvConnection,MeanExcitLevel,MinExcitLevel,MaxExcitLevel
        ENDIF
!        WRITE(6,*) SumHOverlapMP2,SumOverlapMP2
        CALL FLUSH(fcimcstats_unit)
        CALL FLUSH(6)

!Now need to reinitialise all variables
        MinExcitLevel=NEl+10
        MaxExcitLevel=0
        MeanExcitLevel=0.D0
        SumWalkersCyc=0
        AvSign=0.D0        !reinitialise this - average is over update cycle
        Annihilated=0
        ConnAnnihil=0
        Acceptances=0
        SumConnections=0.D0
        NoDied=0
        NoBorn=0

!Reset TotWalkersOld so that it is the number of walkers now
        TotWalkersOld=TotWalkers
        TotSignOld=TotSign

        IF(TWriteDetE) THEN
!Write out the histograms of the energy of the determinants for each excitation level
            CALL WriteEnergyHist()
        ENDIF

        RETURN

    END SUBROUTINE UpdateDiagSft


!This routine sums in the energy contribution from a given walker and updates stats such as mean excit level
    SUBROUTINE SumEContrib(ExcitLevel,Hij0,WSign,j)
        INTEGER :: ExcitLevel,j,Bin
        LOGICAL :: WSign
        REAL*8 :: Hij0      !This is the hamiltonian matrix element between DetCurr and HF
        REAL*8 :: DetE

        MeanExcitLevel=MeanExcitLevel+real(ExcitLevel,dp)
        IF(MinExcitLevel.gt.ExcitLevel) MinExcitLevel=ExcitLevel
        IF(MaxExcitLevel.lt.ExcitLevel) MaxExcitLevel=ExcitLevel
        IF(ExcitLevel.eq.0) THEN
            IF(WSign) THEN
                IF(Iter.gt.NEquilSteps) THEN
                    IF(TUnbiasPGeninProjE) THEN
                        SumNoatHF=SumNoatHF+(1.D0/CurrentPGen(j))
                    ELSE
                        SumNoatHF=SumNoatHF+1.D0
                    ENDIF
                ENDIF
                NoatHF=NoatHF+1
                AvSign=AvSign+1.D0
                TotSign=TotSign+1
            ELSE
                IF(Iter.gt.NEquilSteps) THEN
                    IF(TUnbiasPGeninProjE) THEN
                        SumNoatHF=SumNoatHF-(1.D0/CurrentPGen(j))
                    ELSE
                        SumNoatHF=SumNoatHF-1.D0
                    ENDIF
                ENDIF
                AvSign=AvSign-1.D0
                NoatHF=NoatHF-1
                TotSign=TotSign-1
            ENDIF
        ELSEIF(ExcitLevel.eq.2) THEN
            NoatDoubs=NoatDoubs+1   !Count number at double excitations in a cycle
!At double excit - sum in energy
            IF(WSign) THEN
                IF(Iter.gt.NEquilSteps) THEN
                    IF(TUnbiasPGeninProjE) THEN
                        SumENum=SumENum+(Hij0/CurrentPGen(j))
                    ELSE
                        SumENum=SumENum+Hij0
                    ENDIF
                ENDIF
                AvSign=AvSign+1.D0
                TotSign=TotSign+1
            ELSE
                IF(Iter.gt.NEquilSteps) THEN
                    IF(TUnbiasPGeninProjE) THEN
                        SumENum=SumENum-(Hij0/CurrentPGen(j))
                    ELSE
                        SumENum=SumENum-Hij0
                    ENDIF
                ENDIF
                TotSign=TotSign-1
                AvSign=AvSign-1.D0
            ENDIF
        ELSE
            IF(WSign) THEN
                AvSign=AvSign+1.D0
                TotSign=TotSign+1
            ELSE
                TotSign=TotSign-1
                AvSign=AvSign-1.D0
            ENDIF
        ENDIF

        IF(TWriteDetE) THEN
!We are histogramming the energy of the determinants for each excitation level...
            IF(ExcitLevel.ne.0) THEN
                DetE=CurrentH(1,j)
                Bin=CEILING(DetE*NoHistBins/MaxHistE)       !This will find the right bin
                IF(Bin.le.0) THEN
                    CALL Stop_All("SumEContrib","Trying to access a zero or negative bin number")
                ELSEIF(Bin.gt.NoHistBins) THEN
                    WRITE(6,*) "Trying to histogram to for a determinant higher in energy than MaxHistE. " &
                    & //"Think about increasing this to recover all data.",Bin
                ELSE
                    EHistBins(ExcitLevel,Bin)=EHistBins(ExcitLevel,Bin)+1
                ENDIF
            ENDIF
        ENDIF

        RETURN

    END SUBROUTINE SumEContrib

!!This routine will add the energy contribution from the overlap of the walker with the MP2 wavefunction
!!We want to calculate the energy as: sum_n <Psi_MP2 | H | Psi>/ sum_n <Psi_MP2 | Psi> where n is all iterations
!    SUBROUTINE AddProjMP2Energy(DetCurr,ExcitLevel,Hij0,WSign,j)
!        INTEGER :: DetCurr(NEl),ExcitLevel,j,OrbI,OrbJ,OrbA,OrbB,t
!        INTEGER :: ExcitForm(2,2),nJ(NEl),nStore(6),iExcit,nJ_IC
!        INTEGER :: iGetExcitLevel_2
!        REAL*8 :: Hij0,MP1Compt,Hij,Hjj
!        LOGICAL :: WSign,tSign
!        TYPE(ExcitGenerator) :: TempExcitgen
!        HElement_t :: Hijtemp,TempFjj,Hij2temp
!
!!First calculate the overlap of the wavefunction with the MP2 wavefunction - only doubles/HF will contribute
!        IF(ExcitLevel.eq.2) THEN
!
!            TempFjj=GetH0Element3(DetCurr)
!            MP1Compt=-Hij0/(Fii-(REAL(TempFjj,dp)))
!            IF(WSign) THEN
!                SumOverlapMP2=SumOverlapMP2+MP1Compt
!            ELSE
!                SumOverlapMP2=SumOverlapMP2-MP1Compt
!            ENDIF
!
!!!We need to find the ijab orbitals of the double excitation
!!            ExcitForm(1,1)=ExcitLevel
!!
!!            CALL GetExcitation(HFDet,DetCurr,NEl,ExcitForm,tSign)
!!!The i,j orbitals are ExcitForm(1,1) and (1,2). a/b are (2,1) and (2,2)
!!!Find the ordering of the orbitals in terms of energy
!!            OrbI=INVBRRSpinOrb(ExcitForm(1,1))
!!            OrbJ=INVBRRSpinOrb(ExcitForm(1,2))
!!            OrbA=INVBRRSpinOrb(ExcitForm(2,1))
!!            OrbB=INVBRRSpinOrb(ExcitForm(2,2))
!!
!!!Ensure i > j and a > b.
!!            IF(OrbI.lt.OrbJ) THEN
!!                t=OrbI
!!                OrbI=OrbJ
!!                OrbJ=t
!!            ELSEIF(OrbI.eq.OrbJ) THEN
!!                CALL Stop_All("AddProjMP2Energy","Cannot have I.eq.J")
!!            ENDIF
!!            IF(OrbA.lt.OrbB) THEN
!!                t=OrbA
!!                OrbA=OrbB
!!                OrbB=t
!!            ELSEIF(OrbA.eq.OrbB) THEN
!!                CALL Stop_All("AddProjMP2Energy","Cannot have A.eq.B")
!!            ENDIF
!!            IF(OrbI.ge.OrbB) CALL Stop_All("AddProjMP2Energy","Indexing scheme incorrect")
!!            IF((OrbI.gt.NEl).or.(OrbJ.gt.NEl)) CALL Stop_All("AddProjMP2Energy","Indexing scheme incorrect")
!!            IF((OrbA.gt.nBasis).or.(OrbB.gt.nBasis)) CALL Stop_All("AddProjMP2Energy","Indexing scheme incorrect")
!!            IF((OrbA.le.NEl).or.(OrbB.le.NEl)) CALL Stop_All("AddProjMP2Energy","Indexing scheme incorrect")
!!
!!            OrbA=OrbA-NEl     !Virtual orbital indexing cannot be > NEl, so remove to save space.
!!            OrbB=OrbB-NEl
!!
!!            SumOverlapMP2=SumOverlapMP2+MP2ExcitComps(OrbI,OrbJ,OrbA,OrbB)    !Add component of MP1 Wavefunction
!
!            IF(WSign) THEN
!                Hjj=CurrentH(1,j)
!            ELSE
!                Hjj=-CurrentH(1,j)
!            ENDIF
!            SumHOverlapMP2=SumHOverlapMP2+(MP1Compt*Hjj)
!
!        ELSEIF(ExcitLevel.eq.0) THEN
!!HF MP2 wavefunction component is simply 1 since wavefunction is unnormalised.
!
!            IF(WSign) THEN
!                SumOverlapMP2=SumOverlapMP2+1.D0
!                SumHOverlapMP2=SumHOverlapMP2+Hii
!            ELSE
!                SumOverlapMP2=SumOverlapMP2-1.D0
!                SumHOverlapMP2=SumHOverlapMP2-Hii
!            ENDIF
!
!        ENDIF
!
!!Now, for the more difficult task of finding the overlap of H|Psi> with the MP1 wavefunction
!        IF(ExcitLevel.le.4) THEN
!!Any walker which is at a quadruple or less excitation level will have excitations which overlap with MP1.
!!Setup excit generators for this determinant if needed
!
!            IF(TRegenExcitgens) THEN
!                CALL SetupExitgen(DetCurr,TempExcitgen)
!            ELSE
!                CALL SetupExitgen(DetCurr,CurrentExcits(j))
!                CALL ResetExit2(DetCurr,NEl,G1,nBasis,nBasisMax,CurrentExcits(j)%ExcitData,0) !Reset excitgen
!            ENDIF
!
!            do while(.true.)
!!Run through all excitations - nStore has nothing in it (hopefully not needed)
!                IF(TRegenExcitgens) THEN
!                    CALL GenSymExcitIt2(DetCurr,NEl,G1,nBasis,nBasisMax,.false.,TempExcitgen%ExcitData,nJ,iExcit,0,nStore,3)
!                ELSE
!                    CALL GenSymExcitIt2(DetCurr,NEl,G1,nBasis,nBasisMax,.false.,CurrentExcits(j)%ExcitData,nJ,iExcit,0,nStore,3)
!                ENDIF
!                IF(nJ(1).eq.0) exit
!                nJ_IC=iGetExcitLevel_2(HFDet,nJ,NEl,2)  !Find out if excitation is a double
!
!                IF(nJ_IC.eq.2) THEN
!!Excitation is less than or equal to a double - find connection to original walker
!                    Hijtemp = get_helement (DetCurr, nJ, 2)
!                    IF(WSign) THEN
!                        Hij=REAL(Hijtemp,dp)
!                    ELSE
!                        Hij=-REAL(Hijtemp,dp)
!                    ENDIF
!!Find MP1 excitation compt
!                    TempFjj=GetH0Element3(nJ)
!                    Hij2temp = get_helement (HFDet, nJ, nJ_IC)
!                    MP1Compt=-(REAL(Hij2temp,dp))/(Fii-(REAL(TempFjj,dp)))
!                    SumHOverlapMP2=SumHOverlapMP2+(MP1Compt*Hij)
!
!!...and then find overlap of this excitation with the MP1 wavefunction
!!                    ExcitForm(1,1)=nJ_IC
!!                    CALL GetExcitation(HFDet,nJ,NEl,ExcitForm,tSign)
!!!The i,j orbitals are ExcitForm(1,1) and (1,2). a/b are (2,1) and (2,2)
!!!Find the ordering of the orbitals in terms of energy
!!                    OrbI=INVBRRSpinOrb(ExcitForm(1,1))
!!                    OrbJ=INVBRRSpinOrb(ExcitForm(1,2))
!!                    OrbA=INVBRRSpinOrb(ExcitForm(2,1))
!!                    OrbB=INVBRRSpinOrb(ExcitForm(2,2))
!!
!!!Ensure i > j and a > b.
!!                    IF(OrbI.lt.OrbJ) THEN
!!                        t=OrbI
!!                        OrbI=OrbJ
!!                        OrbJ=t
!!                    ELSEIF(OrbI.eq.OrbJ) THEN
!!                        CALL Stop_All("AddProjMP2Energy","Cannot have I.eq.J")
!!                    ENDIF
!!                    IF(OrbA.lt.OrbB) THEN
!!                        t=OrbA
!!                        OrbA=OrbB
!!                        OrbB=t
!!                    ELSEIF(OrbA.eq.OrbB) THEN
!!                        CALL Stop_All("AddProjMP2Energy","Cannot have A.eq.B")
!!                    ENDIF
!!                    IF(OrbI.ge.OrbB) CALL Stop_All("AddProjMP2Energy","Indexing scheme incorrect")
!!                    IF((OrbI.gt.NEl).or.(OrbJ.gt.NEl)) CALL Stop_All("AddProjMP2Energy","Indexing scheme incorrect")
!!                    IF((OrbA.gt.nBasis).or.(OrbB.gt.nBasis)) CALL Stop_All("AddProjMP2Energy","Indexing scheme incorrect")
!!                    IF((OrbA.le.NEl).or.(OrbB.le.NEl)) CALL Stop_All("AddProjMP2Energy","Indexing scheme incorrect")
!!
!!                    OrbA=OrbA-NEl     !Virtual orbital indexing cannot be > NEl, so remove to save space.
!!                    OrbB=OrbB-NEl
!!
!!!Add <MP1|H|Psi>
!!                    SumHOverlapMP2=SumHOverlapMP2+(MP2ExcitComps(OrbI,OrbJ,OrbA,OrbB)*(real(Hijtemp,dp)))
!
!                ELSEIF(nJ_IC.eq.0) THEN
!!Excitation is the HF determinant - find connection to it
!
!                    Hijtemp = get_helement (DetCurr, nJ, 0)
!                    IF(WSign) THEN
!                        Hij=REAL(Hijtemp,dp)
!                    ELSE
!                        Hij=-REAL(Hijtemp,dp)
!                    ENDIF
!
!                    SumHOverlapMP2=SumHOverlapMP2+Hij
!
!                ENDIF
!
!            enddo
!
!            IF(.not.TRegenExcitgens) CALL ResetExit2(DetCurr,NEl,G1,nBasis,nBasisMax,CurrentExcits(j)%ExcitData,0) !Reset excitgen
!
!        ENDIF
!
!    END SUBROUTINE AddProjMP2Energy
!

!This routine acts as a thermostat for the simulation - killing random particles if the population becomes too large, or
!Doubling them if it gets too low...
    SUBROUTINE ThermostatParticles(HighLow)
        IMPLICIT NONE
        LOGICAL :: HighLow
        INTEGER :: VecSlot,i,ToCull,Culled,OrigWalkers,Chosen
        REAL*8 :: Ran2

        IF(HighLow) THEN
!The population is too large - cull TotWalkers/CullFactor randomly selected particles

            OrigWalkers=TotWalkers
            ToCull=TotWalkers-nint((TotWalkers+0.D0)/CullFactor)
            Culled=0

            do while (Culled.lt.ToCull)

!Pick a random walker between 1 and TotWalkers
                Chosen=int((Ran2(Seed)*TotWalkers)+1.D0)

                IF(CurrentSign(Chosen)) THEN
!Walker that is removed is positive - therefore totsign is one less than it was before
                    TotSign=TotSign-1
                ELSE
                    TotSign=TotSign+1
                ENDIF

!Move the Walker at the end of the list to the position of the walker we have chosen to destroy
                CurrentDets(:,Chosen)=CurrentDets(:,TotWalkers)
                CurrentSign(Chosen)=CurrentSign(TotWalkers)
                CurrentH(:,Chosen)=CurrentH(:,TotWalkers)
                CurrentIC(Chosen)=CurrentIC(TotWalkers)
                IF(TUnbiasPGeninProjE) CurrentPGen(Chosen)=CurrentPGen(TotWalkers)
                IF(.not.TRegenExcitgens) THEN
                    CALL CopyExitgen(CurrentExcits(TotWalkers),CurrentExcits(Chosen))
                    CurrentExcits(TotWalkers)%ExcitGenForDet=.false.
                ENDIF

                TotWalkers=TotWalkers-1
                Culled=Culled+1

            enddo

            IF(TotWalkers.ne.(OrigWalkers-ToCull)) THEN
                WRITE(6,*) "Error in culling walkers..."
                STOP "Error in culling walkers..."
            ENDIF

            IF(TSignShift) THEN
!CullInfo(:,2) is the new number of total walkers/residualsign
                CullInfo(NoCulls,2)=TotSign
            ELSE
                CullInfo(NoCulls,2)=TotWalkers
            ENDIF

        ELSE
!The population is too low - give it a boost by doubling every particle

            VecSlot=TotWalkers+1
            do i=1,TotWalkers

                IF(CurrentSign(Chosen)) THEN
!Walker that is doubled is positive - therefore totsign is one more than it was before
                    TotSign=TotSign+1
                ELSE
                    TotSign=TotSign-1
                ENDIF

!Add clone of walker, at the same determinant, to the end of the list
                CurrentDets(:,VecSlot)=CurrentDets(:,i)
                CurrentSign(VecSlot)=CurrentSign(i)
                CurrentH(:,VecSlot)=CurrentH(:,i)
                CurrentIC(VecSlot)=CurrentIC(i)
                IF(TUnbiasPGeninProjE) CurrentPGen(VecSlot)=CurrentPGen(i)
                IF(.not.TRegenExcitgens) CALL CopyExitgen(CurrentExcits(i),CurrentExcits(VecSlot))

                VecSlot=VecSlot+1

            enddo

            TotWalkers=TotWalkers*2

            IF((VecSlot-1).ne.TotWalkers) THEN
                WRITE(6,*) "Problem in doubling all particles..."
                STOP "Problem in doubling all particles..."
            ENDIF

            IF(TSignShift) THEN
!CullInfo(:,2) is the new number of total walkers/residualsign
                CullInfo(NoCulls,2)=TotSign
            ELSE
                CullInfo(NoCulls,2)=TotWalkers
            ENDIF

        ENDIF

        RETURN

    END SUBROUTINE ThermostatParticles

!!This routine will assign a probability to annihilate pairs of particles which are connected
!!Walkers are initially distributed on New..., but want to end up on Current...
!!Problem - are walkers more likely to be annihilated if they are at the beginning of the list?
!    SUBROUTINE AnnihilAtDistance(TotWalkersNew)
!        INTEGER :: TotWalkersNew,iGetExcitLevel_2,VecSlot,i,j,WalkerScale
!        INTEGER , ALLOCATABLE :: KillArrayOnSite(:),KillArrayAtDist(:)
!        INTEGER :: ierr,Connection,DetCurr(NEl),InteractionResult
!        HElement_t :: Hij
!        REAL*8 :: ConnStrength
!        LOGICAL :: WSign
!
!!Allocate Kill array - this will mark walkers which are annihilated as .true.
!        ALLOCATE(KillArrayOnSite(TotWalkersNew),stat=ierr)
!        ALLOCATE(KillArrayAtDist(TotWalkersNew),stat=ierr)
!        KillArrayOnSite(:)=1
!        KillArrayAtDist(:)=0
!
!!Run through all walkers if not already annihilated
!        do i=1,(TotWalkersNew-1)
!!        do i=1,TotWalkersNew
!
!!            IF(KillArray(i).eq.0) CYCLE  !Skip this walker if it has been annihilated in a previous iteration
!            DetCurr(:)=NewDets(:,i)
!            WSign=NewSign(i)
!
!!Run through rest of walkers on the list
!            do j=(i+1),TotWalkersNew
!!            do j=1,TotWalkersNew
!
!!Test walker has already been annihilated in previous cycle
!!                IF(KillArray(j).eq.0) CYCLE
!
!!See if walkers are connected (We only need to know if they are doubles or more...
!                Connection=iGetExcitLevel_2(DetCurr(:),NewDets(:,j),NEl,2)
!
!                IF(Connection.eq.0) THEN
!                    IF((KillArrayOnSite(i).eq.0).or.(KillArrayOnSite(j).eq.0)) CYCLE
!!If they are the same determinant, then we need to see if the overlap is negative or positive to test annihilation
!
!                    IF(WSign) THEN
!                        IF(.not.NewSign(j)) THEN
!!Walkers are different sign - annihilate them with prob = 1
!                            KillArrayOnSite(i)=KillArrayOnSite(i)-1
!                            KillArrayOnSite(j)=KillArrayOnSite(j)-1
!!                            IF(KillArray(j).eq.0) EXIT    !Exit from the loop - walker i can no longer annihilate
!                        ENDIF
!                    ELSE
!                        IF(NewSign(j)) THEN
!!Walkers are different sign - annihilate them with prob = 1
!                            KillArrayOnSite(i)=KillArrayOnSite(i)-1
!                            KillArrayOnSite(j)=KillArrayOnSite(j)-1
!!                            IF(KillArray(j).eq.0) EXIT    !Exit from the loop - walker i can no longer annihilate
!                        ENDIF
!                    ENDIF
!
!                ELSEIF(Connection.le.2) THEN
!!Walkers i and j are connected, but not at the same determinant - first calculate connection strength
!
!                    Hij = get_helement (DetCurr, NewDets(:,j), Connection)
!                    InteractionResult=AttemptAnnihilatDist(Hij,WSign,NewSign(j))
!
!                    IF(InteractionResult.eq.-1) THEN
!!Particles want to be annihilated at a distinct determinants
!                        ConnAnnihil=ConnAnnihil+2   !Update the counter counting the annihilation of connected walkers
!                        KillArrayAtDist(i)=KillArrayAtDist(i)-1
!                        KillArrayAtDist(j)=KillArrayAtDist(j)-1
!                    ELSEIF(InteractionResult.eq.1) THEN
!!We have decided we want to double both particles
!                        ConnAnnihil=ConnAnnihil-2   !We are creating particles, so reduce ConnAnnihil
!                        KillArrayAtDist(i)=KillArrayAtDist(i)+1
!                        KillArrayAtDist(j)=KillArrayAtDist(j)+1
!
!                    ENDIF
!                ENDIF
!
!            enddo
!
!        enddo
!
!!Now we need to run through the array one final time to transfer the walkers across which are still alive
!        VecSlot=1
!        do i=1,TotWalkersNew
!
!            IF(VecSlot.gt.MaxWalkers) THEN
!                WRITE(6,*) VecSlot,i,ConnAnnihil
!                CALL Stop_All("AnnihilatDistance","Number of particles has grown to greater than MaxWalkers")
!            ENDIF
!            WalkerScale=KillArrayOnSite(i)+KillArrayAtDist(i)
!
!            do j=1,abs(WalkerScale)
!!Walker is still alive (possibly actually more)- transfer it/them
!                CurrentDets(:,VecSlot)=NewDets(:,i)
!                IF(WalkerScale.gt.0) THEN
!                    CurrentSign(VecSlot)=NewSign(i)
!                ELSE
!!Flip sign if we have changed the sign through annihilation...
!                    CurrentSign(VecSlot)=.not.NewSign(i)
!                ENDIF
!                CurrentIC(VecSlot)=NewIC(i)
!                CurrentH(:,VecSlot)=NewH(:,i)
!                IF(TUnbiasPGeninProjE) CurrentPGen(VecSlot)=NewPGen(i)
!                IF(.not.TRegenExcitgens) CALL CopyExitgen(NewExcits(i),CurrentExcits(VecSlot))
!                VecSlot=VecSlot+1
!            enddo
!
!        enddo
!
!        TotWalkers=VecSlot-1
!
!!Deallocate KillArray
!        DEALLOCATE(KillArrayAtDist)
!        DEALLOCATE(KillArrayOnSite)
!
!        RETURN
!
!    END SUBROUTINE AnnihilatDistance
!
!!This function will attempt to annihilate two pre-chosen particles at different sites
!!0 means that nothing should be done.
!!1 means that the particles should be doubled
!!-1 means that the particles should be annihilated
!    INTEGER FUNCTION AttemptAnnihilatDist(Hij,WiSign,WjSign)
!        HElement_t :: Hij
!        REAL*8 :: ConnStrength,Ran2
!        LOGICAL :: WiSign,WjSign,AttemptAnn
!
!        AttemptAnn=.false.
!        ConnStrength=REAL(Hij,dp)*Lambda
!        IF(ConnStrength.lt.0.D0) THEN
!!Particles have a chance of annihilation if they are of opposite sign
!            IF(WiSign) THEN
!                IF(.not.WjSign) THEN
!                    AttemptAnn=.true.
!                ENDIF
!            ELSE
!                IF(WjSign) THEN
!                    AttemptAnn=.true.
!                ENDIF
!            ENDIF
!        ELSE
!!Particles have a chance of annihilation if they are of same sign
!            IF(WiSign) THEN
!                IF(WjSign) THEN
!                    AttemptAnn=.true.
!                ENDIF
!            ELSE
!                IF(.not.WjSign) THEN
!                    AttemptAnn=.true.
!                ENDIF
!            ENDIF
!        ENDIF
!        ConnStrength=ABS(ConnStrength)
!        IF(ConnStrength.gt.1.D0) WRITE(6,*) "Warning - Annihilation/Reinforcing probability > 1",REAL(Hij,dp)
!
!        IF(Ran2(Seed).gt.ConnStrength) THEN
!            AttemptAnnihilatDist=0
!        ELSE
!!We have succeeded in annihilating/reinforcing - which one?
!            IF(AttemptAnn) THEN
!!Annihilate with probability = ConnStrength
!                AttemptAnnihilatDist=-1
!            ELSE
!!Reinforce with probability = ConnStrength
!                AttemptAnnihilatDist=1
!            ENDIF
!        ENDIF
!
!        RETURN
!
!    END FUNCTION AttemptAnnihilatDist

!This routine cancels out particles of opposing sign on the same determinant.
    SUBROUTINE AnnihilatePairs(TotWalkersNew)
        TYPE(ExcitGenerator) :: TempExcit
        REAL*8 :: TempH(2),TempPGen
        INTEGER :: TempIC
        INTEGER :: TotWalkersNew,j,l,DetCurr(NEl),VecSlot,TotWalkersDet
        INTEGER :: DetLT

        call excitgenerator_init(tempexcit)

!First, it is necessary to sort the list of determinants
        temppgen = 0
        if (tUnbiasPGenInProjE) then
            if (tRegenExcitgens) then
                call sort (NewDets(:,1:TotWalkersNew), &
                           newH(:,1:TotWalkersNew), &
                           newIC(1:TotWalkersNew), &
                           newSign(1:TotWalkersNew), &
                           newPGen(1:TotWalkersNew))
            else
                call sort (NewDets(:,1:TotWalkersNew), &
                           newH(:,1:TotWalkersNew), &
                           newIC(1:TotWalkersNew), &
                           newSign(1:TotWalkersNew), &
                           newPGen(1:TotWalkersNew), &
                           newExcits(1:TotWalkersNew))
            endif
        else
            if (tRegenExcitgens) then
                call sort (NewDets(:,1:TotWalkersNew), &
                           newH(:,1:TotWalkersNew), &
                           newIC(1:TotWalkersNew), &
                           newSign(1:TotWalkersNew))
            else
                call sort (NewDets(:,1:TotWalkersNew), &
                           newH(:,1:TotWalkersNew), &
                           newIC(1:TotWalkersNew), &
                           newSign(1:TotWalkersNew), &
                           newExcits(1:totWalkersNew))
            endif
        endif

!Once ordered, each block of walkers on similar determinants can be analysed, and the residual walker concentration moved to CurrentDets
        j=1
!j is the counter over all uncancelled walkers - it indicates when we have reached the end of the list of total walkers
!DetCurr is the current determinant
        DetCurr(:)=NewDets(:,j)
!        CALL NECI_ICOPY(NEl,NewDets(:,j),1,DetCurr(:),1)
        TempIC=NewIC(j)
        TempH(:)=NewH(:,j)
        IF(TUnbiasPGeninProjE) TempPGen=NewPGen(j)
        IF(.not.TRegenExcitgens) CALL CopyExitGen(NewExcits(j),TempExcit)

        VecSlot=1

        do while(j.le.TotWalkersNew)
!Loop over all walkers
            TotWalkersDet=0
            do while ((DetLT(NewDets(:,j),DetCurr,NEl).eq.0).and.(j.le.TotWalkersNew))
!Loop over all walkers on DetCurr and count residual number after cancelling
                IF(NewSign(j)) THEN
                    TotWalkersDet=TotWalkersDet+1
                ELSE
                    TotWalkersDet=TotWalkersDet-1
                ENDIF
                j=j+1
            enddo
!Transfer residual population into VecSlot, along with residual sign
            IF(TotWalkersDet.gt.0) THEN
!Positive sign particles want to populate this determinant
                do l=1,abs(TotWalkersDet)
!                    CALL NECI_ICOPY(NEl,DetCurr(:),1,CurrentDets(:,VecSlot),1)
                    CurrentDets(:,VecSlot)=DetCurr(:)
                    CurrentSign(VecSlot)=.true.
                    CurrentIC(VecSlot)=TempIC
                    CurrentH(:,VecSlot)=TempH(:)
                    IF(TUnbiasPGeninProjE) CurrentPGen(VecSlot)=TempPGen
                    IF(.not.TRegenExcitgens) CALL CopyExitgen(TempExcit,CurrentExcits(VecSlot))
                    VecSlot=VecSlot+1
                enddo
            ELSE
!Negative sign particles want to populate this determinant
                do l=1,abs(TotWalkersDet)
!                    CALL NECI_ICOPY(NEl,DetCurr(:),1,CurrentDets(:,VecSlot),1)
                    CurrentDets(:,VecSlot)=DetCurr(:)
                    CurrentSign(VecSlot)=.false.
                    CurrentIC(VecSlot)=TempIC
                    CurrentH(:,VecSlot)=TempH(:)
                    IF(TUnbiasPGeninProjE) CurrentPGen(VecSlot)=TempPGen
                    IF(.not.TRegenExcitgens) CALL CopyExitgen(TempExcit,CurrentExcits(VecSlot))
                    VecSlot=VecSlot+1
                enddo
            ENDIF
!Now update the current determinant
!            CALL NECI_ICOPY(NEl,NewDets(:,j),1,DetCurr(:),1)
            DetCurr(:)=NewDets(:,j)
            TempIC=NewIC(j)
            TempH(:)=NewH(:,j)
            IF(TUnbiasPGeninProjE) TempPGen=NewPGen(j)
            IF(.not.TRegenExcitgens) CALL CopyExitGen(NewExcits(j),TempExcit)
        enddo
!The new number of residual cancelled walkers is given by one less that VecSlot again.
        TotWalkers=VecSlot-1

        call excitgenerator_destroy(tempexcit)

    END SUBROUTINE AnnihilatePairs


!This initialises the calculation, by allocating memory, setting up the initial walkers, and reading from a file if needed
    SUBROUTINE InitFCIMCCalc()
        use CalcData, only : EXCITFUNCS
        use HElem
        use util_mod, only: get_free_unit
        INTEGER :: ierr,i,j
        INTEGER :: HFConn
        INTEGER*8 :: MemoryAlloc
        REAL*8 :: Ran2
        HElement_t :: TempHii
        CHARACTER(len=*), PARAMETER :: this_routine='InitFCIMC'

        IF(HElement_t_size.gt.1) THEN
            CALL Stop_All("FCIMCPar","FciMCPar cannot function with complex orbitals.")
        ENDIF

!Open a file to store output
        fcimcstats_unit = get_free_unit()
        if (tReadPops) then
            ! Restarting: append to FCIMCStats (if it exists)
            OPEN(fcimcstats_unit,file='FCIMCStats',status='unknown', position='append')
        else
            OPEN(fcimcstats_unit,file='FCIMCStats',status='unknown')
        end if

        ALLOCATE(HFDet(NEl),stat=ierr)
        CALL LogMemAlloc('HFDet',NEl,4,this_routine,HFDetTag)
        do i=1,NEl
            HFDet(i)=FDet(i)
        enddo

!Setup excitation generator for the HF determinant
        CALL SetupExitgen(HFDet,HFExcit)
        CALL GetSymExcitCount(HFExcit%ExcitData,HFConn)

!Initialise random number seed - since the seeds need to be different on different processors, subract processor rank from random number
        Seed=G_VMC_Seed

!Calculate Hii
        TempHii = get_helement (HFDet, HFDet, 0)
        Hii=REAL(TempHii,dp)          !Diagonal Hamiltonian element for the HF determinant

        TempHii=GetH0Element3(HFDet)
        Fii=REAL(TempHii,dp)          !Fock-energy of the HF determinant

        IF(TPopsFile.and.(mod(iWritePopsEvery,StepsSft).ne.0)) THEN
            CALL Warning("InitFCIMCCalc","POPSFILE writeout should be a multiple of the update cycle length.")
        ENDIF

!Initialise variables for calculation on each node
        ProjectionE=0.D0
        ProjectionMP2=0.D0
        AvSign=0.D0
        SumENum=0.D0
        SumNoatHF=0.D0
        NoatHF=0
        SumOverlapMP2=0.D0
        SumHOverlapMP2=0.D0
        MeanExcitLevel=0.D0
        MinExcitLevel=NEl+10
        MaxExcitLevel=0
        NoatDoubs=0
        Acceptances=0
        Annihilated=0
        ConnAnnihil=0
        AccRat=0.D0
        PreviousCycles=0
        SumConnections=0.D0
        NoDied=0
        NoBorn=0

        IF(TStartSinglePart) THEN
            TSinglePartPhase=.true.
            IF(TReadPops) THEN
                CALL WARNING("InitFciMCCalc","Cannot read in POPSFILE as well as starting with a " &
                & //"single particle: ignoring StartSinglePart.")
                tSinglePartPhase = .false.
                tStartSinglePart = .false.
            ENDIF
            IF(TStartMP1) THEN
                CALL Stop_All("InitFciMCCalc","Cannot start with a single particle and be at the MP1 wavefunction")
            ENDIF
        ELSE
            TSinglePartPhase=.false.
        ENDIF

        IF(TNoAnnihil) THEN
            WRITE(6,*) "No Annihilation to occur. Results are likely not to converge to right value. Proceed with caution."
        ENDIF

        WRITE(6,*) ""
        WRITE(6,*) "Performing FCIMC..."
        WRITE(6,*) "Maximum connectivity of HF determinant is: ",HFConn

        IF(ICILevel.ne.0) THEN
            IF(TUnbiasPGeninProjE) THEN
                CALL Stop_All("InitFCIMCCalc","UnbiasPGeninProjE does not currently work in truncated spaces")
            ENDIF
            WRITE(6,*) "Excitation levels w.r.t. HF restricted to level: ",ICILevel
            WRITE(6,*) "!!!  WARNING !!!"
            WRITE(6,*) "!!! Average connecting hamiltonian matrix element data will not be correct for truncated spaces!"
        ENDIF
        IF(TUnbiasPGeninProjE) THEN
            WRITE(6,*) "Acceptance probability will not be unbiased for generation probability. Instead, walker " &
            & //"contributions to the projected energy will be the unbiasing stage..."
            WRITE(6,*) "WARNING - THIS IS AN EXPERIMENTAL OPTION!"
        ENDIF

        IF(TStartMP1) THEN
!Start the initial distribution off at the distribution of the MP1 eigenvector
            CALL Stop_All("InitFciMCCalc","STARTMP1 option is depreciated except when using CCMC.")

            IF(TUnbiasPGeninProjE) CALL Stop_All("InitFciMCCalc","Cannot use option UnbiasPGeninProjE with StartMP1")

            WRITE(6,"(A)") "Starting run with particles populating double excitations proportionally to MP1 wavevector..."
            CALL InitWalkersMP1()

        ELSEIF(TReadPops) THEN
!We are reading in an initial distribution of walkers

            IF(TUnbiasPGeninProjE) CALL Stop_All("InitFciMCCalc","Cannot use option UnbiasPGeninProjE with READPOPS")

            WRITE(6,*) "Reading in initial particle configuration from POPSFILE..."
            CALL ReadFromPopsFile()

        ELSE

!initialise the particle positions - start at HF with positive sign

!Set the maximum number of walkers allowed
            MaxWalkers=NINT(MemoryFacPart*InitWalkers)

            IF(TStartSinglePart) THEN
                WRITE(6,"(A,F9.3,A,I9)") "Initial number of particles set to 1, and shift will be held at ",DiagSft, &
                &   " until particle number gets to ",InitWalkers
            ELSE
                WRITE(6,*) "Initial number of walkers chosen to be: ", InitWalkers
            ENDIF
            WRITE(6,*) "Damping parameter for Diag Shift set to: ", SftDamp
            WRITE(6,*) "Initial Diagonal Shift (Ecorr guess) is: ", DiagSft
            WRITE(6,*) "Maximum storage capability of walkers is: ", MaxWalkers

!Allocate memory to hold walkers
            ALLOCATE(WalkVecDets(NEl,MaxWalkers),stat=ierr)
            CALL LogMemAlloc('WalkVecDets',MaxWalkers*NEl,4,this_routine,WalkVecDetsTag,ierr)
            WalkVecDets(1:NEl,1:MaxWalkers)=0
            ALLOCATE(WalkVec2Dets(NEl,MaxWalkers),stat=ierr)
            CALL LogMemAlloc('WalkVec2Dets',MaxWalkers*NEl,4,this_routine,WalkVec2DetsTag,ierr)
            WalkVec2Dets(1:NEl,1:MaxWalkers)=0
            ALLOCATE(WalkVecSign(MaxWalkers),stat=ierr)
            CALL LogMemAlloc('WalkVecSign',MaxWalkers,4,this_routine,WalkVecSignTag,ierr)
            ALLOCATE(WalkVec2Sign(MaxWalkers),stat=ierr)
            CALL LogMemAlloc('WalkVec2Sign',MaxWalkers,4,this_routine,WalkVec2SignTag,ierr)

            ALLOCATE(WalkVecIC(MaxWalkers),stat=ierr)
            CALL LogMemAlloc('WalkVecIC',MaxWalkers,4,this_routine,WalkVecICTag,ierr)
            ALLOCATE(WalkVec2IC(MaxWalkers),stat=ierr)
            CALL LogMemAlloc('WalkVec2IC',MaxWalkers,4,this_routine,WalkVec2ICTag,ierr)
            ALLOCATE(WalkVecH(2,MaxWalkers),stat=ierr)
            CALL LogMemAlloc('WalkVecH',MaxWalkers*2,8,this_routine,WalkVecHTag,ierr)
            WalkVecH=0.d0
            ALLOCATE(WalkVec2H(2,MaxWalkers),stat=ierr)
            CALL LogMemAlloc('WalkVec2H',MaxWalkers*2,8,this_routine,WalkVec2HTag,ierr)
            WalkVec2H=0.d0

            IF(TUnbiasPGeninProjE) THEN
                ALLOCATE(WalkVecPGen(MaxWalkers),stat=ierr)
                CALL LogMemAlloc('WalkVecPGen',MaxWalkers,8,this_routine,WalkVecPGenTag,ierr)
                WalkVecPgen=0.d0
                ALLOCATE(WalkVec2PGen(MaxWalkers),stat=ierr)
                CALL LogMemAlloc('WalkVec2PGen',MaxWalkers,8,this_routine,WalkVec2PGenTag,ierr)
                WalkVec2PGen=0.d0
                MemoryAlloc=((2*NEl)+16)*4*MaxWalkers

                CurrentPGen=>WalkVecPGen
                NewPGen=>WalkVec2PGen

            ELSE
                MemoryAlloc=((2*NEl)+12)*4*MaxWalkers
            ENDIF


!Allocate pointers to the correct walker arrays
            CurrentDets=>WalkVecDets
            CurrentSign=>WalkVecSign
            CurrentIC=>WalkVecIC
            CurrentH=>WalkVecH
            NewDets=>WalkVec2Dets
            NewSign=>WalkVec2Sign
            NewIC=>WalkVec2IC
            NewH=>WalkVec2H

            IF(TStartSinglePart) THEN
                CurrentDets(:,1)=HFDet(:)
                CurrentIC(1)=0
                CurrentSign(1)=.true.
                CurrentH(:,1)=0.D0
                IF(TUnbiasPGeninProjE) THEN
                    CurrentPGen(1)=1.D0
                ENDIF
            ELSE
                do j=1,InitWalkers
                    CurrentDets(:,j)=HFDet(:)
                    CurrentIC(j)=0
                    CurrentH(:,j)=0.D0
                    IF(TFixParticleSign) THEN
                        IF(Ran2(Seed).lt.0.40) THEN
                            CurrentSign(j)=.false.
                        ELSE
                            CurrentSign(j)=.true.
                        ENDIF
                    ELSE
                        CurrentSign(j)=.true.
                    ENDIF

                    IF(TUnbiasPGeninProjE) THEN
                        CurrentPGen(j)=1.D0
                    ENDIF
                enddo
            ENDIF

            WRITE(6,"(A,F14.6,A)") "Initial memory (without excitgens) consists of : ",REAL(MemoryAlloc,dp)/1048576.D0," Mb"
            WRITE(6,*) "Initial memory allocation sucessful..."
            CALL FLUSH(6)

            IF(.not.TRegenExcitgens) THEN
                ASSERT(.not. allocated(WalkVecExcits))
                ASSERT(.not. allocated(WalkVec2Excits))

                ALLOCATE(WalkVecExcits(MaxWalkers),stat=ierr)
                IF(ierr.ne.0) CALL Stop_All("InitFCIMCCalc","Error in allocating walker excitation generators")
                ALLOCATE(WalkVec2Excits(MaxWalkers),stat=ierr)
                IF(ierr.ne.0) CALL Stop_All("InitFCIMCCalc","Error in allocating walker excitation generators")

                do i = 1, MaxWalkers
                    call excitgenerator_init(WalkVecExcits(i))
                    call excitgenerator_init(WalkVec2Excits(i))
                enddo

!Allocate pointers to the correct excitation arrays
                CurrentExcits=>WalkVecExcits
                NewExcits=>WalkVec2Excits
            ENDIF


            IF(.not.TRegenExcitgens) THEN
                IF(TStartSinglePart) THEN
                    CALL CopyExitGen(HFExcit,CurrentExcits(1))
                ELSE
                    do j=1,InitWalkers
    !Copy the HF excitation generator accross to each initial particle
                        CALL CopyExitGen(HFExcit,CurrentExcits(j))
                    enddo
                ENDIF
                MemoryAlloc=((INT(HFExcit%nExcitMemLen,8))+2)*4*INT(MaxWalkers,8)
                WRITE(6,"(A,F14.6,A)") "Probable maximum memory for excitgens is : ",REAL(MemoryAlloc,dp)/1048576.D0," Mb"
                WRITE(6,*) "Initial allocation of excitation generators successful..."
                CALL FLUSH(6)
            ELSE
                WRITE(6,*) "Excitation generators not being stored..."
            ENDIF


        ENDIF

        IF(THFRetBias) THEN
            IF((PRet.gt.1.D0).or.(PRet.lt.0.D0)) THEN
                CALL Stop_All("InitFciMCCalc","HFRetBias set, but return bias is not a normalised probability")
            ELSE
                WRITE(6,*) "Return bias to HF determinant set, with PRet = ", PRet
            ENDIF
        ENDIF

        IF(TStartSinglePart) THEN
            TotWalkers=1
            TotWalkersOld=1
            TotSign=1
            TotSignOld=1
        ELSE
!TotWalkers contains the number of current walkers at each step
            TotWalkers=InitWalkers
            TotSign=InitWalkers
            TotWalkersOld=InitWalkers
            TotSignOld=InitWalkers
        ENDIF
!TotSign is the sum of the walkers x sign
        ProjectionE=SumENum/SumNoatHF

        CullInfo=0
        NoCulls=0

!Routine to initialise the blocking analysis
        CALL InitBlocking()

        IF(TProjEMP2) THEN
!This will perform an MP2 calculation, so that the projection to it can be used to calculate the energy
            CALL InitMP2Calc()
        ENDIF

        IF(TWriteDetE) THEN
!If this logging option is on, then we want to write out the energies of the determinants
            WRITE(6,"(A,I6,A,F10.2)") "Histogramming determinant energies by excitation level in ",NoHistBins, &
            &   " bins, with a maximum energy of ",MaxHistE

            ALLOCATE(EHistBins(NEl,NoHistBins),stat=ierr)
            CALL LogMemAlloc('EHistBins',NoHistBins*NEl,8,this_routine,EHistBinsTag)
!            EHistBins(1:nEl,1:NoHistBins)=0
            do i=1,NoHistBins
                do j=1,NEl
                    EHistBins(j,i)=0
                enddo
            enddo


        ENDIF


        RETURN

    END SUBROUTINE InitFCIMCCalc

!This routine writes out the histogram of the determinants energies
    SUBROUTINE WriteEnergyHist()
        use util_mod, only: get_free_unit
        INTEGER :: i,j, iunit
        REAL*8 :: LowEnergyofbin,HighEnergyofbin,MeanEnergyofbin
!        CHARACTER(len=16) :: FormatSpec

!        FormatSpec=''
!        write(FormatSpec,'(I2)') NEl
!        FormatSpec="'(F20.10,"//adjustl(FormatSpec)
!        FormatSpec=trim(FormatSpec) // "I15)'"
!        FormatSpec=trim(FormatSpec)
!        FormatSpec=adjustl(FormatSpec)
!        WRITE(6,*) FormatSpec
!        CALL FLUSH(6)

        iunit = get_free_unit()
        OPEN(iunit,file='HISTEXCITS',Status='unknown')

        WRITE(iunit,*) "# Determinant_energy_bin     Number from each excitation level..."

        do j=1,NoHistBins
            LowEnergyofbin=(j-1)*MaxHistE/real(NoHistBins,dp)
            HighEnergyofbin=j*MaxHistE/real(NoHistBins,dp)
            MeanEnergyofbin=(LowEnergyofbin+HighEnergyofbin)/2.D0
            WRITE(iunit,'(F20.10,I15)',advance='no') MeanEnergyofbin,EHistBins(1,j)
            do i=2,NEl-1
                WRITE(iunit,'(I15)',advance='no') EHistBins(i,j)
            enddo
            WRITE(iunit,'(I15)') EHistBins(NEl,j)
        enddo

        CLOSE(iunit)

        RETURN

    END SUBROUTINE WriteEnergyHist

!This routine allocates memory for the initial walkers, and then assigns them stochastically, proportional to the MP1 wavefunction
    SUBROUTINE InitWalkersMP1()
        INTEGER :: HFConn,ierr,VecSlot,nJ(NEl),nStore(6),iExcit,i,j,WalkersonHF
        REAL*8 :: SumMP1Compts,MP2Energy,Compt,Ran2,r
        HElement_t :: Hij,Hjj,Fjj
        INTEGER , ALLOCATABLE :: MP1Dets(:,:)
        REAL*8 , ALLOCATABLE :: MP1Comps(:),MP1Hij(:)
        LOGICAL , ALLOCATABLE :: MP1Sign(:)
        INTEGER :: MP1DetsTag,MP1CompsTag,MP1HijTag,MP1SignTag
        INTEGER*8 :: MemoryAlloc
        CHARACTER(Len=*) , PARAMETER :: this_routine='InitWalkersMP1'

!initialise the particle positions according to a discretized MP1 wavefunction

!Set the maximum number of walkers allowed
        MaxWalkers=NINT(MemoryFacPart*InitWalkers)

        WRITE(6,"(A,I10,A)") "Initial number of particles set to ",InitWalkers, &
        &   " distributed according to the MP1 wavefunction. Shift will start at the MP2 energy."
        WRITE(6,*) "Damping parameter for Diag Shift set to: ", SftDamp
        WRITE(6,*) "Maximum storage capability of walkers is: ", MaxWalkers

!Allocate memory to hold walkers
        ALLOCATE(WalkVecDets(NEl,MaxWalkers),stat=ierr)
        CALL LogMemAlloc('WalkVecDets',MaxWalkers*NEl,4,this_routine,WalkVecDetsTag,ierr)
        WalkVecDets(1:NEl,1:MaxWalkers)=0
        ALLOCATE(WalkVec2Dets(NEl,MaxWalkers),stat=ierr)
        CALL LogMemAlloc('WalkVec2Dets',MaxWalkers*NEl,4,this_routine,WalkVec2DetsTag,ierr)
        WalkVec2Dets(1:NEl,1:MaxWalkers)=0
        ALLOCATE(WalkVecSign(MaxWalkers),stat=ierr)
        CALL LogMemAlloc('WalkVecSign',MaxWalkers,4,this_routine,WalkVecSignTag,ierr)
        ALLOCATE(WalkVec2Sign(MaxWalkers),stat=ierr)
        CALL LogMemAlloc('WalkVec2Sign',MaxWalkers,4,this_routine,WalkVec2SignTag,ierr)

        ALLOCATE(WalkVecIC(MaxWalkers),stat=ierr)
        CALL LogMemAlloc('WalkVecIC',MaxWalkers,4,this_routine,WalkVecICTag,ierr)
        ALLOCATE(WalkVec2IC(MaxWalkers),stat=ierr)
        CALL LogMemAlloc('WalkVec2IC',MaxWalkers,4,this_routine,WalkVec2ICTag,ierr)
        ALLOCATE(WalkVecH(2,MaxWalkers),stat=ierr)
        CALL LogMemAlloc('WalkVecH',MaxWalkers*2,8,this_routine,WalkVecHTag,ierr)
        WalkVecH=0.d0
        ALLOCATE(WalkVec2H(2,MaxWalkers),stat=ierr)
        CALL LogMemAlloc('WalkVec2H',MaxWalkers*2,8,this_routine,WalkVec2HTag,ierr)
        WalkVec2H=0.d0

        MemoryAlloc=((2*NEl)+12)*4*MaxWalkers

!Allocate pointers to the correct walker arrays
        CurrentDets=>WalkVecDets
        CurrentSign=>WalkVecSign
        CurrentIC=>WalkVecIC
        CurrentH=>WalkVecH
        NewDets=>WalkVec2Dets
        NewSign=>WalkVec2Sign
        NewIC=>WalkVec2IC
        NewH=>WalkVec2H

!Now calculate MP1 components - allocate memory for doubles
        CALL GetSymExcitCount(HFExcit%ExcitData,HFConn)
        HFConn=HFConn+1     !Add on one for the HF Det itself

        ALLOCATE(MP1Comps(HFConn),stat=ierr)    !This will store the cumulative absolute values of the mp1 wavevector components
        CALL LogMemAlloc('MP1Comps',HFConn,8,this_routine,MP1CompsTag,ierr)
        MP1Comps=0.d0
        ALLOCATE(MP1Dets(NEl,HFConn),stat=ierr)
        CALL LogMemAlloc('MP1Dets',HFConn*NEl,4,this_routine,MP1DetsTag,ierr)
        MP1Dets(1:NEl,1:HFConn)=0
        ALLOCATE(MP1Sign(HFConn),stat=ierr)
        CALL LogMemAlloc('MP1Sign',HFConn,4,this_routine,MP1SignTag,ierr)
        ALLOCATE(MP1Hij(HFConn),stat=ierr)
        CALL LogMemAlloc('MP1Hij',HFConn,8,this_routine,MP1HijTag,ierr)

!HF Compt. of MP1 is 1
!        CALL NECI_ICOPY(NEl,HFDet,1,MP1Dets(1:NEl,1),1)
        MP1Dets(1:NEl,1)=HFDet(:)
        MP1Comps(1)=1.D0
        MP1Sign(1)=.true.

        SumMP1Compts=1.D0   !Initialise the sum of the MP1 wavevector components
        VecSlot=2           !This is the next free slot in the MP1 arrays
        MP2Energy=0.D0      !Calculate the MP2 energy as we go, since the shift will be set to this

        CALL ResetExIt2(HFExcit%ExcitData)

        do while(.true.)
!Generate double excitations
            CALL GenSymExcitIt2(HFDet,NEl,G1,nBasis,.false.,HFExcit%Excitdata,nJ,iExcit,nStore,2)
            IF(nJ(1).eq.0) EXIT
            IF(iExcit.ne.2) THEN
                CALL Stop_All("InitWalkersMP1","Error - excitations other than doubles being generated in MP1 wavevector code")
            ENDIF

            Hij = get_helement (HFDet, nJ, iExcit)
            CALL GetH0Element(nJ,NEl,Arr,nBasis,ECore,Fjj)

            Compt=real(Hij,dp)/(Fii-(REAL(Fjj,dp)))     !Calculate MP1 components
            MP1Hij(VecSlot)=real(Hij,dp)                  !Store Hij to give to particles
            IF(Compt.lt.0.D0) THEN
                MP1Sign(VecSlot)=.false.
                IF(MP1Hij(VecSlot).lt.0.D0) THEN
                    CALL Stop_All("InitWalkersMP1","Problem here - particle on MP1 double registered as -ve, but Hij is -ve...")
                ENDIF
            ELSE
                MP1Sign(VecSlot)=.true.
            ENDIF
!            CALL NECI_ICOPY(NEl,nJ,1,MP1Dets(1:NEl,VecSlot),1)
            MP1Dets(1:NEl,VecSlot)=nJ(:)
            MP1Comps(VecSlot)=MP1Comps(VecSlot-1)+abs(Compt)
            SumMP1Compts=SumMP1Compts+abs(Compt)
            MP2Energy=MP2Energy+((real(Hij,dp))**2)/(Fii-(REAL(Fjj,dp)))

            VecSlot=VecSlot+1

        enddo
        CALL ResetExIt2(HFExcit%ExcitData)

        WRITE(6,"(A,F15.7,A)") "Sum of absolute components of MP1 wavefunction is ",SumMP1Compts," with the HF being 1."

        VecSlot=VecSlot-1

!Total components is VecSlot
        IF(MP1Comps(VecSlot).ne.SumMP1Compts) THEN
            CALL Stop_All("InitWalkersMP1","Error in calculating sum of MP1 components")
        ENDIF

        DiagSft=MP2Energy
        MP2Energy=MP2Energy+Hii
        WRITE(6,"(A,F16.7,A,F16.7)") "MP2 energy is ",MP2Energy," which the initial shift has been set to: ",DiagSft

        WalkersonHF=0       !Find the number of walkers we are assigning to HF

        do j=1,InitWalkers

            i=1

            r=Ran2(Seed)*SumMP1Compts       !Choose the double that this walker wants to be put...
            do while(r.gt.MP1Comps(i))

                i=i+1

                IF(i.gt.VecSlot) THEN
                    CALL Stop_All("InitWalkersMP1","Assigning walkers stochastically has been performed incorrectly")
                ENDIF

            enddo

            IF(i.eq.1) THEN
!If we are at HF, then we do not need to calculate the information for the walker
                WalkersonHF=WalkersonHF+1
!                CALL NECI_ICOPY(NEl,HFDet,1,CurrentDets(1:NEl,j),1)
                CurrentDets(1:NEl,j)=HFDet(:)
                CurrentIC(j)=0
                CurrentSign(j)=.true.
                CurrentH(:,j)=0.D0
            ELSE
!We are at a double excitation - we need to calculate most of this information...
!                CALL NECI_ICOPY(NEl,MP1Dets(1:NEl,i),1,CurrentDets(1:NEl,j),1)
                CurrentDets(1:NEl,j)=MP1Dets(1:NEl,i)
                CurrentIC(j)=2
                CurrentSign(j)=MP1Sign(i)
                CurrentH(2,j)=MP1Hij(i)     !This is the off-diagonal element to HF det
                Hjj = get_helement (MP1Dets(:,i), MP1Dets(:,i), 0)
                CurrentH(1,j)=real(Hjj,dp)-Hii
            ENDIF

        enddo

        WRITE(6,"(A,I9,A,I9,A)") "Out of ",InitWalkers," initial walkers allocated, ",WalkersonHF, &
        &   " of them are situated on the HF determinant."
        NoatHF=WalkersonHF
        NoatDoubs=InitWalkers-WalkersonHF

!Deallocate MP1 data
        DEALLOCATE(MP1Comps)
        CALL LogMemDealloc(this_routine,MP1CompsTag)
        DEALLOCATE(MP1Dets)
        CALL LogMemDealloc(this_routine,MP1DetsTag)
        DEALLOCATE(MP1Sign)
        CALL LogMemDealloc(this_routine,MP1SignTag)
        DEALLOCATE(MP1Hij)
        CALL LogMemDealloc(this_routine,MP1HijTag)

        WRITE(6,"(A,F14.6,A)") "Initial memory (without excitgens) consists of : ", &
        &   REAL(MemoryAlloc,dp)/1048576.D0," Mb"
        WRITE(6,*) "Initial memory allocation sucessful..."
        CALL FLUSH(6)

        IF(.not.TRegenExcitgens) THEN
            ASSERT(.not. allocated(WalkVecExcits))
            ASSERT(.not. allocated(WalkVec2Excits))

            ALLOCATE(WalkVecExcits(MaxWalkers),stat=ierr)
            IF(ierr.ne.0) CALL Stop_All("InitFCIMCCalc","Error in allocating walker excitation generators")
            ALLOCATE(WalkVec2Excits(MaxWalkers),stat=ierr)
            IF(ierr.ne.0) CALL Stop_All("InitFCIMCCalc","Error in allocating walker excitation generators")
!Allocate pointers to the correct excitation arrays

            do i = 1, MaxWalkers
                call excitgenerator_init(WalkVecExcits(i))
                call excitgenerator_init(WalkVec2Excits(i))
            enddo

            CurrentExcits=>WalkVecExcits
            NewExcits=>WalkVec2Excits
            MemoryAlloc=((INT(HFExcit%nExcitMemLen,8))+2)*4*INT(MaxWalkers,8)
        ENDIF


        IF(.not.TRegenExcitgens) THEN

            do i=1,InitWalkers
                IF(CurrentIC(i).eq.0) THEN
!We are at HF - can copy accross correct excitation generator...
                    CALL CopyExitGen(HFExcit,CurrentExcits(i))
                ELSE
!We are at a double excitation - simply tell it to find the excitation generator when it is needed
                    CurrentExcits(i)%ExcitgenForDet=.false.
                ENDIF
            enddo
            WRITE(6,"(A,F14.6,A)") "Probable maximum memory for excitgens is : ",REAL(MemoryAlloc,dp)/1048576.D0," Mb"
            WRITE(6,*) "Initial allocation of excitation generators successful..."
            CALL FLUSH(6)
        ELSE
            WRITE(6,*) "Excitation generators not being stored..."
        ENDIF

        RETURN

    END SUBROUTINE InitWalkersMP1


    SUBROUTINE InitMP2Calc()
        INTEGER :: nJ(NEl),nStore(6),ExcitForm(2,2),iExcit
        INTEGER :: MaxComptDet(NEl),Compts
        REAL*8 :: Denom,MaxCompt,MP2Energy,MP1Comp
        HElement_t :: Hij

!The MP1 wavefunction components are no longer precalculated, but rather calculated on the fly now.
!Need to calculate all the components of the MP2 wavefunction, and store them in MP2ExcitComps
!MP2 ExcitComps stores the eigenvector for ij->ab, with each dimension representing an index
!i > j and a > b. An indexing scheme and a 1D array could be used.
!The HF component is 1, since we are working with an unnormalised eigenvector.
!        ALLOCATE(MP2ExcitComps(NEl,NEl,nBasis-NEl,nBasis-NEl),stat=ierr)
!        CALL LogMemAlloc("MP2ExcitComps",NEl*NEl*(nBasis-NEl)**2,8,this_routine,MP2ExcitCompsTag,ierr)
!        MP2ExcitComps=0.d0
!
!!To store in excitation form - need to be able to order orbitals purely in terms of energy, so setup INVBRR
!!This is different to the INVBRR in UMatCache, since it works with spin-orbitals
!        ALLOCATE(INVBRRSpinOrb(nBasis),stat=ierr)
!        CALL LogMemAlloc("InvBrrSpinOrb",nBasis,4,this_routine,InvBrrSpinOrbTag,ierr)
!        INVBRRSpinOrb(1:nBasis)=0
!        t=0
!        do i=1,nBasis
!            t=t+1
!            INVBRRSpinOrb(BRR(i))=t
!        enddo

!        WRITE(6,*) "INVBRRSpinOrb is: ",INVBRRSpinOrb(:)

        MP2Energy=Hii  !From HF Determinant which has a wavevector component of 1
        MaxCompt=1.D0
        MaxComptDet(:)=HFDet(:)
        Compts=0
        excitform = 0

!Reset the HF Excitation generator
        CALL ResetExIt2(HFExcit%ExcitData)

        do while(.true.)
!Generate double excitations
            CALL GenSymExcitIt2(HFDet,NEl,G1,nBasis,.false.,HFExcit%Excitdata,nJ,iExcit,nStore,2)
            IF(nJ(1).eq.0) EXIT
            Compts=Compts+1     !Calculate total number of MP1 excitations
!            ExcitForm(1,1)=2    !signify that we are only dealing with double excitations
            IF(iExcit.ne.2) CALL Stop_All("InitMP2Calc","Excitations other than double being generated")
!            CALL GetExcitation(HFDet,nJ,NEl,ExcitForm,tSign)
!!The i,j orbitals are ExcitForm(1,1) and (1,2). a/b are (2,1) and (2,2)
!!Find the ordering of the orbitals in terms of energy
!            I=INVBRRSpinOrb(ExcitForm(1,1))
!            J=INVBRRSpinOrb(ExcitForm(1,2))
!            A=INVBRRSpinOrb(ExcitForm(2,1))
!            B=INVBRRSpinOrb(ExcitForm(2,2))
!
!!Ensure i > j and a > b.
!            IF(I.lt.J) THEN
!                t=I
!                I=J
!                J=t
!            ELSEIF(I.eq.J) THEN
!                CALL Stop_All("InitMP2Calc","Cannot have I.eq.J")
!            ENDIF
!            IF(A.lt.B) THEN
!                t=A
!                A=B
!                B=t
!            ELSEIF(A.eq.B) THEN
!                CALL Stop_All("InitMP2Calc","Cannot have A.eq.B")
!            ENDIF
!            IF(I.ge.B) CALL Stop_All("InitMP2Calc","Indexing scheme incorrect")
!            IF((I.gt.NEl).or.(J.gt.NEl)) CALL Stop_All("InitMP2Calc","Indexing scheme incorrect")
!            IF((A.gt.nBasis).or.(B.gt.nBasis)) CALL Stop_All("InitMP2Calc","Indexing scheme incorrect")
!            IF((A.le.NEl).or.(B.le.NEl)) CALL Stop_All("InitMP2Calc","Indexing scheme incorrect")
!
!            A=A-NEl     !Virtual orbital indexing cannot be > NEl, so remove to save space.
!            B=B-NEl

!Now put component of MP2 wavefunction into MP2ExcitComps(I,J,A,B)
            Denom=Arr(ExcitForm(2,1),2)-Arr(ExcitForm(1,1),2)+Arr(ExcitForm(2,2),2)-Arr(ExcitForm(1,2),2)
            Hij = get_helement (HFDet, nJ, iExcit)

!            MP2ExcitComps(I,J,A,B)=-REAL(Hij,dp)/Denom    !Store MP2 Wavefunction
            MP1Comp=-REAL(Hij,dp)/Denom
            IF((ABS(MP1Comp)).gt.MaxCompt) THEN
!Find the maximum component of the MP2 wavefunction
                MaxCompt=ABS(MP1Comp)
                MaxComptDet(:)=nJ(:)
            ENDIF
            MP2Energy=MP2Energy-(REAL(Hij,dp)**2)/Denom   !Calculate MP2 Energy

        enddo

!Reset the HF Excitation generator
        CALL ResetExIt2(HFExcit%ExcitData)

        WRITE(6,"(I7,A)") Compts," MP2 components calculated. Maximum MP2 wavevector component is determinant: "
        call write_det (6, MaxComptDet, .true.)
        WRITE(6,*) "MP2 ENERGY = ",MP2Energy
        CALL FLUSH(6)

        RETURN

    END SUBROUTINE InitMP2Calc

    SUBROUTINE InitBlocking()
        INTEGER :: TotSamples,TotBlocks,i

!First, we want to find the theoretical maximum number of different block sizes there could be in the simulation.
!This is the total number of shiftchange samples theoretically possible if the simulation goes to completion.
        TotSamples=INT(real(NMCyc)/real(StepsSft))

!I'm sure theres a more elegant way to do this, but this will calculate the maximum number of different block sizes possible
!This is calculated by seeing if the run will give at least two complete blocks of data.
        TotBlocks=0
        do i=0,100
            IF((TotSamples/(2**i)).ge.2) THEN
                TotBlocks=TotBlocks+1
            ELSE
                EXIT
            ENDIF
        enddo

        WRITE(6,"(A,I6)") "Total number of different sizes blocks possible is: ",TotBlocks

!We will have Totblocks different block sizes, of length: 1,2,4,8,...,2**TotBlocks.
!Allocate memory to hold the stats for these different block lengths.


        RETURN
    END SUBROUTINE InitBlocking

    SUBROUTINE WriteToPopsFile()

        use util_mod, only: get_unique_filename, get_free_unit

        INTEGER :: j,k, iunit
        character (255) :: popsfile

        call get_unique_filename('POPSFILE',tIncrementPops,.true.,iPopsFileNoWrite,popsfile)

        WRITE(6,*) "Writing to POPSFILE..."
        iunit = get_free_unit()
        OPEN(iunit,FILE=popsfile,Status='unknown')
        WRITE(iunit,*) TotWalkers, "   TOTWALKERS"
        WRITE(iunit,*) DiagSft, "   DIAGSHIFT"
        WRITE(iunit,*) SumNoatHF, "   SUMNOATHF"
        WRITE(iunit,*) SumENum,"   SUMENUM ( \sum<D0|H|Psi> )"
        WRITE(iunit,*) Iter+PreviousCycles, "   PREVIOUS CYCLES"
        do j=1,TotWalkers
            do k=1,NEl
                WRITE(iunit,"(I5)",advance='no') CurrentDets(k,j)
            enddo
            WRITE(iunit,*) CurrentSign(j)
        enddo
        CLOSE(iunit)

        RETURN

    END SUBROUTINE WriteToPopsFile

    SUBROUTINE ReadFromPopsFile()

        use util_mod, only: get_unique_filename, get_free_unit

        INTEGER :: ierr,l,j,k,VecSlot,IntegerPart,iGetExcitLevel_2, iunit
        INTEGER*8 :: MemoryAlloc
        REAL*8 :: FracPart,Ran2
        HElement_t :: HElemTemp
        CHARACTER(len=*), PARAMETER :: this_routine='ReadFromPopsFile'
        LOGICAL :: exists
        character(255) :: popsfile

        call get_unique_filename('POPSFILE',tIncrementPops,.false.,iPopsFileNoRead,popsfile)
        INQUIRE(FILE=popsfile,EXIST=exists)
        IF(.not.exists) THEN
            CALL Stop_All("ReadFromPopsFile",trim(popsfile)//"not present - cannot read in particle configuration")
        ENDIF
        iunit = get_free_unit()
        OPEN(iunit,FILE=popsfile,Status='old')
!Read in initial data
        READ(iunit,*) InitWalkers
        READ(iunit,*) DiagSft
        READ(iunit,*) SumNoatHF
        READ(iunit,*) SumENum
        READ(iunit,*) PreviousCycles

        WRITE(6,*) "Number of cycles in previous simulation: ",PreviousCycles
        IF(NEquilSteps.gt.0) THEN
            WRITE(6,*) "Removing equilibration steps since reading in from POPSFILE."
            NEquilSteps=0
        ENDIF

        IF(TZeroProjE) THEN
!Zero projected energy estimator.
            WRITE(6,*) "Resetting projected energy counters to zero..."
            SumNoatHF=0.D0
            SumENum=0.D0
        ENDIF

        MaxWalkers=NINT(MemoryFacPart*InitWalkers)
!Allocate memory to hold walkers at least temporarily
        ALLOCATE(WalkVecDets(NEl,MaxWalkers),stat=ierr)
        CALL LogMemAlloc('WalkVecDets',MaxWalkers*NEl,4,this_routine,WalkVecDetsTag,ierr)
        WalkVecDets(1:NEl,1:MaxWalkers)=0
        ALLOCATE(WalkVecSign(MaxWalkers),stat=ierr)
        CALL LogMemAlloc('WalkVecSign',MaxWalkers,4,this_routine,WalkVecSignTag,ierr)

        do l=1,InitWalkers
            READ(iunit,*) WalkVecDets(1:NEl,l),WalkVecSign(l)
        enddo
        CLOSE(iunit)

        WRITE(6,*) InitWalkers," particles read in from POPSFILE..."

        IF(ScaleWalkers.ne.1.D0) THEN

            WRITE(6,*) "Rescaling walkers by a factor of: ",ScaleWalkers
            MaxWalkers=NINT(MemoryFacPart*(nint(InitWalkers*ScaleWalkers)))

!Allocate more memory for WalkVec2
            ALLOCATE(WalkVec2Dets(NEl,MaxWalkers),stat=ierr)
            CALL LogMemAlloc('WalkVec2Dets',MaxWalkers*NEl,4,this_routine,WalkVec2DetsTag,ierr)
            WalkVec2Dets(1:NEl,1:MaxWalkers)=0
            ALLOCATE(WalkVec2Sign(MaxWalkers),stat=ierr)
            CALL LogMemAlloc('WalkVec2Sign',MaxWalkers,4,this_routine,WalkVec2SignTag,ierr)

            IntegerPart=INT(ScaleWalkers)
            FracPart=ScaleWalkers-REAL(IntegerPart)

            VecSlot=1
            do l=1,InitWalkers
                do k=1,IntegerPart
                    WalkVec2Dets(1:NEl,VecSlot)=WalkVecDets(1:NEl,l)
                    WalkVec2Sign(VecSlot)=WalkVecSign(l)
                    VecSlot=VecSlot+1
                enddo
                IF(Ran2(Seed).lt.FracPart) THEN
!Create extra stochastically created particle
                    WalkVec2Dets(1:NEl,VecSlot)=WalkVecDets(1:NEl,l)
                    WalkVec2Sign(VecSlot)=WalkVecSign(l)
                    VecSlot=VecSlot+1
                ENDIF
            enddo

            WRITE(6,*) "Total number of initial walkers is now: ",VecSlot-1
            WRITE(6,*) "Initial Diagonal Shift (Ecorr guess) is now: ", DiagSft
!            InitWalkers=nint(InitWalkers*ScaleWalkers)
            InitWalkers=VecSlot-1

!Deallocate the arrays used to hold the original walkers, and reallocate with right size
            DEALLOCATE(WalkVecDets)
            CALL LogMemDealloc(this_routine,WalkVecDetsTag)
            DEALLOCATE(WalkVecSign)
            CALL LogMemDealloc(this_routine,WalkVecSignTag)
            ALLOCATE(WalkVecDets(NEl,MaxWalkers),stat=ierr)
            CALL LogMemAlloc('WalkVecDets',MaxWalkers*NEl,4,this_routine,WalkVecDetsTag,ierr)
            WalkVecDets(1:NEl,1:MaxWalkers)=0
            ALLOCATE(WalkVecSign(MaxWalkers),stat=ierr)
            CALL LogMemAlloc('WalkVecSign',MaxWalkers,4,this_routine,WalkVecSignTag,ierr)

!Transfer initial data accross to WalkVecDets
            do l=1,InitWalkers
                WalkVecDets(1:NEl,l)=WalkVec2Dets(1:NEl,l)
                WalkVecSign(l)=WalkVec2Sign(l)
            enddo

!Zero the second arrays
            WalkVec2Dets(1:NEl,1:MaxWalkers)=0

        ELSE
!If not scaling, second array has not been allocated, allocate it now
            ALLOCATE(WalkVec2Dets(NEl,MaxWalkers),stat=ierr)
            CALL LogMemAlloc('WalkVec2Dets',MaxWalkers*NEl,4,this_routine,WalkVec2DetsTag,ierr)
            WalkVec2Dets(1:NEl,1:MaxWalkers)=0
            ALLOCATE(WalkVec2Sign(MaxWalkers),stat=ierr)
            CALL LogMemAlloc('WalkVec2Sign',MaxWalkers,4,this_routine,WalkVec2SignTag,ierr)

            WRITE(6,*) "Total number of initial walkers is now: ",InitWalkers
            WRITE(6,*) "Initial Diagonal Shift (Ecorr guess) is now: ", DiagSft

        ENDIF

        WRITE(6,*) "Damping parameter for Diag Shift set to: ", SftDamp

!Now need to allocate other arrays
        ALLOCATE(WalkVecIC(MaxWalkers),stat=ierr)
        CALL LogMemAlloc('WalkVecIC',MaxWalkers,4,this_routine,WalkVecICTag,ierr)
        ALLOCATE(WalkVec2IC(MaxWalkers),stat=ierr)
        CALL LogMemAlloc('WalkVec2IC',MaxWalkers,4,this_routine,WalkVec2ICTag,ierr)
        ALLOCATE(WalkVecH(2,MaxWalkers),stat=ierr)
        CALL LogMemAlloc('WalkVecH',MaxWalkers*2,8,this_routine,WalkVecHTag,ierr)
        WalkVecH=0.d0
        ALLOCATE(WalkVec2H(2,MaxWalkers),stat=ierr)
        CALL LogMemAlloc('WalkVec2H',MaxWalkers*2,8,this_routine,WalkVec2HTag,ierr)
        WalkVec2H=0.d0

        MemoryAlloc=((2*NEl)+12)*4*MaxWalkers

        WRITE(6,"(A,F14.6,A)") "Initial memory (without excitgens) consists of : ",REAL(MemoryAlloc,dp)/1048576.D0," Mb"
        WRITE(6,*) "Initial memory allocation sucessful..."
        CALL FLUSH(6)

!Allocate pointers to the correct walker arrays
        CurrentDets=>WalkVecDets
        CurrentSign=>WalkVecSign
        CurrentIC=>WalkVecIC
        CurrentH=>WalkVecH
        NewDets=>WalkVec2Dets
        NewSign=>WalkVec2Sign
        NewIC=>WalkVec2IC
        NewH=>WalkVec2H

        IF(.not.TRegenExcitgens) THEN
            ASSERT(.not. allocated(WalkVecExcits))
            ASSERT(.not. allocated(WalkVec2Excits))

            ALLOCATE(WalkVecExcits(MaxWalkers),stat=ierr)
            ALLOCATE(WalkVec2Excits(MaxWalkers),stat=ierr)
            IF(ierr.ne.0) CALL Stop_All("InitFCIMCCalc","Error in allocating walker excitation generators")

            do j = 1, MaxWalkers
                call excitgenerator_init(WalkVecExcits(j))
                call excitgenerator_init(WalkVec2Excits(j))
            enddo

    !Allocate pointers to the correct excitation arrays
            CurrentExcits=>WalkVecExcits
            NewExcits=>WalkVec2Excits
        ENDIF

!Initialise data for new walkers
        do j=1,InitWalkers
            CurrentIC(j)=iGetExcitLevel_2(HFDet,CurrentDets(:,j),NEl,NEl)
            IF(CurrentIC(j).eq.2) THEN
!Only need it for double excitations, since these are the only ones which contribute to energy
                HElemTemp = get_helement (HFDet, CurrentDets(:,j), 2)
                CurrentH(2,j)=REAL(HElemTemp,dp)
                HElemTemp = get_helement (CurrentDets(:,j),CurrentDets(:,j),0)
                CurrentH(1,j)=REAL(HElemTemp,dp)-Hii
                IF(.not.TRegenExcitgens) CurrentExcits(j)%ExcitGenForDet=.false.
            ELSEIF(CurrentIC(j).eq.0) THEN
!We know we are at HF - HDiag=0, and can use HF excitgen
                IF(.not.TRegenExcitgens) CALL CopyExitGen(HFExcit,CurrentExcits(j))
                CurrentH(1,j)=0.D0
                CurrentH(2,j)=0.D0

            ELSE
                IF(.not.TRegenExcitgens) CurrentExcits(j)%ExcitGenForDet=.false.
                HElemTemp = get_helement (CurrentDets(:,j),CurrentDets(:,j),0)
                CurrentH(1,j)=(REAL(HElemTemp,dp))-Hii
                CurrentH(2,j)=0.D0
            ENDIF

        enddo

        IF(.not.TRegenExcitgens) THEN
            MemoryAlloc=((INT(HFExcit%nExcitMemLen,8))+2)*4*INT(MaxWalkers,8)
            WRITE(6,"(A,F14.6,A)") "Probable maximum memory for excitgens is : ",REAL(MemoryAlloc,dp)/1048576.D0," Mb"
            WRITE(6,*) "Initial allocation of excitation generators successful..."
            CALL FLUSH(6)
        ELSE
            WRITE(6,*) "Excitation generators not being saved to save memory..."
            CALL FLUSH(6)
        ENDIF

        RETURN

    END SUBROUTINE ReadFromPopsFile


!This routine copies an excitation generator from origExcit to NewExit, if the original claims that it is for the correct determinant
    SUBROUTINE CopyExitgen(OrigExit,NewExit)
        TYPE(ExcitGenerator) :: OrigExit,NewExit
        INTEGER :: ierr

        IF(Associated(NewExit%ExcitData)) THEN
            DEALLOCATE(NewExit%ExcitData)
        ENDIF
        IF(.not.OrigExit%ExcitGenForDet) THEN
!See if we actually want the excitation generator - is it for the correct determinant
            NewExit%ExcitGenForDet=.false.
            RETURN
        ELSE
!We want to copy the excitation generator
            ALLOCATE(NewExit%ExcitData(OrigExit%nExcitMemLen),stat=ierr)
!            IF(OrigExit%nExcitMemLen.eq.0) THEN
!                CALL Stop_All("CopyExitgen","Problem allocating memory for new excit")
!            ENDIF
            IF(ierr.ne.0) CALL Stop_All("CopyExitgen","Problem with allocating memory for new excitation generator")
!            CALL NECI_ICOPY(OrigExit%nExcitMemLen,OrigExit%ExcitData,1,NewExit%ExcitData,1)
            NewExit%ExcitData(:)=OrigExit%ExcitData(:)
!            NewExit%ExcitData(:)=OrigExit%ExcitData(:)
            NewExit%nExcitMemLen=OrigExit%nExcitMemLen
            NewExit%ExcitGenForDet=.true.
        ENDIF

        RETURN

    END SUBROUTINE CopyExitgen

    SUBROUTINE SetupExitgen(nI,ExcitGen)
        TYPE(ExcitGenerator) :: ExcitGen
        INTEGER :: ierr,iMaxExcit,nJ(NEl)
        INTEGER :: nI(NEl),nStore(6)
!        REAL*8 :: Prob

        IF(ExcitGen%ExcitGenForDet) THEN
!The excitation generator is already allocated for the determinant in question - no need to recreate it
            IF(.not.associated(ExcitGen%ExcitData)) THEN
                CALL Stop_All("SetupExitgen","Excitation generator meant to already be set up")
            ENDIF

        ELSE

            IF(Associated(ExcitGen%ExcitData)) THEN
                DEALLOCATE(ExcitGen%ExcitData)
            ENDIF

!Setup excit generators for this determinant (This can be reduced to an order N routine later for abelian symmetry.
            iMaxExcit=0
            nStore(1:6)=0
            CALL GenSymExcitIt2(nI,NEl,G1,nBasis,.TRUE.,ExcitGen%nExcitMemLen,nJ,iMaxExcit,nStore,3)
            ALLOCATE(ExcitGen%ExcitData(ExcitGen%nExcitMemLen),stat=ierr)
            IF(ierr.ne.0) CALL Stop_All("SetupExcitGen","Problem allocating excitation generator")
            ExcitGen%ExcitData(1)=0
            CALL GenSymExcitIt2(nI,NEl,G1,nBasis,.TRUE.,ExcitGen%ExcitData,nJ,iMaxExcit,nStore,3)

!Check generation probabilities
!            CALL GenRandSymExcitIt3(nI,ExcitGen%ExcitData,nJ,Seed,IC,Prob,iCount)
!            Exitlevel=iGetExcitLevel(nI,HFDet,NEl)
!            IF(ABS((1.D0/iMaxExcit)-Prob).gt.1.D-07) WRITE(6,"I5,I5,I9,2G20.10") ExitLevel,IC,iMaxExcit,1.D0/iMaxExcit,Prob

!Indicate that the excitation generator is now correctly allocated.
            ExcitGen%ExcitGenForDet=.true.

        ENDIF

    END SUBROUTINE SetupExitgen


!This routine gets a random excitation for when we want to generate the excitation generator on the fly, then chuck it.
SUBROUTINE GetPartRandExcit(DetCurr,nJ,Seed,IC,Prob,iCount,Excitlevel)
    INTEGER :: DetCurr(NEl),nJ(NEl),Seed,IC,iCount,iMaxExcit,nStore(6),MemLength,ierr
    INTEGER :: Excitlevel
    REAL*8 :: Prob
    INTEGER , ALLOCATABLE :: ExcitGenTemp(:)

    IF(Excitlevel.eq.0) THEN
        CALL GenRandSymExcitIt3(DetCurr,HFExcit%ExcitData,nJ,Seed,IC,Prob,iCount)
        RETURN
    ENDIF
!Need to generate excitation generator to find excitation.
!Setup excit generators for this determinant
    iMaxExcit=0
    nStore(1:6)=0
    CALL GenSymExcitIt2(DetCurr,NEl,G1,nBasis,.TRUE.,MemLength,nJ,iMaxExcit,nStore,3)
    ALLOCATE(ExcitGenTemp(MemLength),stat=ierr)
    IF(ierr.ne.0) CALL Stop_All("SetupExcitGen","Problem allocating excitation generator")
    ExcitGenTemp(1)=0
    CALL GenSymExcitIt2(DetCurr,NEl,G1,nBasis,.TRUE.,ExcitGenTemp,nJ,iMaxExcit,nStore,3)

!Now generate random excitation
    CALL GenRandSymExcitIt3(DetCurr,ExcitGenTemp,nJ,Seed,IC,Prob,iCount)

!Deallocate when finished
        DEALLOCATE(ExcitGenTemp)

        RETURN

    END SUBROUTINE GetPartRandExcit

!This function tells us whether we should create a child particle on nJ, from a parent particle on DetCurr with sign WSign, created with probability Prob
!It returns zero if we are not going to create a child, or -1/+1 if we are to create a child, giving the sign of the new particle
!You can optionally specify the connection between the determinants if it is already known.
    INTEGER FUNCTION AttemptCreate(DetCurr,WSign,nJ,Prob,IC,Hij)
        IMPLICIT NONE
        INTEGER :: DetCurr(NEl),nJ(NEl),IC,ExtraCreate
        LOGICAL :: WSign
        REAL*8 :: Prob,Ran2,rat
        REAL*8 , OPTIONAL :: Hij
        HElement_t :: rh

        IF(present(Hij)) THEN
!Connection between determinants is specified in Hij argument
            rh=(Hij)
        ELSE
!Calculate off diagonal hamiltonian matrix element between determinants
            rh = get_helement(DetCurr, nJ, IC)
        ENDIF

        SumConnections=SumConnections+REAL(rh,dp)     !Sum the connections (success and failure) to find average connection strength

!Divide by the probability of creating the excitation to negate the fact that we are only creating a few determinants
        rat=Tau*abs(REAL(rh,dp))/Prob

!If probability is > 1, then we can just create multiple children at the chosen determinant
        ExtraCreate=INT(rat)
        rat=rat-REAL(ExtraCreate)


!Stochastically choose whether to create or not according to Ran2
        IF(rat.gt.Ran2(Seed)) THEN
!Child is created - what sign is it?
            IF(WSign) THEN
!Parent particle is positive
                IF(real(rh).gt.0.D0) THEN
                    AttemptCreate=-1     !-ve walker created
                ELSE
                    AttemptCreate=1      !+ve walker created
                ENDIF

            ELSE
!Parent particle is negative
                IF(real(rh).gt.0.D0) THEN
                    AttemptCreate=1      !+ve walker created
                ELSE
                    AttemptCreate=-1     !-ve walker created
                ENDIF
            ENDIF

        ELSE
!No child particle created
            AttemptCreate=0
        ENDIF

        IF(ExtraCreate.ne.0) THEN
!Need to include the definitely create additional particles from a initial probability > 1

            IF(AttemptCreate.lt.0) THEN
!In this case particles are negative
                AttemptCreate=AttemptCreate-ExtraCreate
            ELSEIF(AttemptCreate.gt.0) THEN
!Include extra positive particles
                AttemptCreate=AttemptCreate+ExtraCreate
            ELSEIF(AttemptCreate.eq.0) THEN
!No particles were stochastically created, but some particles are still definatly created - we need to determinant their sign...
                IF(WSign) THEN
                    IF(real(rh).gt.0.D0) THEN
                        AttemptCreate=-1*ExtraCreate    !Additional particles are negative
                    ELSE
                        AttemptCreate=ExtraCreate       !Additional particles are positive
                    ENDIF
                ELSE
                    IF(real(rh).gt.0.D0) THEN
                        AttemptCreate=ExtraCreate
                    ELSE
                        AttemptCreate=-1*ExtraCreate
                    ENDIF
                ENDIF
            ENDIF
        ENDIF

        RETURN

    END FUNCTION AttemptCreate

!This function tells us whether we should kill the particle at determinant DetCurr
!If also diffusing, then we need to know the probability with which we have spawned. This will reduce the death probability.
!The function allows multiple births(if +ve shift) or deaths from the same particle.
!The returned number is the number of deaths if positive, and the number of births if negative.
    INTEGER FUNCTION AttemptDie(Kii)
        IMPLICIT NONE
        INTEGER :: iKill
!        HElement_t :: rh,rhij
        REAL*8 :: Ran2,rat,Kii

!Calculate the diagonal hamiltonian matrix element for the determinant
!        rh=GetHElement2(DetCurr,DetCurr,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,0,ECore)
!Subtract from the diagonal the value of the lowest hamiltonian matrix element
!        rh=rh-Hii

!Subtract the current value of the shift and multiply by tau
        rat=Tau*(Kii-DiagSft)

        iKill=INT(rat)
        rat=rat-REAL(iKill)

!Stochastically choose whether to die or not
        IF(abs(rat).gt.Ran2(Seed)) THEN
            IF(rat.ge.0.D0) THEN
!Depends whether we are trying to kill or give birth to particles.
                iKill=iKill+1
            ELSE
                iKill=iKill-1
            ENDIF
        ENDIF

        AttemptDie=iKill

        RETURN

    END FUNCTION AttemptDie

!Deallocate memory needed for the simulation
    SUBROUTINE DeallocFCIMCMem()
        INTEGER :: i
        CHARACTER(len=*), PARAMETER :: this_routine='DeallocFCIMCMem'

        DEALLOCATE(WalkVecDets)
        CALL LogMemDealloc(this_routine,WalkVecDetsTag)
        DEALLOCATE(WalkVec2Dets)
        CALL LogMemDealloc(this_routine,WalkVec2DetsTag)
        DEALLOCATE(WalkVecSign)
        CALL LogMemDealloc(this_routine,WalkVecSignTag)
        DEALLOCATE(WalkVec2Sign)
        CALL LogMemDealloc(this_routine,WalkVec2SignTag)
        DEALLOCATE(WalkVecIC)
        CALL LogMemDealloc(this_routine,WalkVecICTag)
        DEALLOCATE(WalkVec2IC)
        CALL LogMemDealloc(this_routine,WalkVec2ICTag)
        DEALLOCATE(WalkVecH)
        CALL LogMemDealloc(this_routine,WalkVecHTag)
        DEALLOCATE(WalkVec2H)
        CALL LogMemDealloc(this_routine,WalkVec2HTag)

        DEALLOCATE(HFDet)
        CALL LogMemDealloc(this_routine,HFDetTag)
        DEALLOCATE(HFExcit%ExcitData)
        IF(.not.TRegenExcitgens) THEN
            do i=1,MaxWalkers
                call excitgenerator_destroy(WalkVecExcits(i))
                call excitgenerator_destroy(WalkVec2Excits(i))
            enddo
            DEALLOCATE(WalkVecExcits)
            DEALLOCATE(WalkVec2Excits)
        ENDIF
        IF(TWriteDetE) THEN
            DEALLOCATE(EHistBins)
            CALL LogMemDealloc(this_routine,EHistBinsTag)
        ENDIF

    END SUBROUTINE DeallocFCIMCMem


END MODULE FciMCMod


!This is a determinant comparison function
!DetA and DetB are two determinants. Function will return 0 if they are the same, -1 if A.lt.B and +1 if A.gt.B when ordered.
INTEGER FUNCTION DetLT(DetA,DetB,NEl)
    IMPLICIT NONE
    INTEGER :: DetA(NEl),DetB(NEl),NEl,i

    do i=1,NEl
        IF(DetA(i).lt.DetB(i)) THEN
            DetLT=-1
            RETURN
        ELSEIF(DetA(i).gt.DetB(i)) THEN
            DetLT=+1
            RETURN
        ENDIF
    enddo
    DetLT=0
    RETURN

END FUNCTION DetLT

!A function to get the factorial of the number Num
INTEGER*8 FUNCTION Fact(Num)
    IMPLICIT NONE
    INTEGER :: Num,i

    Fact=Num
    do i=Num-1,2,-1
        Fact=Fact*i
    enddo
    RETURN

END FUNCTION Fact

!Below is the commented out old developmental serial version of the code. This contains more features, though has turned into a bit of a mess.
!It is not deleted as may want salvaging later, but it is now easier to rewrite a seperate more efficient code!

!
!    SUBROUTINE CreateNewParts(WSign,VecSlot,TotComps)
!        IMPLICIT NONE
!        LOGICAL :: WSign
!        INTEGER :: i,j,VecSlot,Create,ExtraCreate,StochCreate,iKill,TotComps,Components
!        REAL*8 :: Ran2,rat
!
!        IF(TResumAllConns) THEN
!            Components=TotComps
!        ELSE
!            Components=NDets
!        ENDIF
!
!        do i=1,Components
!
!            IF((i.ne.1).and.(.not.TResumAllConns)) THEN
!!Augment the list of creation probabilities by dividing through by the probability of creating a graph with that excitation in it.
!                GraphVec(i)=GraphVec(i)/((NDets-1)*RootExcitProb)
!            ENDIF
!
!            Create=INT(abs(GraphVec(i)))
!
!            rat=abs(GraphVec(i))-REAL(Create,dp)    !rat is now the fractional part, to be assigned stochastically
!            IF(rat.gt.Ran2(Seed)) Create=Create+1
!            IF(.not.WSign) Create=-Create
!            IF(GraphVec(i).lt.0.D0) Create=-Create
!!            IF((GraphVec(i).lt.0.D0).and.(i.eq.1)) THEN
!!                CALL Stop_All("CreateParts", "trying to create opposite signed particle on root")
!!            ENDIF
!!            IF(i.eq.1) WRITE(6,*) GraphVec(i),Create, WSign
!
!!Now actually create the particles in NewDets and NewSign
!            do j=1,abs(Create)
!                NewDets(:,VecSlot)=DetsInGraph(:,i)
!                IF(Create.lt.0) THEN
!                    NewSign(VecSlot)=.false.
!                ELSE
!                    NewSign(VecSlot)=.true.
!                ENDIF
!                VecSlot=VecSlot+1
!            enddo
!        enddo
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   T E S T - to reduce to original spawning when RhoApp=1 and NDets=2    !!!!!!!!!!!!!!!!!!!!!!!!
!
!!        do i=1,2
!!            GraphVec(i)=GraphVec(i)/GraphVecProbs(i)
!!        enddo
!!
!!!First deal with spawning prob.....GraphVec(2) has -tau*Hij/Pj    spawning prob is tau*abs(Hij)/Pj so take abs value
!!        rat=abs(GraphVec(2))
!!        ExtraCreate=INT(rat)
!!        rat=rat-REAL(ExtraCreate)
!!        IF(rat.gt.Ran2(Seed)) THEN
!!            StochCreate=1
!!        ELSE
!!            StochCreate=0
!!        ENDIF
!!        IF(WSign) THEN
!!!Parent particle is positive
!!            IF(GraphVec(2).lt.0.D0) THEN
!!                Create=-StochCreate-ExtraCreate     !-ve walker created
!!            ELSE
!!                Create=StochCreate+ExtraCreate      !+ve walker created
!!            ENDIF
!!
!!        ELSE
!!!Parent particle is negative
!!            IF(GraphVec(2).lt.0.D0) THEN
!!                Create=StochCreate+ExtraCreate      !+ve walker created
!!            ELSE
!!                Create=-StochCreate-ExtraCreate     !-ve walker created
!!            ENDIF
!!        ENDIF
!!
!!        do j=1,abs(Create)
!!            NewDets(:,VecSlot)=DetsInGraph(:,2)
!!            IF(Create.lt.0) THEN
!!                NewSign(VecSlot)=.false.
!!            ELSE
!!                NewSign(VecSlot)=.true.
!!            ENDIF
!!            VecSlot=VecSlot+1
!!        enddo
!!
!!!Now deal with death......GraphVec(1) has 1-tau*((Hii-H00)-Sft)    Death probability is tau*((Hii-H00)-Sft)
!!        rat=1.D0-GraphVec(1)        !This is now death prob
!!        iKill=INT(rat)
!!        rat=rat-REAL(iKill)
!!        IF(abs(rat).gt.Ran2(Seed)) THEN
!!            IF(rat.ge.0.D0) THEN
!!!Depends whether we are trying to kill or give birth to particles.
!!                iKill=iKill+1
!!            ELSE
!!                iKill=iKill-1
!!            ENDIF
!!        ENDIF
!!
!!        IF(iKill.eq.0) THEN
!!!Want to keep particle - copy accross
!!            NewDets(:,VecSlot)=DetsInGraph(:,1)
!!            IF(WSign) THEN
!!                NewSign(VecSlot)=.true.
!!            ELSE
!!                NewSign(VecSlot)=.false.
!!            ENDIF
!!            VecSlot=VecSlot+1
!!        ELSEIF(iKill.eq.1) THEN
!!!Don't copy accross
!!        ELSE
!!            WRITE(6,*) Iter,iKill,-(1.D0-GraphVec(1)),GraphVec(1)
!!            CALL Stop_All("CreateParts","Trying to kill/survive > 1")
!!        ENDIF
!
!        RETURN
!
!    END SUBROUTINE CreateNewParts
!
!!This applies the rho matrix successive times to a root determinant. From this, GraphVec is filled with the correct probabilities for the determinants in the graph
!    SUBROUTINE ApplyRhoMat(TotComps)
!        IMPLICIT NONE
!        REAL*8 , ALLOCATABLE :: TempVec(:)
!        INTEGER :: i,j,k,TotComps,ierr,Components
!
!        IF(TResumAllConns) THEN
!!TotComps is the total dimension of the matrix if all excitations included (i.e. iMaxExcit+1)
!            Components=TotComps
!        ELSE
!            Components=NDets
!        ENDIF
!
!        ALLOCATE(TempVec(Components),stat=ierr)
!        GraphVec=0.d0
!        TempVec=0.d0
!
!        GraphVec(1)=1.D0    !Set the initial vector to be 1 at the root (i.e. for one walker initially)
!
!        do i=1,RhoApp   !Cycle over the number of times we want to apply the rho matrix
!
!            CALL DGEMV('n',Components,Components,1.D0,GraphRhoMat,Components,GraphVec,1,0.D0,TempVec,1)
!            CALL DCOPY(Components,TempVec,1,GraphVec,1)
!            TempVec=0.d0
!
!!            do j=1,Components
!!                TempVec(j)=0.D0
!!                do k=1,Components
!!                    TempVec(j)=TempVec(j)+GraphRhoMat(j,k)*GraphVec(k)
!!                enddo
!!            enddo
!!            do j=1,Components
!!                GraphVec(j)=TempVec(j)
!!            enddo
!
!        enddo
!
!        DEALLOCATE(TempVec)
!
!        RETURN
!
!    END SUBROUTINE ApplyRhoMat
!
!
!
!!This creates a graph of size NDets with all determinants attached to nI. It also forms the matrix for it, and puts it in GraphRhoMat, with the dets used in DetsInGraph(NEl,NDets)
!    SUBROUTINE CreateGraph(nI,ExcitGen,TotExcits,TotComps)
!        IMPLICIT NONE
!        INTEGER :: nI(NEl),IC,iCount,nJ(NEl),i,j,Attempts,TotExcits,ierr,TotComps
!        REAL*8 :: Prob,RemovedProb
!        TYPE(ExcitGenerator) :: ExcitGen
!        HElement_t :: Hamii,Hamij
!        LOGICAL :: SameDet,CompiPath
!
!        IF(TResumAllConns) THEN
!            TotComps=TotExcits+1
!            IF(ALLOCATED(GraphRhoMat)) DEALLOCATE(GraphRhoMat)
!            IF(ALLOCATED(GraphVec)) DEALLOCATE(GraphVec)
!            IF(ALLOCATED(DetsinGraph)) DEALLOCATE(DetsinGraph)
!            ALLOCATE(GraphRhoMat(TotComps,TotComps),stat=ierr)
!            ALLOCATE(GraphVec(TotComps),stat=ierr)
!            ALLOCATE(DetsinGraph(NEl,TotComps),stat=ierr)
!            GraphRhoMat=0.d0
!            DetsinGraph(1:NEl,1:TotComps)=0
!        ELSE
!            GraphRhoMat=0.d0
!        ENDIF
!
!        DetsInGraph(:,1)=nI(:)
!        RemovedProb=0.D0        !RemovedProb is the sum of the probabilities of the excitations already picked. This allows for unbiasing when we only select distinct determinants.
!
!!Find diagonal element for root determinant
!        Hamii=GetHElement2(nI,nI,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,0,ECore)
!!        GraphRhoMat(1,1)=1.D0-Tau*((REAL(Hamii,dp)-REAL(Hii,dp))-(DiagSft/REAL(RhoApp,dp)))
!        GraphRhoMat(1,1)=1.D0-Tau*((REAL(Hamii,dp)-REAL(Hii,dp))-DiagSft)
!
!        IF(TResumAllConns) THEN
!!We want to run through all possible connections to nI...
!            i=2
!            do while(.true.)
!                CALL GenSymExcitIt2(nI,NEl,G1,nBasis,nBasisMax,.false.,ExcitGen%ExcitData,nJ,IC,0,ExcitGen%nStore,exFlag)
!                IF(nJ(1).eq.0) EXIT
!!Determinant is distinct - add it
!                IF(i.gt.TotComps) CALL Stop_All("CreateGraph","Problem creating graph")
!                DetsInGraph(:,i)=nJ(:)
!
!!First find connection to root
!                Hamij=GetHElement2(nI,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,IC,ECore)
!                GraphRhoMat(1,i)=-Tau*REAL(Hamij,dp)
!                GraphRhoMat(i,1)=GraphRhoMat(1,i)
!
!!Then find connection to other determinants
!                do j=2,(i-1)
!                    Hamij=GetHElement2(nJ,DetsInGraph(:,j),NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,-1,ECore)
!                    GraphRhoMat(i,j)=-Tau*REAL(Hamij,dp)
!                    GraphRhoMat(j,i)=GraphRhoMat(i,j)
!                enddo
!
!!Find diagonal element
!                Hamii=GetHElement2(nJ,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,0,ECore)
!!                GraphRhoMat(i,i)=1.D0-(Tau*((REAL(Hamii,dp)-REAL(Hii,dp))-(DiagSft/REAL(RhoApp,dp))))
!                GraphRhoMat(i,i)=1.D0-Tau*((REAL(Hamii,dp)-REAL(Hii,dp))-DiagSft)
!                i=i+1   !Increment counter
!
!            enddo   !loop over excitations
!
!        ELSE
!!Here we are choosing a stochastic graph with a smaller number of excitations chosen at random
!
!            i=2
!            do while(i.le.NDets)    !loop until all connections found
!
!                CALL GenRandSymExcitIt3(nI,ExcitGen%ExcitData,nJ,Seed,IC,Prob,iCount)
!
!                SameDet=.false.
!                do j=2,(i-1)
!                    IF(CompiPath(nJ,DetsInGraph(:,j),NEl)) THEN
!!determinants are the same - ignore them
!                        SameDet=.true.
!                        Attempts=Attempts+1     !Increment the attempts counter
!                        IF(Attempts.gt.100) CALL Stop_All("CreateGraph","More than 100 attempts needed to grow graph")
!                        EXIT
!                    ENDIF
!                enddo
!
!                IF(.not.SameDet) THEN
!!Store the unbiased probability of generating excitations from this root - check that it is the same as other excits generated
!                    IF(i.eq.2) THEN
!                        RootExcitProb=Prob
!                    ELSE
!                        IF(abs(Prob-RootExcitProb).gt.1.D-07) THEN
!                            CALL Stop_All("CreateGraph","Excitation probabilities are not uniform - problem here...")
!                        ENDIF
!                    ENDIF
!
!!Determinant is distinct - add it
!                    DetsInGraph(:,i)=nJ(:)
!
!!First find connection to root
!                    Hamij=GetHElement2(nI,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,IC,ECore)
!                    GraphRhoMat(1,i)=-Tau*REAL(Hamij,dp)
!                    GraphRhoMat(i,1)=GraphRhoMat(1,i)
!
!!Then find connection to other determinants
!                    do j=2,(i-1)
!                        Hamij=GetHElement2(nJ,DetsInGraph(:,j),NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,-1,ECore)
!                        GraphRhoMat(i,j)=-Tau*REAL(Hamij,dp)
!                        GraphRhoMat(j,i)=GraphRhoMat(i,j)
!                    enddo
!
!!Find diagonal element
!                    Hamii=GetHElement2(nJ,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,0,ECore)
!!                GraphRhoMat(i,i)=1.D0-(Tau*((REAL(Hamii,dp)-REAL(Hii,dp))-(DiagSft/REAL(RhoApp,dp))))
!                    GraphRhoMat(i,i)=1.D0-Tau*((REAL(Hamii,dp)-REAL(Hii,dp))-DiagSft)
!
!                    i=i+1   !increment the excit counter
!                    Attempts=0      !Reset the attempts counter
!
!                ENDIF
!
!            enddo
!
!        ENDIF
!
!        RETURN
!
!    END SUBROUTINE CreateGraph
!
!
!!This is the heart of FCIMC, where the MC Cycles are performed
!    SUBROUTINE PerformFCIMCyc()
!        IMPLICIT NONE
!        INTEGER :: VecSlot,i,j,k,l,DetCurr(NEl),iMaxExcit,nExcitMemLen,nStore(6)
!        INTEGER :: nJ(NEl),ierr,nExcitTag=0,IC,Child,TotWalkersNew,iCount
!        type(timer), save :: proc_timercyc
!        REAL*8 :: Prob,rat,Kik
!        INTEGER , ALLOCATABLE :: nExcit(:)
!        INTEGER :: iDie             !Indicated whether a particle should self-destruct on DetCurr
!        LOGICAL :: WSign
!        LOGICAL :: KeepOrig
!        INTEGER :: CreateAtI,CreateAtJ,tocopy
!        CHARACTER(len=*), PARAMETER :: this_routine='PerformFCIMCyc'
!
!        proc_timerCyc%timer_name='MCyc'
!        call set_timer(proc_timerCyc)
!
!!VecSlot indicates the next free position in NewDets
!        VecSlot=1
!
!        do j=1,TotWalkers
!!j runs through all current walkers
!            do k=1,NEl
!                DetCurr(k)=CurrentDets(k,j)
!            enddo
!
!!Setup excit generators for this determinant (This can be reduced to an order N routine later for abelian symmetry.
!            iMaxExcit=0
!            nStore(1:6)=0
!            CALL GenSymExcitIt2(DetCurr,NEl,G1,nBasis,nBasisMax,.TRUE.,nExcitMemLen,nJ,iMaxExcit,0,nStore,exFlag)
!            ALLOCATE(nExcit(nExcitMemLen),stat=ierr)
!            CALL LogMemAlloc('nExcit',nExcitMemLen,4,this_routine,nExcitTag,ierr)
!            nExcit(1)=0
!            CALL GenSymExcitIt2(DetCurr,NEl,G1,nBasis,nBasisMax,.TRUE.,nExcit,nJ,iMaxExcit,0,nStore,exFlag)
!
!            IF(TMCExcitSpace) THEN
!!Excitations are picked stochastically
!
!                do i=1,NoMCExcits
!
!                    CALL GenRandSymExcitIt3(DetCurr,nExcit,nJ,Seed,IC,Prob,iCount)
!
!                    Child=AttemptCreate(DetCurr,CurrentSign(j),nJ,Prob,IC,Kik)
!!Kik is the off-diagonal hamiltonian matrix element for the walker. This is used for the augmentation of the death term if TDiffuse is on.
!                    IF(Child.gt.0) THEN
!!We have successfully created at least one positive child at nJ
!                        WSign=.true.
!                    ELSE
!!We have successfully created at least one negative child at nJ
!                        WSign=.false.
!                    ENDIF
!                    do l=1,abs(Child)
!                        do k=1,NEl
!                            NewDets(k,VecSlot)=nJ(k)
!                        enddo
!                        NewSign(VecSlot)=WSign
!                        VecSlot=VecSlot+1
!                    enddo
!
!                enddo
!
!            ELSE
!!Run through all possible excitations of each walker
!
!                CALL ResetExIt2(DetCurr,NEl,G1,nBasis,nBasisMax,nExcit,0)
!
!                do while(.true.)
!                    CALL GenSymExcitIt2(DetCurr,NEl,G1,nBasis,nBasisMax,.FALSE.,nExcit,nJ,IC,0,nStore,exFlag)
!                    IF(nJ(1).eq.0) EXIT
!
!                    Child=AttemptCreate(DetCurr,CurrentSign(j),nJ,1.D0,IC,Kik)
!!Kik is the off-diagonal hamiltonian matrix element for the walker. This is used for the augmentation of the death term if TDiffuse is on.
!                    IF(Child.gt.0) THEN
!!We have successfully created at least one positive child at nJ
!                        WSign=.true.
!                    ELSE
!!We have successfully created at least one negative child at nJ
!                        WSign=.false.
!                    ENDIF
!                    do l=1,abs(Child)
!                        do k=1,NEl
!                            NewDets(k,VecSlot)=nJ(k)
!                        enddo
!                        NewSign(VecSlot)=WSign
!                        VecSlot=VecSlot+1
!                    enddo
!
!                enddo
!
!            ENDIF
!
!            KeepOrig=.true.
!            IF(TDiffuse) THEN
!!Next look at possibility of diffusion to another determinant
!                CALL GenRandSymExcitIt3(DetCurr,nExcit,nJ,Seed,IC,Prob,iCount)
!                CALL AttemptDiffuse(DetCurr,nJ,Prob,IC,CurrentSign(j),KeepOrig,CreateAtI,CreateAtJ)
!                !If we want to keep the original walker, then KeepOrig is true, However, we do not want to copy it accross yet, because we want to see if it is killed first in the birth/death process
!!                IF(KeepOrig) THEN
!!                    do k=1,NEl
!!                        NewDets(k,VecSlot)=DetCurr(k)
!!                    enddo
!!                    NewSign(VecSlot)=CurrentSign(j)
!!                    VecSlot=VecSlot+1
!!                ENDIF
!                do l=1,abs(CreateAtI)       !Sum in the number of walkers to create at the original determinant
!                    do k=1,NEl
!                        NewDets(k,VecSlot)=DetCurr(k)
!                    enddo
!                    IF(CreateAtI.gt.0) THEN
!                        NewSign(VecSlot)=.true.
!                    ELSE
!                        NewSign(VecSlot)=.false.
!                    ENDIF
!                    VecSlot=VecSlot+1
!                enddo
!                do l=1,abs(CreateAtJ)       !Add the number of walkers to create at nJ
!                    do k=1,NEl
!                        NewDets(k,VecSlot)=nJ(k)
!                    enddo
!                    IF(CreateAtJ.gt.0) THEN
!                        NewSign(VecSlot)=.true.
!                    ELSE
!                        NewSign(VecSlot)=.false.
!                    ENDIF
!                    VecSlot=VecSlot+1
!                enddo
!            ENDIF
!
!!We now have to decide whether the parent particle (j) wants to self-destruct or not...
!            iDie=AttemptDie(DetCurr,Kik,nExcitMemLen,nExcit,nStore)
!!iDie can be positive to indicate the number of deaths, or negative to indicate the number of births
!
!            IF(iDie.le.0) THEN
!!This indicates that the particle is spared and we may want to create more...copy them across to NewDets
!!If iDie < 0, then we are creating the same particles multiple times. Copy accross (iDie+1) copies of particle
!
!                IF(KeepOrig) THEN
!                    ToCopy=abs(iDie)+1  !This is because we need to copy accross the original particle too
!                ELSE
!                    IF(iDie.eq.0) THEN
!                        ToCopy=0        !Indicates that want to spare original particle, which has already been copied accross previously, or previously been annihilated
!                    ELSE
!                        ToCopy=abs(iDie)
!                    ENDIF
!                ENDIF
!
!                do l=1,ToCopy    !We need to copy accross one more, since we need to include the original spared particle
!                    do k=1,NEl
!                        NewDets(k,VecSlot)=DetCurr(k)
!                    enddo
!                    NewSign(VecSlot)=CurrentSign(j)
!                    VecSlot=VecSlot+1
!                enddo
!
!            ELSEIF(iDie.gt.0) THEN
!!This indicates that particles on DetCurr want to be killed. The first kill will simply be performed by not copying accross the original particle.
!!Therefore, if iDie = 1, then we can simply ignore it.
!!However, after that anti-particles will need to be created on the same determinant.
!
!                IF(KeepOrig) iDie=iDie-1
!!This is because we can already kill one particle by not copying accross the particle which was originally there (and still is even after diffusion).
!!If KeepOrig is false, then the particle has already diffused somewhere else, and so antiparticles need to be created in its place.
!
!                do l=1,iDie
!                    do k=1,NEl
!                        NewDets(k,VecSlot)=DetCurr(k)
!                    enddo
!                    IF(CurrentSign(j)) THEN
!!Copy accross new anti-particles
!                        NewSign(VecSlot)=.FALSE.
!                    ELSE
!                        NewSign(VecSlot)=.TRUE.
!                    ENDIF
!                    VecSlot=VecSlot+1
!                enddo
!
!            ENDIF
!
!!Destroy excitation generators for current walker
!            DEALLOCATE(nExcit)
!            CALL LogMemDealloc(this_routine,nExcitTag)
!
!!            rat=(VecSlot+0.D0)/(MaxWalkers+0.D0)
!!            IF(rat.gt.0.9) THEN
!!                WRITE(6,*) "*WARNING* - Number of walkers has increased to over 90% of MaxWalkers"
!!            ENDIF
!
!!Finish cycling over walkers
!        enddo
!
!!Since VecSlot holds the next vacant slot in the array, TotWalkersNew will be one less than this.
!        TotWalkersNew=VecSlot-1
!        rat=(TotWalkersNew+0.D0)/(MaxWalkers+0.D0)
!        IF(rat.gt.0.9) THEN
!            WRITE(6,*) "*WARNING* - Number of walkers has increased to over 90% of MaxWalkers"
!        ENDIF
!
!        IF(TNodalCutoff.and.(NodalCutoff.lt.0.D0)) THEN
!!If TNodalCutoff is set, then we are imposing a nodal boundary on the wavevector - if the MP1 wavefunction has a component which is larger than a NodalCutoff
!!then the net number of walkers must be the same sign, or it is set to zero walkers, and they are killed.
!            CALL TestWavevectorNodes(TotWalkersNew,2)
!        ENDIF
!
!        IF(TNoAnnihil) THEN
!!We are not annihilating particles - this will make things much quicker.
!
!!However, we now need to swap around the pointers of CurrentDets and NewDets, since this was done previously explicitly in the annihilation routine
!            IF(associated(CurrentDets,target=WalkVecDets)) THEN
!                CurrentDets=>WalkVec2Dets
!                CurrentSign=>WalkVec2Sign
!                NewDets=>WalkVecDets
!                NewSign=>WalkVecSign
!            ELSE
!                CurrentDets=>WalkVecDets
!                CurrentSign=>WalkVecSign
!                NewDets=>WalkVec2Dets
!                NewSign=>WalkVec2Sign
!            ENDIF
!
!            TotWalkers=TotWalkersNew
!
!        ELSE
!!This routine now cancels down the particles with opposing sign on each determinant
!!This routine does not necessarily need to be called every Iter, but it does at the moment, since it is the only way to
!!transfer the residual particles back onto CurrentDets
!            CALL AnnihilatePairs(TotWalkersNew)
!!            WRITE(6,*) "Number of annihilated particles= ",TotWalkersNew-TotWalkers
!        ENDIF
!
!
!        IF(TNodalCutoff.and.(NodalCutoff.ge.0.D0)) THEN
!!If TNodalCutoff is set, then we are imposing a nodal boundary on the wavevector - if the MP1 wavefunction has a component which is larger than a NodalCutoff
!!then the net number of walkers must be the same sign, or it is set to zero walkers, and they are killed.
!            CALL TestWavevectorNodes(TotWalkers,1)
!        ENDIF
!
!
!        IF(TotWalkers.gt.(InitWalkers*GrowMaxFactor)) THEN
!!Particle number is too large - kill them randomly
!
!!Log the fact that we have made a cull
!            NoCulls=NoCulls+1
!            IF(NoCulls.gt.10) CALL Stop_All("PerformFCIMCyc","Too Many Culls")
!!CullInfo(:,1) is walkers before cull
!            CullInfo(NoCulls,1)=TotWalkers
!!CullInfo(:,3) is MC Steps into shift cycle before cull
!            CullInfo(NoCulls,3)=mod(Iter,StepsSft)
!
!            WRITE(6,"(A,F8.2,A)") "Total number of particles has grown to ",GrowMaxFactor," times initial number..."
!            WRITE(6,"(A,I12,A)") "Killing randomly selected particles in cycle ", Iter," in order to reduce total number..."
!            WRITE(6,"(A,F8.2)") "Population will reduce by a factor of ",CullFactor
!            CALL ThermostatParticles(.true.)
!
!!Need to reduce totwalkersOld, so that the change in shift is also reflected by this
!!The Shift is no longer calculated like this...
!!            TotWalkersOld=nint((TotWalkersOld+0.D0)/CullFactor)
!
!        ELSEIF((TotWalkers.lt.(InitWalkers/2)).and.(.NOT.TNoBirth)) THEN
!!Particle number is too small - double every particle in its current position
!
!!Log the fact that we have made a cull
!            NoCulls=NoCulls+1
!            IF(NoCulls.gt.10) CALL Stop_All("PerformFCIMCyc","Too Many Culls")
!!CullInfo(:,1) is walkers before cull
!            CullInfo(NoCulls,1)=TotWalkers
!!CullInfo(:,3) is MC Steps into shift cycle before cull
!            CullInfo(NoCulls,3)=mod(Iter,StepsSft)
!
!            WRITE(6,*) "Doubling particle population to increase total number..."
!            CALL ThermostatParticles(.false.)
!
!!Need to increase TotWalkersOld, so that the change in shift is also reflected by this
!!The shift is no longer calculated like this...
!!            TotWalkersOld=TotWalkersOld*2
!
!        ENDIF
!
!        call halt_timer(proc_timerCyc)
!
!        RETURN
!
!    END SUBROUTINE PerformFCIMCyc
!
!!If TNodalCutoff is set, then we are imposing a nodal boundary on the wavevector - if the MP1 wavefunction has a component which is larger than a NodalCutoff,
!!then the walkers at that determinant must be of the same sign, or they are killed.
!!Particles indicates the number of particles to look through, and iArray is 1 if the WalkVecDets array is active, and 2 if the WalkVec2Dets array is active.
!    SUBROUTINE TestWavevectorNodes(Particles,iArray)
!        use CalcData , only : i_P
!        use SystemData , only : Beta
!        use IntegralsData , only : nTay
!        IMPLICIT NONE
!        INTEGER :: ParticlesOrig,VecSlot,IC,iGetExcitLevel,j,k,NoatHF,Particles,iArray,NoPositive,NoNegative
!        INTEGER , POINTER :: ActiveVecDets(:,:)
!        LOGICAL , POINTER :: ActiveVecSign(:)
!        REAL*8 :: EigenComp,EnergyNum
!        LOGICAL :: Component
!        HElement_t :: Hamij,Fj!,rhjj,rhij
!
!!We first need to point to the active array
!        IF(iArray.eq.1) THEN
!            ActiveVecDets => CurrentDets
!            ActiveVecSign => CurrentSign
!        ELSEIF(iArray.eq.2) THEN
!            ActiveVecDets => NewDets
!            ActiveVecSign => NewSign
!        ELSE
!            CALL Stop_All("TestWavevectorNodes","Error with iArray")
!        ENDIF
!
!        EnergyNum=0.D0  !EnergyNum indicates the sum over all the hamiltonian matrix elements between the double excitations and HF
!        NoatHF=0
!        NoPositive=0    !Total number of positive particles
!        NoNegative=0    !Total number of negative particles
!
!        ParticlesOrig=Particles
!!VecSlot indicates the next free position in ActiveVec
!        VecSlot=1
!
!        do j=1,Particles
!!j runs through all current walkers
!!IC labels the excitation level away from the HF determinant
!            IC=iGetExcitLevel(FDet,ActiveVecDets(:,j),NEl)
!
!            IF((IC.gt.2).or.(IC.eq.1)) THEN
!!More than double excitations/singles are not included in the MP1 wavefunction, therefore we can copy these straight across
!                IF(VecSlot.lt.j) THEN
!!Only copy accross to VecSlot if VecSlot<j, otherwise, if VecSlot=j, particle already in right place.
!                    do k=1,NEl
!                        ActiveVecDets(k,VecSlot)=ActiveVecDets(k,j)
!                    enddo
!                    ActiveVecSign(VecSlot)=ActiveVecSign(j)
!                ENDIF
!                VecSlot=VecSlot+1
!
!                IF(ActiveVecSign(j)) THEN
!                    NoPositive=NoPositive+1
!                ELSE
!                    NoNegative=NoNegative+1
!                ENDIF
!
!            ELSEIF((IC.eq.2).or.(IC.eq.0)) THEN
!                IF(IC.eq.2) THEN
!!We are at a double excitation - first find the desired sign of the determinant.
!                    Hamij=GetHElement2(FDet,ActiveVecDets(:,j),NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,IC,ECore)
!                    IF((real(Hamij)).lt.0) THEN
!!Negative Hamiltonian connection indicates that the component of the MP1 wavevector is positive
!                        Component=.true.
!                    ELSE
!                        Component=.false.
!                    ENDIF
!                ELSE
!!We are at the HF determinant
!                    Hamij=Hii
!                    Component=.true.    !HF component of MP1 wavevector always wants to be positive
!                ENDIF
!
!                IF((ActiveVecSign(j).and.Component).or.((.NOT.ActiveVecSign(j)).and.(.NOT.Component))) THEN
!!The particle is of the same sign as the MP1 wavevector component, so whether or not the determinant is of fixed sign, the particle does not want to be destroyed
!                    IF(VecSlot.lt.j) THEN
!!Only copy accross to VecSlot if VecSlot<j, otherwise, if VecSlot=j, particle already in right place.
!                        do k=1,NEl
!                            ActiveVecDets(k,VecSlot)=ActiveVecDets(k,j)
!                        enddo
!                        ActiveVecSign(VecSlot)=ActiveVecSign(j)
!                    ENDIF
!                    VecSlot=VecSlot+1
!
!!Add to the estimate for the energy if we want to keep the particle
!                    IF(ActiveVecSign(j)) THEN
!                        IF(Iter.gt.NEquilSteps) EnergyNum=EnergyNum+(REAL(Hamij,dp))
!                        NoPositive=NoPositive+1
!                    ELSE
!                        IF(Iter.gt.NEquilSteps) EnergyNum=EnergyNum-(REAL(Hamij,dp))
!                        NoNegative=NoNegative+1
!                    ENDIF
!                    IF(IC.eq.0) THEN
!                        IF(ActiveVecSign(j)) THEN
!                            IF(Iter.gt.NEquilSteps) NoatHF=NoatHF+1
!                        ELSE
!                            IF(Iter.gt.NEquilSteps) NoatHF=NoatHF-1
!                        ENDIF
!                    ENDIF
!
!                ELSE
!!Particle is of a different sign to the component of the MP1 wavefunction - if the determinant is of fixed sign, we don't want to copy it across. Find if fixed sign...
!                    IF(IC.eq.2) THEN
!                        CALL GetH0Element(ActiveVecDets(:,j),NEl,Arr,nBasis,ECore,Fj)
!!EigenComp is now the component of the normalised MP1 wavefunction for the double excitation WalkVecDets(:,j)
!                        EigenComp=abs(((Hamij)/(Fj-FZero))/MPNorm)
!                    ELSE
!!Here, EigenComp is the component of the normalised MP1 wavefunction at the HF determinant (should always be +ve)
!                        EigenComp=1.D0/MPNorm
!                    ENDIF
!
!                    IF(EigenComp.lt.abs(NodalCutoff)) THEN
!!Determinant does not have a fixed sign - keep the particle
!                        IF(VecSlot.lt.j) THEN
!!Only copy accross to VecSlot if VecSlot<j, otherwise, if VecSlot=j, particle already in right place.
!                            do k=1,NEl
!                                ActiveVecDets(k,VecSlot)=ActiveVecDets(k,j)
!                            enddo
!                            ActiveVecSign(VecSlot)=ActiveVecSign(j)
!                        ENDIF
!                        VecSlot=VecSlot+1
!
!!Add to the estimate for the energy if we want to keep the particle
!                        IF(ActiveVecSign(j)) THEN
!                            IF(Iter.gt.NEquilSteps) EnergyNum=EnergyNum+(REAL(Hamij,dp))
!                            NoPositive=NoPositive+1
!                        ELSE
!                            IF(Iter.gt.NEquilSteps) EnergyNum=EnergyNum-(REAL(Hamij,dp))
!                            NoNegative=NoNegative+1
!                        ENDIF
!                        IF(IC.eq.0) THEN
!                            IF(ActiveVecSign(j)) THEN
!                                IF(Iter.gt.NEquilSteps) NoatHF=NoatHF+1
!                            ELSE
!                                IF(Iter.gt.NEquilSteps) NoatHF=NoatHF-1
!                            ENDIF
!                        ENDIF
!
!                    ENDIF
!                ENDIF
!            ELSE
!                CALL Stop_All("TestWavevectorNodes","Should not be here - wrong IC calculated")
!            ENDIF
!        enddo   !end loop over all walkers
!
!!Total number of particles now modified by killing of wrong signed particles
!        Particles=VecSlot-1
!
!        IF((ParticlesOrig-Particles).ne.0) THEN
!            WRITE(6,*) "Some particles killed by Nodal approximation: ", ParticlesOrig-Particles
!        ENDIF
!
!!Calculate the time average of the numerator and demonimator to calculate the running average of the energy - this will then not be affected by the case when there aren't any particles at the HF determinant
!        SumNoatHF=SumNoatHF+NoatHF
!        SumENum=SumENum+EnergyNum
!        ProjectionE=(SumENum/(SumNoatHF+0.D0))-REAL(Hii,dp)
!
!        IF(NoatHF.ne.0) THEN
!!The energy cannot be calculated via the projection back onto the HF if there are no particles at HF
!            SumE=SumE+((EnergyNum/(NoatHF+0.D0))-(REAL(Hii,dp)))
!            ProjectionEInst=SumE/((Iter-CycwNoHF)+0.D0)
!        ELSE
!            CycwNoHF=CycwNoHF+1         !Record the fact that there are no particles at HF in this run, so we do not bias the average
!!            WRITE(6,*) "No positive particles at reference determinant during iteration: ",Iter
!        ENDIF
!
!        NetPositive=NoPositive-NoNegative
!!        WRITE(6,*) ParticlesOrig,Particles,NetPositive,NoPositive,NoNegative
!
!        RETURN
!
!    END SUBROUTINE TestWavevectorNodes
!
!!This routine acts as a thermostat for the simulation - killing random particles if the population becomes too large, or
!!Doubling them if it gets too low...
!    SUBROUTINE ThermostatParticles(HighLow)
!        IMPLICIT NONE
!        LOGICAL :: HighLow
!        INTEGER :: VecSlot,i,j,ToCull,Culled,OrigWalkers,Chosen
!        REAL*8 :: Ran2
!
!        IF(HighLow) THEN
!!The population is too large - cull TotWalkers/CullFactor randomly selected particles
!
!            OrigWalkers=TotWalkers
!            ToCull=TotWalkers-nint((TotWalkers+0.D0)/CullFactor)
!            Culled=0
!
!            do while (Culled.lt.ToCull)
!
!!Pick a random walker between 1 and TotWalkers
!                Chosen=int((Ran2(Seed)*TotWalkers)+1.D0)
!
!!Move the Walker at the end of the list to the position of the walker we have chosen to destroy
!                do i=1,NEl
!                    CurrentDets(i,Chosen)=CurrentDets(i,TotWalkers)
!                enddo
!                CurrentSign(Chosen)=CurrentSign(TotWalkers)
!
!                TotWalkers=TotWalkers-1
!                Culled=Culled+1
!
!            enddo
!
!            IF(TotWalkers.ne.(OrigWalkers-ToCull)) THEN
!                WRITE(6,*) "Error in culling walkers..."
!                STOP "Error in culling walkers..."
!            ENDIF
!
!!CullInfo(:,2) is the new number of total walkers
!            CullInfo(NoCulls,2)=TotWalkers
!
!        ELSE
!!The population is too low - give it a boost by doubling every particle
!
!            VecSlot=TotWalkers+1
!            do i=1,TotWalkers
!
!!Add clone of walker, at the same determinant, to the end of the list
!                do j=1,NEl
!                    CurrentDets(j,VecSlot)=CurrentDets(j,i)
!                enddo
!                CurrentSign(VecSlot)=CurrentSign(i)
!
!                VecSlot=VecSlot+1
!
!            enddo
!
!            TotWalkers=TotWalkers*2
!
!            IF((VecSlot-1).ne.TotWalkers) THEN
!                WRITE(6,*) "Problem in doubling all particles..."
!                STOP "Problem in doubling all particles..."
!            ENDIF
!
!!CullInfo(:,2) is the new number of total walkers
!            CullInfo(NoCulls,2)=TotWalkers
!
!        ENDIF
!
!        RETURN
!
!    END SUBROUTINE ThermostatParticles
!
!
!!This routine looks at the change in residual particle number over a number of cycles, and adjusts the
!!value of the diagonal shift in the hamiltonian in order to compensate for this
!    SUBROUTINE UpdateDiagSft()
!        IMPLICIT NONE
!        INTEGER :: j,k,GrowthSteps
!
!        IF(NoCulls.eq.0) THEN
!            GrowRate=(TotWalkers+0.D0)/(TotWalkersOld+0.D0)
!        ELSEIF(NoCulls.eq.1) THEN
!!GrowRate is the sum of the individual grow rates for each uninterrupted growth sequence, multiplied by the fraction of the cycle which was spent on it
!            GrowRate=((CullInfo(1,3)+0.D0)/(StepsSft+0.D0))*((CullInfo(1,1)+0.D0)/(TotWalkersOld+0.D0))
!            GrowRate=GrowRate+(((StepsSft-CullInfo(1,3))+0.D0)/(StepsSft+0.D0))*((TotWalkers+0.D0)/(CullInfo(1,2)+0.D0))
!
!            NoCulls=0
!            CullInfo=0
!        ELSE
!            GrowRate=((CullInfo(1,3)+0.D0)/(StepsSft+0.D0))*((CullInfo(1,1)+0.D0)/(TotWalkersOld+0.D0))
!            do j=2,NoCulls
!
!!This is needed since the steps between culling is stored cumulatively
!                GrowthSteps=CullInfo(j,3)-CullInfo(j-1,3)
!                GrowRate=GrowRate+((GrowthSteps+0.D0)/(StepsSft+0.D0))*((CullInfo(j,1)+0.D0)/(CullInfo(j-1,2)+0.D0))
!
!            enddo
!
!            GrowthSteps=StepsSft-CullInfo(NoCulls,3)
!            GrowRate=GrowRate+((GrowthSteps+0.D0)/(StepsSft+0.D0))*((TotWalkers+0.D0)/(CullInfo(NoCulls,2)+0.D0))
!
!            NoCulls=0
!            CullInfo(1:30)=0
!
!        ENDIF
!        DiagSft=DiagSft-(log(GrowRate)*SftDamp)/(Tau*(StepsSft+0.D0))
!!        IF((DiagSft).gt.0.D0) THEN
!!            WRITE(6,*) "***WARNING*** - DiagSft trying to become positive..."
!!            STOP
!!        ENDIF
!
!    END SUBROUTINE UpdateDiagSft
!
!
!!This routine cancels out particles of opposing sign on the same determinant.
!    SUBROUTINE AnnihilatePairs(TotWalkersNew)
!        IMPLICIT NONE
!        INTEGER :: TotWalkersNew,j,k,l,DetCurr(NEl),VecSlot,TotWalkersDet
!        INTEGER :: DetLT
!
!!First, it is necessary to sort the list of determinants
!        CALL SortDets(TotWalkersNew,NewDets(:,1:TotWalkersNew),NEl,NewSign(1:TotWalkersNew),1)
!
!!Once ordered, each block of walkers on similar determinants can be analysed, and the residual walker concentration moved to CurrentDets
!        j=1
!!j is the counter over all uncancelled walkers - it indicates when we have reached the end of the list of total walkers
!        do k=1,NEl
!!DetCurr is the current determinant
!            DetCurr(k)=NewDets(k,j)
!        enddo
!        VecSlot=1
!
!        do while(j.le.TotWalkersNew)
!!Loop over all walkers
!            TotWalkersDet=0
!            do while ((DetLT(NewDets(:,j),DetCurr,NEl).eq.0).and.(j.le.TotWalkersNew))
!!Loop over all walkers on DetCurr and count residual number after cancelling
!                IF(NewSign(j)) THEN
!                    TotWalkersDet=TotWalkersDet+1
!                ELSE
!                    TotWalkersDet=TotWalkersDet-1
!                ENDIF
!                j=j+1
!            enddo
!!Transfer residual population into VecSlot, along with residual sign
!            IF(TotWalkersDet.gt.0) THEN
!!Positive sign particles want to populate this determinant
!                do l=1,abs(TotWalkersDet)
!                    do k=1,NEl
!                        CurrentDets(k,VecSlot)=DetCurr(k)
!                    enddo
!                    CurrentSign(VecSlot)=.true.
!                    VecSlot=VecSlot+1
!                enddo
!            ELSE
!!Negative sign particles want to populate this determinant
!                do l=1,abs(TotWalkersDet)
!                    do k=1,NEl
!                        CurrentDets(k,VecSlot)=DetCurr(k)
!                    enddo
!                    CurrentSign(VecSlot)=.false.
!                    VecSlot=VecSlot+1
!                enddo
!            ENDIF
!!Now update the current determinant
!            do k=1,NEl
!                DetCurr(k)=NewDets(k,j)
!            enddo
!        enddo
!!The new number of residual cancelled walkers is given by one less that VecSlot again.
!        TotWalkers=VecSlot-1
!
!        RETURN
!
!    END SUBROUTINE AnnihilatePairs
!
!!This routine calculates the MP1 eigenvector, and uses it as a guide for setting the initial walker configuration
!    SUBROUTINE StartWavevector(WaveType)
!        use CalcData , only : i_P
!        use SystemData , only : Beta
!        use IntegralsData , only : nTay
!        IMPLICIT NONE
!        INTEGER :: ierr,i,j,WaveType,EigenvectorTag=0,k,VecSlot,NoDoublesWalk
!        CHARACTER(len=*), PARAMETER :: this_routine='StartWavevector'
!        REAL*8 :: TypeChange,SumComp,GrowFactor
!        INTEGER :: nStore(6),nExcitMemLen,nJ(NEl),iMaxExcit,nExcitTag=0,iExcit,WalkersOnDet
!        INTEGER , ALLOCATABLE :: nExcit(:)
!        REAL*8 , ALLOCATABLE :: Eigenvector(:)
!        HElement_t :: rhij,rhjj,Hamij,Fj,MP2E
!
!        IF((WaveType.eq.1).or.(WaveType.eq.2)) THEN
!!If WaveType=1, we want to calculate the MP1 wavevector as our initial configuration, and WaveType=2 is the star wavevector
!
!            IF(WaveType.eq.1) THEN
!!For MP1 wavefunction, we want TypeChange=1.D0, but star will require the star correlation energy
!                TypeChange=1.D0
!            ELSEIF(WaveType.eq.2) THEN
!!Star energy not yet proparly coded & tested
!                STOP 'Star initial wavefunction not yet working'
!!                StarWeight=fMCPR3StarNewExcit(FDet,Beta,i_P,NEl,nBasisMax,G1,nBasis,nMsh,fck,Arr,ALat,UMat,nTay,RhoEps,iExcit,iMaxExcit,nWHTay,iLogging,TSym,ECore,DBeta,DLWDB,MP2E)
!!                TypeChange=DLWDB
!            ENDIF
!
!            MP2E=0.D0
!
!!First, generate all excitations, and store their determianants, and rho matrix elements
!            nStore(1)=0
!            CALL GenSymExcitIt2(FDet,NEl,G1,nBasis,nBasisMax,.TRUE.,nExcitMemLen,nJ,iMaxExcit,0,nStore,exFlag)
!            ALLOCATE(nExcit(nExcitMemLen),stat=ierr)
!            CALL LogMemAlloc('nExcit',nExcitMemLen,4,this_routine,nExcitTag,ierr)
!            nExcit(1)=0
!            CALL GenSymExcitIt2(FDet,NEl,G1,nBasis,nBasisMax,.TRUE.,nExcit,nJ,iMaxExcit,0,nStore,exFlag)
!
!            ALLOCATE(Eigenvector(iMaxExcit+1),stat=ierr)
!            CALL LogMemAlloc('Eigenvector',iMaxExcit+1,8,this_routine,EigenvectorTag,ierr)
!            Eigenvector=0.d0
!
!!Also need to store the determinants which each component of the eigenvector refers to...
!            ALLOCATE(ExcitStore(NEl,iMaxExcit+1),stat=ierr)
!            CALL LogMemAlloc('ExcitStore',(iMaxExcit+1)*NEl,4,this_routine,ExcitStoreTag,ierr)
!            ExcitStore(1:nEl,1:iMaxExcit+1)=0
!
!!            CALL CalcRho2(FDet,FDet,Beta,i_P,NEl,nBasisMax,G1,nBasis,Brr,nMsh,fck,Arr,ALat,UMat,rhii,nTay,0,ECore)
!            CALL GetH0Element(FDet,NEl,Arr,nBasis,ECore,FZero)
!
!            i=1
!            do j=1,NEl
!                ExcitStore(j,i)=FDet(j)
!            enddo
!            Eigenvector(i)=1.D0
!            SumComp=1.D0
!
!            do while (.true.)
!                CALL GenSymExcitIt2(FDet,NEl,G1,nBasis,nBasisMax,.false.,nExcit,nJ,iExcit,0,nStore,exFlag)
!                IF(nJ(1).eq.0) EXIT
!                i=i+1
!!                CALL CalcRho2(FDet,nJ,Beta,i_P,NEl,nBasisMax,G1,nBasis,Brr,nMsh,fck,Arr,ALat,UMat,rhij,nTay,iExcit,ECore)
!!                CALL CalcRho2(nJ,nJ,Beta,i_P,NEl,nBasisMax,G1,nBasis,Brr,nMsh,fck,Arr,ALat,UMat,rhjj,nTay,0,ECore)
!
!!We want the value of rho_jj/rho_ii
!!                rhjj=rhjj/rhii
!                Hamij=GetHElement2(FDet,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,iExcit,ECore)
!                CALL GetH0Element(nJ,NEl,Arr,nBasis,ECore,Fj)
!
!                do j=1,NEl
!                    ExcitStore(j,i)=nJ(j)
!                enddo
!!                Eigenvector(i)=(rhij)/((rhjj)-TypeChange)
!                MP2E=MP2E-((Hamij)**2)/((Fj)-(FZero))
!                Eigenvector(i)=(Hamij)/(Fj-FZero)
!                SumComp=SumComp+Eigenvector(i)
!            enddo
!
!            NoComps=i
!
!            WRITE(6,*) "Number of components found for new starting wavevector: ",NoComps
!
!            DEALLOCATE(nExcit)
!            CALL LogMemDealloc(this_routine,nExcitTag)
!
!            DiagSft=real(MP2E,KIND(0.D0))
!
!        ENDIF
!
!        GrowFactor=(InitWalkers+0.D0)/SumComp
!
!        WRITE(6,*) "Growth factor of initial wavevector is: ",GrowFactor
!
!!Find actual number of new initial walkers
!        NoDoublesWalk=0
!        InitWalkers=0
!        do i=1,NoComps
!            WalkersOnDet=abs(nint(Eigenvector(i)*GrowFactor))
!            InitWalkers=InitWalkers+WalkersOnDet
!            IF(i.ne.1) THEN
!                NoDoublesWalk=NoDoublesWalk+WalkersOnDet
!            ENDIF
!        enddo
!
!        WRITE(6,*) "New number of initial walkers is: ",InitWalkers
!        WRITE(6,*) "Number of walkers on double excitations: ",NoDoublesWalk
!
!!Set the maximum number of walkers allowed
!        MaxWalkers=MemoryFac*InitWalkers
!
!!Allocate memory to hold walkers
!        ALLOCATE(WalkVecDets(NEl,MaxWalkers),stat=ierr)
!        CALL LogMemAlloc('WalkVecDets',MaxWalkers*NEl,4,this_routine,WalkVecDetsTag,ierr)
!        ALLOCATE(WalkVec2Dets(NEl,MaxWalkers),stat=ierr)
!        CALL LogMemAlloc('WalkVec2Dets',MaxWalkers*NEl,4,this_routine,WalkVec2DetsTag,ierr)
!        ALLOCATE(WalkVecSign(MaxWalkers),stat=ierr)
!        CALL LogMemAlloc('WalkVecSign',MaxWalkers,4,this_routine,WalkVecSignTag,ierr)
!        ALLOCATE(WalkVec2Sign(MaxWalkers),stat=ierr)
!        CALL LogMemAlloc('WalkVec2Sign',MaxWalkers,4,this_routine,WalkVec2SignTag,ierr)
!
!        CurrentDets=>WalkVecDets
!        CurrentSign=>WalkVecSign
!        NewDets=>WalkVec2Dets
!        NewSign=>WalkVec2Sign
!
!        VecSlot=1
!!Cycle over components
!        do i=1,NoComps
!!Cycle over number of initial walkers wanted in each component
!            IF(Eigenvector(i).gt.0.D0) THEN
!!Walkers in this determinant are positive
!                WalkersOnDet=abs(nint(Eigenvector(i)*GrowFactor))
!                do j=1,WalkersOnDet
!                    do k=1,NEl
!                        CurrentDets(k,VecSlot)=ExcitStore(k,i)
!                    enddo
!                    CurrentSign(VecSlot)=.true.
!                    VecSlot=VecSlot+1
!                enddo
!
!            ELSE
!                WalkersOnDet=abs(nint(Eigenvector(i)*GrowFactor))
!                do j=1,WalkersOnDet
!                    do k=1,NEl
!                        CurrentDets(k,VecSlot)=ExcitStore(k,i)
!                    enddo
!                    CurrentSign(VecSlot)=.false.
!                    VecSlot=VecSlot+1
!                enddo
!            ENDIF
!
!        enddo
!
!        IF((VecSlot-1).ne.InitWalkers) THEN
!            WRITE(6,*) "Problem in assigning particles proportionally to given wavevector..."
!            STOP "Problem in assigning particles proportionally to given wavevector..."
!        ENDIF
!
!        IF(TNoBirth) THEN
!!Allocate memory to hold all initial determinants and their starting populations
!            ALLOCATE(InitPops(NoComps),stat=ierr)
!            CALL LogMemAlloc('InitPops',NoComps,4,this_routine,InitPopsTag)
!
!            WRITE(6,*) ""
!            WRITE(6,*) "    Step   Components   WalkersOnDet   Expected"
!            WRITE(fcimcstats_unit,*) "#    Step   Components   WalkersOnDet   Expected"
!
!            do i=1,NoComps
!                InitPops(i)=abs(nint(Eigenvector(i)*GrowFactor))
!                WRITE(6,"(2I9,2G16.7)") 0,i,InitPops(i),InitPops(i)
!                WRITE(fcimcstats_unit,"(2I9,2G16.7)") 0,1,InitPops(i),InitPops(i)
!            enddo
!            WRITE(6,*) ""
!            WRITE(fcimcstats_unit,*) ""
!
!!Can deallocate the eigenvector, but we want to keep the ExcitStore in order to compare the populations at a later date
!            DEALLOCATE(Eigenvector)
!            CALL LogMemDealloc(this_routine,EigenvectorTag)
!
!        ELSE
!
!            DEALLOCATE(Eigenvector)
!            CALL LogMemDealloc(this_routine,EigenvectorTag)
!            DEALLOCATE(ExcitStore)
!            CALL LogMemDealloc(this_routine,ExcitStoreTag)
!
!        ENDIF
!
!        RETURN
!
!    END SUBROUTINE StartWavevector
!
!
!!This initialises the calculation, by allocating memory, setting up the initial walkers, and reading from a file if needed
!    SUBROUTINE InitFCIMCCalc()
!        USE DetCalc , only : NDet
!        IMPLICIT NONE
!        INTEGER :: ierr,i,j,k,l,DetCurr(NEl),ReadWalkers,TotWalkersDet
!        INTEGER :: DetLT,VecSlot
!        HElement_t :: rh
!        CHARACTER(len=*), PARAMETER :: this_routine='InitFCIMC'
!
!
!        IF(TStartMP1) THEN
!!Start the initial distribution off at the distribution of the MP1 eigenvector
!
!            WRITE(6,"(A)") "Starting run with particles populating double excitations proportionally to MP1 wavevector..."
!            CALL StartWavevector(1)
!
!        ELSEIF(TReadPops) THEN
!
!!Set the maximum number of walkers allowed
!            MaxWalkers=MemoryFac*InitWalkers
!
!!Allocate memory to hold walkers
!            ALLOCATE(WalkVecDets(NEl,MaxWalkers),stat=ierr)
!            CALL LogMemAlloc('WalkVecDets',MaxWalkers*NEl,4,this_routine,WalkVecDetsTag,ierr)
!            ALLOCATE(WalkVec2Dets(NEl,MaxWalkers),stat=ierr)
!            CALL LogMemAlloc('WalkVec2Dets',MaxWalkers*NEl,4,this_routine,WalkVec2DetsTag,ierr)
!            ALLOCATE(WalkVecSign(MaxWalkers),stat=ierr)
!            CALL LogMemAlloc('WalkVecSign',MaxWalkers,4,this_routine,WalkVecSignTag,ierr)
!            ALLOCATE(WalkVec2Sign(MaxWalkers),stat=ierr)
!            CALL LogMemAlloc('WalkVec2Sign',MaxWalkers,4,this_routine,WalkVec2SignTag,ierr)
!
!            CurrentDets=>WalkVecDets
!            CurrentSign=>WalkVecSign
!            NewDets=>WalkVec2Dets
!            NewSign=>WalkVec2Sign
!
!            IF((ABS(ScaleWalkers-1.D0)).lt.1.D-8) THEN
!!Read in walker positions
!                do i=1,InitWalkers
!                    READ(17,*) CurrentDets(:,i),CurrentSign(i)
!                enddo
!            ELSE
!!Read in walker positions - we will scale these later...
!                do i=1,InitWalkers
!                    READ(17,*) NewDets(:,i),NewSign(i)
!                enddo
!                WRITE(6,*) "Scaling number of walkers by: ",ScaleWalkers
!                ReadWalkers=InitWalkers
!                InitWalkers=0
!!First, count the total number of initial walkers on each determinant - sort into list
!                CALL SortDets(ReadWalkers,NewDets(:,1:ReadWalkers),NEl,NewSign(1:ReadWalkers),1)
!
!                j=1
!!j is the counter over all read in walkers - it indicates when we have reached the end of the entire list
!                do k=1,NEl
!!DetCurr is the current determinant
!                    DetCurr(k)=NewDets(k,j)
!                enddo
!
!                do while(j.le.ReadWalkers)
!!Loop over all walkers
!                    TotWalkersDet=0
!                    do while ((DetLT(NewDets(:,j),DetCurr,NEl).eq.0).and.(j.le.ReadWalkers))
!!Loop over all walkers on DetCurr and count residual number after cancelling
!                        IF(NewSign(j)) THEN
!                            TotWalkersDet=TotWalkersDet+1
!                        ELSE
!                            TotWalkersDet=TotWalkersDet-1
!                        ENDIF
!                        j=j+1
!                    enddo
!!Now update the current determinant
!                    do k=1,NEl
!                        DetCurr(k)=NewDets(k,j)
!                    enddo
!!Count total number of initial walkers
!                    InitWalkers=InitWalkers+abs(nint((TotWalkersDet+0.D0)*ScaleWalkers))
!                enddo
!                WRITE(6,*) "Total number of walkers is now: ",InitWalkers
!!Set the new maximum number of walkers allowed
!                MaxWalkers=MemoryFac*InitWalkers
!
!!Deallocate old memory block for WalkVec
!                DEALLOCATE(WalkVecDets)
!                CALL LogMemDealloc(this_routine,WalkVecDetsTag)
!                DEALLOCATE(WalkVecSign)
!                CALL LogMemDealloc(this_routine,WalkVecSignTag)
!
!!Allocate memory to hold new maximum number of walkers
!                ALLOCATE(WalkVecDets(NEl,MaxWalkers),stat=ierr)
!                CALL LogMemAlloc('WalkVecDets',MaxWalkers*NEl,4,this_routine,WalkVecDetsTag,ierr)
!                ALLOCATE(WalkVecSign(MaxWalkers),stat=ierr)
!                CALL LogMemAlloc('WalkVecSign',MaxWalkers,4,this_routine,WalkVecSignTag,ierr)
!
!                CurrentDets=>WalkVecDets
!                CurrentSign=>WalkVecSign
!
!!Now multiply them up...
!                j=1
!                VecSlot=1
!!j is the counter over all read in walkers - it indicates when we have reached the end of the entire list
!                do k=1,NEl
!                    DetCurr(k)=NewDets(k,j)
!                enddo
!!DetCurr is the current determinant
!                do while(j.le.ReadWalkers)
!!Loop over all walkers
!                    TotWalkersDet=0
!                    do while ((DetLT(NewDets(:,j),DetCurr,NEl).eq.0).and.(j.le.ReadWalkers))
!!Loop over all walkers on DetCurr and count residual number after cancelling
!                        IF(NewSign(j)) THEN
!                            TotWalkersDet=TotWalkersDet+1
!                        ELSE
!                            TotWalkersDet=TotWalkersDet-1
!                        ENDIF
!                        j=j+1
!                    enddo
!!Now multiply up the number of walkers, and insert into CurrentDets
!                    TotWalkersDet=nint((TotWalkersDet+0.D0)*ScaleWalkers)
!                    IF(TotWalkersDet.gt.0) THEN
!                        do l=1,abs(TotWalkersDet)
!                            do k=1,NEl
!                                CurrentDets(k,VecSlot)=DetCurr(k)
!                            enddo
!                            CurrentSign(VecSlot)=.true.
!                            VecSlot=VecSlot+1
!                        enddo
!                    ELSE
!                        do l=1,abs(TotWalkersDet)
!                            do k=1,NEl
!                                CurrentDets(k,VecSlot)=DetCurr(k)
!                            enddo
!                            CurrentSign(VecSlot)=.false.
!                            VecSlot=VecSlot+1
!                        enddo
!                    ENDIF
!                    do k=1,NEl
!                        DetCurr(k)=NewDets(k,j)
!                    enddo
!                enddo
!                IF((VecSlot-1).ne.InitWalkers) THEN
!                    WRITE(6,*) "Problem scaling up walker number - exiting..."
!                    STOP 'Problem scaling up walker number - exiting...'
!                ENDIF
!
!!Now deallocate and reallocate WalkVec2 with correct number of total walkers
!                DEALLOCATE(WalkVec2Dets)
!                CALL LogMemDealloc(this_routine,WalkVec2DetsTag)
!                DEALLOCATE(WalkVec2Sign)
!                CALL LogMemDealloc(this_routine,WalkVec2SignTag)
!                ALLOCATE(WalkVec2Dets(NEl,MaxWalkers),stat=ierr)
!                CALL LogMemAlloc('WalkVec2Dets',MaxWalkers*NEl,4,this_routine,WalkVec2DetsTag,ierr)
!                ALLOCATE(WalkVec2Sign(MaxWalkers),stat=ierr)
!                CALL LogMemAlloc('WalkVec2Sign',MaxWalkers,4,this_routine,WalkVec2SignTag,ierr)
!
!                NewDets=>WalkVec2Dets
!                NewSign=>WalkVec2Sign
!
!            ENDIF
!
!!End of reading in POPSFILE
!            CLOSE(17)
!
!        ELSE
!!If not reading in from POPSFILE, then we need to initialise the particle positions - start at HF with positive sign
!
!!Set the maximum number of walkers allowed
!            IF(TMCDiffusion) THEN
!                MaxWalkers=InitWalkers
!            ELSE
!                MaxWalkers=MemoryFac*InitWalkers
!            ENDIF
!
!!Allocate memory to hold walkers
!            ALLOCATE(WalkVecDets(NEl,MaxWalkers),stat=ierr)
!            CALL LogMemAlloc('WalkVecDets',MaxWalkers*NEl,4,this_routine,WalkVecDetsTag,ierr)
!            ALLOCATE(WalkVecSign(MaxWalkers),stat=ierr)
!            CALL LogMemAlloc('WalkVecSign',MaxWalkers,4,this_routine,WalkVecSignTag,ierr)
!
!            CurrentDets=>WalkVecDets
!            CurrentSign=>WalkVecSign
!
!            IF(.NOT.TMCDiffusion) THEN
!                ALLOCATE(WalkVec2Sign(MaxWalkers),stat=ierr)
!                CALL LogMemAlloc('WalkVec2Sign',MaxWalkers,4,this_routine,WalkVec2SignTag,ierr)
!                ALLOCATE(WalkVec2Dets(NEl,MaxWalkers),stat=ierr)
!                CALL LogMemAlloc('WalkVec2Dets',MaxWalkers*NEl,4,this_routine,WalkVec2DetsTag,ierr)
!                NewDets=>WalkVec2Dets
!                NewSign=>WalkVec2Sign
!            ENDIF
!
!            do j=1,InitWalkers
!                do k=1,NEl
!                    CurrentDets(k,j)=FDet(k)
!                enddo
!                CurrentSign(j)=.true.
!            enddo
!
!            IF(TNoBirth) THEN
!
!                WRITE(6,*) ""
!                WRITE(6,*) "    Step   Components   WalkersOnDet   Expected"
!                WRITE(fcimcstats_unit,*) "#    Step   Components   WalkersOnDet   Expected"
!
!                ALLOCATE(InitPops(1),stat=ierr)
!                CALL LogMemAlloc('InitPops',1,4,this_routine,InitPopsTag)
!                ALLOCATE(ExcitStore(NEl,1),stat=ierr)
!                CALL LogMemAlloc('ExcitStore',NEl,4,this_routine,ExcitStoreTag)
!
!                NoComps=1
!                do j=1,NEl
!                    ExcitStore(j,1)=FDet(j)
!                enddo
!                InitPops(1)=InitWalkers
!                WRITE(6,"(2I9,2G16.7)") 0,1,InitWalkers,InitWalkers
!                WRITE(fcimcstats_unit,"(2I9,2G16.7)") 0,1,InitWalkers,InitWalkers
!
!            ELSEIF(TDetPops) THEN
!
!                SizeofSpace=NDET
!                WRITE(6,*) "Size of space is: ", SizeOfSpace
!
!                ALLOCATE(PopsVec(SizeofSpace),stat=ierr)
!                CALL LogMemAlloc('PopsVec',SizeofSpace,8,this_routine,PopsVecTag)
!                PopsVec=0.d0
!                ALLOCATE(TransMat(SizeofSpace,SizeofSpace),stat=ierr)
!                CALL LogMemAlloc('TransMat',SizeofSpace**2,8,this_routine,TransMatTag)
!                TransMat=0.d0
!
!                IF(DetLT(NMRKS(:,1),FDet,NEl).ne.0) THEN
!                    WRITE(6,*) "Problem with NMRKS"
!                    STOP "Problem with NMRKS"
!                ENDIF
!
!                do j=1,SizeOfSpace
!                    rh=GetHElement2(FDet,NMRKS(:,j),NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,-1,ECore)
!                    WRITE(67,"(F10.5)",advance='no') rh
!                enddo
!                WRITE(67,*) ""
!                WRITE(67,*) ""
!
!            ENDIF
!
!        ENDIF
!
!!TotWalkers contains the number of current walkers at each step
!        TotWalkers=InitWalkers
!        TotWalkersOld=InitWalkers
!
!        CullInfo(1:30)=0
!        NoCulls=0
!
!        IF(TNodalCutoff.and.(.not.TMCDiffusion)) CALL CalcNodalSurface()
!
!        IF(TResumFciMC) THEN
!!Allocate memory to hold graphs and corresponding vectors for ResumFciMC.
!            ALLOCATE(GraphRhoMat(NDets,NDets),stat=ierr)
!            CALL LogMemAlloc('GraphRhoMat',NDets**2,8,this_routine,GraphRhoMatTag)
!            ALLOCATE(GraphVec(NDets),stat=ierr)
!            CALL LogMemAlloc('GraphVec',NDets,8,this_routine,GraphVecTag)
!            ALLOCATE(DetsinGraph(NEl,NDets),stat=ierr)
!            CALL LogMemAlloc('DetsinGraph',NEl*NDets,4,this_routine,DetsinGraphTag)
!        ENDIF
!
!        RETURN
!
!    END SUBROUTINE InitFCIMCCalc
!
!!This routine calculates the normalisation for the MP1 wavefunction. This is needed if a nodal structure is being applied, and can also calculate the number of determinants which are being constrained.
!    SUBROUTINE CalcNodalSurface()
!        use CalcData , only : i_P
!        use SystemData , only : Beta
!        use IntegralsData , only : nTay
!        IMPLICIT NONE
!        INTEGER :: ierr,i,j,k,Doubs,FixedSign
!        REAL*8 :: EigenComp
!        CHARACTER(len=*), PARAMETER :: this_routine='CalcNodalSurface'
!        INTEGER :: nStore(6),nExcitMemLen,nJ(NEl),iMaxExcit,nExcitTag=0,iExcit
!        INTEGER , ALLOCATABLE :: nExcit(:)
!        HElement_t :: Fj,Hamij!,rhij,rhjj
!
!        WRITE(6,"(A,F19.9)") "Calculating the nodal structure of the MP1 wavefunction with a normalised cutoff of ",NodalCutoff
!
!!        IF(nTay(2).ne.3) THEN
!!This is no longer needed since the MP1 components are calculated exactly
!!Fock-partition-lowdiag is not set - it must be in order to use the given formulation for the MP1 wavefunction
!!            WRITE(6,*) "FOCK-PARTITION-LOWDIAG is not specified. It must be to use NODALCUTOFF."
!!            WRITE(6,*) "Resetting all rho integrals to use FOCK-PARTITION-LOWDIAG"
!!            nTay(2)=3
!!        ENDIF
!
!!First, generate all excitations, and store their determianants, and rho matrix elements
!        nStore(1)=0
!        CALL GenSymExcitIt2(FDet,NEl,G1,nBasis,nBasisMax,.TRUE.,nExcitMemLen,nJ,iMaxExcit,0,nStore,2)
!        ALLOCATE(nExcit(nExcitMemLen),stat=ierr)
!        CALL LogMemAlloc('nExcit',nExcitMemLen,4,this_routine,nExcitTag,ierr)
!        nExcit(1)=0
!        CALL GenSymExcitIt2(FDet,NEl,G1,nBasis,nBasisMax,.TRUE.,nExcit,nJ,iMaxExcit,0,nStore,2)
!
!!Calculate F0
!        CALL GetH0Element(FDet,NEl,Arr,nBasis,ECore,FZero)
!!        CALL CalcRho2(FDet,FDet,Beta,i_P,NEl,nBasisMax,G1,nBasis,Brr,nMsh,fck,Arr,ALat,UMat,rhii,nTay,0,ECore)
!
!        Doubs=0
!!The HF determinant has a component 1
!        MPNorm=1.D0
!        do while (.true.)
!            CALL GenSymExcitIt2(FDet,NEl,G1,nBasis,nBasisMax,.false.,nExcit,nJ,iExcit,0,nStore,2)
!            IF(nJ(1).eq.0) EXIT
!            Doubs=Doubs+1
!            Hamij=GetHElement2(FDet,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,iExcit,ECore)
!            CALL GetH0Element(nJ,NEl,Arr,nBasis,ECore,Fj)
!!            CALL CalcRho2(FDet,nJ,Beta,i_P,NEl,nBasisMax,G1,nBasis,Brr,nMsh,fck,Arr,ALat,UMat,rhij,nTay,iExcit,ECore)
!!            CALL CalcRho2(nJ,nJ,Beta,i_P,NEl,nBasisMax,G1,nBasis,Brr,nMsh,fck,Arr,ALat,UMat,rhjj,nTay,0,ECore)
!
!!We want the value of rho_jj/rho_ii
!!            rhjj=rhjj/rhii
!!EigenComp is now the component of the MP1 wavefunction for nJ, but unnormalised
!!            EigenComp=(rhij)/((rhjj)-1.D0)
!            EigenComp=(Hamij)/(Fj-FZero)
!            MPNorm=MPNorm+(EigenComp**2)
!        enddo
!
!        WRITE(6,"(A,I15)") "Number of double excitations found in MP Wavevector: ",Doubs
!
!!Find the normalisation for the MP1 wavevector
!        MPNorm=SQRT(MPNorm)
!
!!Reset the excitation generator, so that we can run through the excitations again and calculate the number of components of the MP1 wavefunction which will be sign-constrained
!        CALL ResetExit2(FDet,NEl,G1,nBasis,nBasisMax,nExcit,0)
!
!        FixedSign=0     !FixedSign is the number of determinants which are fixed in sign with the given value of the NodalCutoff
!
!        IF((1.D0/MPNorm).gt.abs(NodalCutoff)) THEN
!!This indicates that the HF is included in the fixed sign approximation, and so will always be constrained to have net positive particles.
!            FixedSign=FixedSign+1
!            WRITE(6,*) "Hartree-Fock determinant constrained to always have net positive sign"
!        ELSE
!            WRITE(6,"(A,F17.9)") "Hartree-Fock determinant NOT constrained to have net positive sign, since normalised component is only: ", 1.D0/MPNorm
!        ENDIF
!
!        do while(.true.)
!            CALL GenSymExcitIt2(FDet,NEl,G1,nBasis,nBasisMax,.false.,nExcit,nJ,iExcit,0,nStore,2)
!            IF(nJ(1).eq.0) EXIT
!            Hamij=GetHElement2(FDet,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,iExcit,ECore)
!            CALL GetH0Element(nJ,NEl,Arr,nBasis,ECore,Fj)
!!            CALL CalcRho2(FDet,nJ,Beta,i_P,NEl,nBasisMax,G1,nBasis,Brr,nMsh,fck,Arr,ALat,UMat,rhij,nTay,iExcit,ECore)
!!            CALL CalcRho2(nJ,nJ,Beta,i_P,NEl,nBasisMax,G1,nBasis,Brr,nMsh,fck,Arr,ALat,UMat,rhjj,nTay,0,ECore)
!
!!We want the value of rho_jj/rho_ii
!!            rhjj=rhjj/rhii
!!EigenComp is now the component of the MP1 wavefunction for nJ, but now normalised
!!            EigenComp=abs(((rhij)/((rhjj)-1.D0))/MPNorm)
!            EigenComp=abs(((Hamij)/(Fj-FZero))/MPNorm)
!            IF(EigenComp.gt.abs(NodalCutoff)) THEN
!!Increase the counter of number of determinants with fixed sign
!                FixedSign=FixedSign+1
!            ENDIF
!
!        enddo
!
!        WRITE(6,*) "Total number of determinants constrained by fixed sign: ", FixedSign
!
!        DEALLOCATE(nExcit)
!        CALL LogMemDealloc(this_routine,nExcitTag)
!
!        RETURN
!
!    END SUBROUTINE CalcNodalSurface
!
!!This function tells us whether we want to diffuse from DetCurr to nJ
!    SUBROUTINE AttemptDiffuse(DetCurr,nJ,Prob,IC,WSign,KeepOrig,CreateAtI,CreateAtJ)
!        IMPLICIT NONE
!        INTEGER :: DetCurr(NEl),nJ(NEl),IC,i,CreateAtI,CreateAtJ
!        REAL*8 :: Prob,Ran2,rat
!        LOGICAL :: WSign,KeepOrig
!        HElement_t :: rh
!
!!Calculate off-diagonal hamiltonian matrix element between determinants
!        rh=GetHElement2(DetCurr,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,IC,ECore)
!
!!rat is the probability of diffusing to nJ
!        rat=Tau*Lambda*abs(rh)/Prob
!
!        IF(rat.gt.1.D0) CALL Stop_All("AttemptDiffuse","*** Probability > 1 to diffuse.")
!
!        IF(rat.gt.Ran2(Seed)) THEN
!            IF(TExtraPartDiff) THEN
!!We want to perform the non-total number conserving diffusion matrix - anti-diffusion creates 2 new particles
!                IF(real(rh).gt.0.D0) THEN
!!Perform anti-diffusion - particle number will increase
!                    IF(WSign) THEN
!!We have a positive walker
!                        KeepOrig=.true.
!                        CreateAtI=1
!                        CreateAtJ=-1
!                    ELSE
!!We have a negative walker
!                        KeepOrig=.true.
!                        CreateAtI=-1
!                        CreateAtJ=1
!                    ENDIF
!                ELSE
!!Perform diffusion - particle number will remain constant
!                    IF(WSign) THEN
!                        KeepOrig=.false.    !Particle is annihilated by newly created opposing signed particle
!                        CreateAtI=0
!                        CreateAtJ=1
!                    ELSE
!                        KeepOrig=.false.
!                        CreateAtI=0
!                        CreateAtJ=-1
!                    ENDIF
!                ENDIF
!            ELSE
!!We are performing a number-conserving diffusion process - this will have a different diagonal birth/death unbiasing probability
!                IF(real(rh).gt.0.D0) THEN
!!Perform anti-diffusion, but conserve total particle number
!                    IF(WSign) THEN
!                        KeepOrig=.false.
!                        CreateAtI=0
!                        CreateAtJ=-1
!                    ELSE
!                        KeepOrig=.false.
!                        CreateAtI=0
!                        CreateAtJ=1
!                    ENDIF
!                ELSE
!!Perform diffusion - this should conserve particle number, and be the same as the other diffusion process
!                    IF(WSign) THEN
!                        KeepOrig=.false.
!                        CreateAtI=0
!                        CreateAtJ=1
!                    ELSE
!                        KeepOrig=.false.
!                        CreateAtI=0
!                        CreateAtJ=-1
!                    ENDIF
!                ENDIF
!            ENDIF
!        ELSE
!!No diffusion will occur...
!            KeepOrig=.true.        !We don't want to copy it accross, because it still can die - wait to see if it dies before copying accross
!            CreateAtI=0
!            CreateAtJ=0
!        ENDIF
!
!        RETURN
!
!    END SUBROUTINE AttemptDiffuse
!
!!This function tells us whether we should create a child particle on nJ, from a parent particle on DetCurr with sign WSign, created with probability Prob
!!It returns zero if we are not going to create a child, or -1/+1 if we are to create a child, giving the sign of the new particle
!!Kik returns the a value which can be used to unbias the diffusion at the birth/death stage
!    INTEGER FUNCTION AttemptCreate(DetCurr,WSign,nJ,Prob,IC,Kik)
!        IMPLICIT NONE
!        INTEGER :: DetCurr(NEl),nJ(NEl),IC,StoreNumTo,StoreNumFrom,DetLT,i,ExtraCreate
!        LOGICAL :: WSign
!        REAL*8 :: Prob,Ran2,rat,Kik
!        HElement_t :: rh
!
!!Calculate off diagonal hamiltonian matrix element between determinants
!        IF(TNoBirth) THEN
!            rh=(0.D0)
!        ELSE
!            rh=GetHElement2(DetCurr,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,IC,ECore)
!        ENDIF
!
!!Divide by the probability of creating the excitation to negate the fact that we are only creating a few determinants
!        IF(TDiffuse) THEN
!            IF(TExtraPartDiff) THEN
!                Kik=Tau*rh/Prob
!            ELSE
!                Kik=Tau*abs(rh)/Prob
!            ENDIF
!            rat=(1.D0-Lambda)*abs(Kik)
!        ELSE
!            rat=Tau*abs(rh)/Prob
!        ENDIF
!
!!        IF(rat.lt.0.D0) THEN
!!            CALL Stop_All("AttemptCreate","*** Probability < 0 to create child.")
!!        ENDIF
!
!!If probability is > 1, then we can just create multiple children at the chosen determinant
!        ExtraCreate=INT(rat)
!        rat=rat-REAL(ExtraCreate)
!
!
!!Stochastically choose whether to create or not according to Ran2
!        IF(rat.gt.Ran2(Seed)) THEN
!!Child is created - what sign is it?
!            IF(WSign) THEN
!!Parent particle is positive
!                IF(real(rh).gt.0.D0) THEN
!                    AttemptCreate=-1     !-ve walker created
!                ELSE
!                    AttemptCreate=1      !+ve walker created
!                ENDIF
!
!            ELSE
!!Parent particle is negative
!                IF(real(rh).gt.0.D0) THEN
!                    AttemptCreate=1      !+ve walker created
!                ELSE
!                    AttemptCreate=-1     !-ve walker created
!                ENDIF
!            ENDIF
!
!        ELSE
!!No child particle created
!            AttemptCreate=0
!        ENDIF
!
!        IF(ExtraCreate.ne.0) THEN
!!Need to include the definitely create additional particles from a initial probability > 1
!
!            IF(AttemptCreate.lt.0) THEN
!!In this case particles are negative
!                AttemptCreate=AttemptCreate-ExtraCreate
!            ELSEIF(AttemptCreate.gt.0) THEN
!!Include extra positive particles
!                AttemptCreate=AttemptCreate+ExtraCreate
!            ELSEIF(AttemptCreate.eq.0) THEN
!!No particles were stochastically created, but some particles are still definatly created - we need to determinant their sign...
!                IF(WSign) THEN
!                    IF(real(rh).gt.0.D0) THEN
!                        AttemptCreate=-1*ExtraCreate    !Additional particles are negative
!                    ELSE
!                        AttemptCreate=ExtraCreate       !Additional particles are positive
!                    ENDIF
!                ELSE
!                    IF(real(rh).gt.0.D0) THEN
!                        AttemptCreate=ExtraCreate
!                    ELSE
!                        AttemptCreate=-1*ExtraCreate
!                    ENDIF
!                ENDIF
!            ENDIF
!        ENDIF
!
!        IF(Tau.lt.0.D0) THEN
!!If tau is negative, we are going back in time, and so will actually create antiparticles - flip sign again...
!            AttemptCreate=-AttemptCreate
!        ENDIF
!
!        IF(TDetPops) THEN
!!Here, we want to record the details of every spawning connection
!
!            StoreNumTo=0
!            StoreNumFrom=0
!            do i=1,SizeOfSpace
!                IF((DetLT(nJ,NMRKS(:,i),NEl).eq.0).and.(StoreNumTo.eq.0)) THEN
!!Found position of determinant
!                    StoreNumTo=i
!                ENDIF
!                IF((DetLT(DetCurr,NMRKS(:,i),NEl).eq.0).and.(StoreNumFrom.eq.0)) THEN
!                    StoreNumFrom=i
!                ENDIF
!                IF((StoreNumTo.ne.0).and.(StoreNumFrom.ne.0)) EXIT
!            enddo
!
!            IF(AttemptCreate.lt.0) THEN
!!If creating a negative particle, reduce the connection
!                TransMat(StoreNumFrom,StoreNumTo)=TransMat(StoreNumFrom,StoreNumTo)-(AttemptCreate*0.00001)
!                TransMat(StoreNumTo,StoreNumFrom)=TransMat(StoreNumTo,StoreNumFrom)-(AttemptCreate*0.00001)
!            ELSE
!!If creating a positive particle, increase connection
!                TransMat(StoreNumFrom,StoreNumTo)=TransMat(StoreNumFrom,StoreNumTo)+(AttemptCreate*0.00001)
!                TransMat(StoreNumTo,StoreNumFrom)=TransMat(StoreNumTo,StoreNumFrom)+(AttemptCreate*0.00001)
!            ENDIF
!
!        ENDIF
!
!        RETURN
!
!    END FUNCTION AttemptCreate
!
!!This function tells us whether we should kill the particle at determinant DetCurr
!!If also diffusing, then we need to know the probability with which we have spawned. This will reduce the death probability.
!!The function allows multiple births(if +ve shift) or deaths from the same particle.
!!The returned number is the number of deaths if positive, and the number of births if negative.
!    INTEGER FUNCTION AttemptDie(DetCurr,Kik,nExcitMemLen,nExcit,nStore)
!        IMPLICIT NONE
!        INTEGER :: DetCurr(NEl),DetLT,iKill,nExcitMemLen,nStore(6),nExcit(nExcitMemLen)
!        INTEGER :: nJ(NEl),IC,iMaxExcit,ierr,nExcitTag=0
!        CHARACTER(len=*) , PARAMETER :: this_routine='AttemptDie'
!        HElement_t :: rh,rhij
!        REAL*8 :: Ran2,rat,Kik
!
!!Test if determinant is FDet - in a strongly single-configuration problem, this will save time
!        IF(DetLT(DetCurr,FDet,NEl).eq.0) THEN
!            rh=0.D0
!        ELSE
!!Calculate the diagonal hamiltonian matrix element for the determinant
!            rh=GetHElement2(DetCurr,DetCurr,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,0,ECore)
!!Subtract from the diagonal the value of the lowest hamiltonian matrix element
!            rh=rh-Hii
!        ENDIF
!
!        IF(TDiffuse) THEN
!!If also diffusing, then the probability of dying must be modified, since the diagonal elements have been altered
!            IF(TExtraPartDiff) THEN
!
!                IF(TFullUnbias) THEN
!
!
!!Setup excit generators for this determinant (This can be reduced to an order N routine later for abelian symmetry.
!
!                    CALL ResetExIt2(DetCurr,NEl,G1,nBasis,nBasisMax,nExcit,0)
!
!                    Kik=0.D0    !If we are fully unbiasing, then the unbiasing factor is reset and recalculated from all excitations of DetCurr
!                    do while(.true.)
!                        CALL GenSymExcitIt2(DetCurr,NEl,G1,nBasis,nBasisMax,.FALSE.,nExcit,nJ,IC,0,nStore,exFlag)
!                        IF(nJ(1).eq.0) EXIT
!                        rhij=GetHElement2(DetCurr,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,IC,ECore)
!                        Kik=Kik+(rhij)
!                    enddo
!
!                    CALL ResetExIt2(DetCurr,NEl,G1,nBasis,nBasisMax,nExcit,0)
!
!                    Kik=Kik*Tau    !Unbias with the tau*sum of connected elements
!                ENDIF
!
!                rat=(Tau*((rh)-DiagSft))+(Lambda*Kik)     !This is now the probability with the correct unbiasing
!
!            ELSE
!                IF(TFullUnbias) THEN
!
!                    CALL ResetExIt2(DetCurr,NEl,G1,nBasis,nBasisMax,nExcit,0)
!
!                    Kik=0.D0    !If we are fully unbiasing, then the unbiasing factor is reset and recalculated from all excitations of DetCurr
!                    do while(.true.)
!                        CALL GenSymExcitIt2(DetCurr,NEl,G1,nBasis,nBasisMax,.FALSE.,nExcit,nJ,IC,0,nStore,exFlag)
!!                        CALL WRITEDET(6,nJ,NEl,.true.)
!                        IF(nJ(1).eq.0) EXIT
!                        rhij=GetHElement2(DetCurr,nJ,NEl,nBasisMax,G1,nBasis,Brr,NMsh,fck,NMax,ALat,UMat,IC,ECore)
!                        Kik=Kik+abs(rhij)
!                    enddo
!
!                    CALL ResetExIt2(DetCurr,NEl,G1,nBasis,nBasisMax,nExcit,0)
!
!                    Kik=Kik*Tau    !Unbias with the tau*sum of connected elements
!                ENDIF
!
!                rat=(Tau*((rh)-DiagSft))-(Lambda*Kik)     !This is now the probability with the correct unbiasing
!
!            ENDIF
!
!        ELSE
!!Subtract the current value of the shift and multiply by tau
!            rat=Tau*((rh)-DiagSft)
!        ENDIF
!
!!        IF(rat.gt.1.D0) THEN
!!If probs of dying is greater than one, reduce tau
!!            CALL Stop_All("AttemptDie","*** Death probability > 1. *** Tau too large")
!!        ENDIF
!
!        iKill=INT(rat)
!        rat=rat-REAL(iKill)
!
!!Stochastically choose whether to die or not
!        IF(abs(rat).gt.Ran2(Seed)) THEN
!            IF(rat.ge.0.D0) THEN
!!Depends whether we are trying to kill or give birth to particles.
!                iKill=iKill+1
!            ELSE
!                iKill=iKill-1
!            ENDIF
!        ENDIF
!
!        AttemptDie=iKill
!!        IF(AttemptDie.le.-1) WRITE(6,*) Iter,AttemptDie,rat
!
!        RETURN
!
!    END FUNCTION AttemptDie
!
!    SUBROUTINE MCDiffusion()
!        IMPLICIT NONE
!        INTEGER :: ierr,nExcitMemLen,TotExcits
!        CHARACTER(len=*) , PARAMETER :: this_routine='MCDiffusion'
!        INTEGER :: nJ(NEl),nK(NEl),ICJ,ICK,iCountJ,iCountK,i,j,iGetExcitLevel
!        REAL*8 :: ProbJ,ProbK,Ran2,rat,NewHii,SumDeathProb,ExpectedWalkers
!        HElement_t :: Hij,Hik,tempHii
!        HElement_t , ALLOCATABLE :: Hi0Array(:)
!        INTEGER , ALLOCATABLE :: ICWalk(:)
!        REAL*8 , ALLOCATABLE :: HiiArray(:)
!
!        CALL InitFCIMCCalc()    !Initialise walkers to be all positive and on the HF
!
!        WRITE(6,*) "Performing MC Diffusion with ",InitWalkers," walkers."
!        WRITE(6,*) " Iteration   Shift    ExpectedGrowthRate   ProjectionE"
!        WRITE(fcimcstats_unit,*) "# Iteration   Shift    ExpectedGrowthRate   ProjectionE"
!
!        WRITE(6,"(I9,3G16.7)") 0,DiagSft,0.D0,0.D0
!        WRITE(fcimcstats_unit,"(I9,3G16.7)") 0,DiagSft,0.D0,0.D0
!
!!Need to store excitation generators for each of the particles
!        ALLOCATE(ExcitGens(InitWalkers),stat=ierr)     !Array to hold excitation generators for each walker
!        ALLOCATE(ICWalk(InitWalkers),stat=ierr)     !Array to hold excitation level for each walker
!        ALLOCATE(Hi0Array(InitWalkers),stat=ierr)   !Array to hold connection back to HF for each walker
!        ALLOCATE(HiiArray(InitWalkers),stat=ierr)   !Array to hold diagonal hamiltonian element for each walker
!        IF(ierr.ne.0) CALL Stop_All("MCDiffusion","Error in allocation")
!
!        CALL SetupExitgen(FDet,ExcitGens(1),nExcitMemLen,TotExcits)
!        ICWalk(1)=0
!        Hi0Array(1)=Hii
!        HiiArray(1)=real(Hii,dp)
!
!        do i=2,InitWalkers
!!Copy the excitation generator for FDet to all the other initial walkers
!            ALLOCATE(ExcitGens(i)%ExcitData(nExcitMemLen),stat=ierr)
!            IF(ierr.ne.0) CALL Stop_All("MCDiffusion","Error in allocation")
!            do j=1,nExcitMemLen
!                ExcitGens(i)%ExcitData(j)=ExcitGens(1)%ExcitData(j)
!            enddo
!            ICWalk(i)=0
!            Hi0Array(i)=Hii
!            HiiArray(i)=real(Hii,dp)
!        enddo
!
!        SumENum=real(Hii,dp)*InitWalkers
!        SumNoatHF=InitWalkers
!
!        SumDeathProb=0.D0
!
!        do Iter=1,NMCyc
!!Perform MC cycles
!            do j=1,InitWalkers
!!Cycle over all walkers
!
!!First we have to see if we're going to perform a self-hop, or allow an attempt at a diffusive move.
!!                rat=Tau/(HiiArray(j)-(real(Hii,dp))-DiagSft)      !This is the probability of self-hopping, rather than attempting a diffusive move
!!                rat=Tau*((HiiArray(j)/(real(Hii,dp)))-DiagSft)      !This is the probability of self-hopping, rather than attempting a diffusive move
!                rat=0.8*(1.D0-Tau*((HiiArray(j)-(real(Hii,dp)))-DiagSft))      !This is the probability of self-hopping, rather than attempting a diffusive move
!                                                        !Higher excitations have smaller prob, so resampled fewer times and lower excitations sampled for longer.
!
!                IF((rat.lt.0.D0).or.(rat.gt.1.D0)) CALL Stop_All("DiffusionMC","Incorrect self-hop probability")
!                IF(rat.gt.Ran2(Seed)) THEN
!!We want to self-hop. Resum in energy, but to not allow an attempted move away from excit. We also update the effect on the shift later.
!
!                        SumENum=SumENum+(real(Hi0Array(j),dp))
!                        IF(ICWalk(j).eq.0) SumNoatHF=SumNoatHF+1
!                        NewHii=HiiArray(j)
!
!                ELSE
!!We do not have to self-hop. Attempt to diffuse away from determinant.
!
!                    CALL GenRandSymExcitIt3(CurrentDets(:,j),ExcitGens(j)%ExcitData,nJ,Seed,ICJ,ProbJ,iCountJ)  !First random excitation is to attempt to move to
!                    CALL GenRandSymExcitIt3(CurrentDets(:,j),ExcitGens(j)%ExcitData,nK,Seed,ICK,ProbK,iCountK)  !Second is to unbias the diffusion in the birth/death prob
!                    Hij=GetHElement2(CurrentDets(:,j),nJ,NEl,nBasisMax,G1,nBasis,Brr,nMsh,fck,NMax,ALat,UMat,ICJ,ECore)
!                    Hik=GetHElement2(CurrentDets(:,j),nK,NEl,nBasisMax,G1,nBasis,Brr,nMsh,fck,NMax,ALat,UMat,ICK,ECore)
!
!!Attempt diffusion away to nJ
!                    rat=Tau*abs(real(Hij,dp))/ProbJ
!
!                    IF(rat.gt.1.D0) CALL Stop_All("AttemptDiffuse","*** Probability > 1 to diffuse.")
!
!                    IF(rat.gt.Ran2(Seed)) THEN
!!Diffusion successful - need to update all the information
!
!                        CurrentDets(:,j)=nJ(:)
!
!                        IF(real(Hij,dp).gt.0.D0) THEN
!!This is the anti-diffusion
!                            IF(CurrentSign(j)) THEN
!!Walker is positive
!                                CurrentSign(j)=.false.  !Want negative walker
!                            ELSE
!                                CurrentSign(j)=.true.   !Positive walker
!                            ENDIF
!                        ELSE
!!This is diffusion - no need to flip sign, since we want to keep the same signs.
!                        ENDIF
!
!!Sum in new energy
!                        ICWalk(j)=iGetExcitLevel(FDet,nJ,NEl)
!                        IF(ICWalk(j).eq.2) THEN
!                            Hi0Array(j)=GetHElement2(FDet,nJ,NEl,nBasisMax,G1,nBasis,Brr,nMsh,fck,NMax,ALat,UMat,2,ECore)
!                            SumENum=SumENum+(real(Hi0Array(j),dp))
!                        ELSEIF(ICWalk(j).eq.0) THEN
!                            Hi0Array(j)=Hii
!                            SumENum=SumENum+(real(Hii,dp))
!                            SumNoatHF=SumNoatHF+1
!                        ELSE
!                            Hi0Array(j)=(0.D0)
!                        ENDIF
!
!!Create and save new excitation generator
!                        CALL SetupExitgen(nJ,ExcitGens(j),nExcitMemLen,TotExcits)
!
!                        tempHii=GetHElement2(nJ,nJ,NEl,nBasisMax,G1,nBasis,Brr,nMsh,fck,NMax,ALat,UMat,0,ECore)
!                        NewHii=real(tempHii,dp)  !This is the new diagonal matrix element
!
!                    ELSE
!!Attempted diffusion away is not successful - still need to update the energy
!
!                        SumENum=SumENum+(real(Hi0Array(j),dp))
!                        IF(ICWalk(j).eq.0) SumNoatHF=SumNoatHF+1
!                        NewHii=HiiArray(j)
!
!                    ENDIF
!
!                ENDIF
!
!                rat=Tau*(((HiiArray(j)-(real(Hii,dp)))-DiagSft)-(abs(real(Hik,dp))/ProbK))      !This is the prob of death, adjusted to unbias for the diffusion
!
!                HiiArray(j)=NewHii      !Now we can update the HiiArray to take into account if the walker has moved to a new position
!
!                SumDeathProb=SumDeathProb+rat   !Sum the death probabilities
!
!            enddo   !Finsh cycling over all walkers
!
!            ProjectionE=(SumENum/(SumNoatHF+0.D0))-REAL(Hii,dp)
!
!            IF(mod(Iter,StepsSft).eq.0) THEN
!
!                SumDeathProb=SumDeathProb/(InitWalkers*StepsSft+0.D0)       !This now indicates the average death probability per walker per cycle
!!                WRITE(6,*) SumDeathProb
!
!!                ExpectedWalkers=InitWalkers+0.D0    !This is the number of walkers we start off with at the beginning of the update shift cycle.
!!                do i=1,StepsSft
!!                    ExpectedWalkers=ExpectedWalkers-ExpectedWalkers*SumDeathProb
!!                enddo
!
!                IF(SumDeathProb.gt.1.D0) CALL Stop_All("MCDIFFUSION","Average Death prob. > 1")
!
!                ExpectedWalkers=InitWalkers*((1.D0-SumDeathProb)**StepsSft)
!
!                GrowRate=(ExpectedWalkers)/(InitWalkers+0.D0)  !This is the expected growth rate over the previous StepsSft
!
!                DiagSft=DiagSft-(log(GrowRate)*SftDamp)/(Tau*(StepsSft+0.D0))
!
!                SumDeathProb=0.D0
!
!                WRITE(6,"(I9,3G16.7)") Iter,DiagSft,GrowRate,ProjectionE
!                WRITE(fcimcstats_unit,"(I9,3G16.7)") Iter,DiagSft,GrowRate,ProjectionE
!
!                CALL FLUSH(6)
!                CALL FLUSH(fcimcstats_unit)
!
!            ENDIF
!
!        enddo
!
!        RETURN
!
!    END SUBROUTINE MCDiffusion
!
!    SUBROUTINE SetupExitgen(nI,ExcitGen,nExcitMemLen,iMaxExcit)
!        IMPLICIT NONE
!        TYPE(ExcitGenerator) :: ExcitGen
!        INTEGER :: ierr,iMaxExcit,nExcitMemLen,nJ(NEl)
!        INTEGER :: nI(NEl)
!
!        IF(Allocated(ExcitGen%ExcitData)) THEN
!            DEALLOCATE(ExcitGen%ExcitData)
!        ENDIF
!
!!Setup excit generators for this determinant (This can be reduced to an order N routine later for abelian symmetry.
!        iMaxExcit=0
!        ExcitGen%nStore(1:6)=0
!        CALL GenSymExcitIt2(nI,NEl,G1,nBasis,nBasisMax,.TRUE.,nExcitMemLen,nJ,iMaxExcit,0,ExcitGen%nStore,3)
!        ALLOCATE(ExcitGen%ExcitData(nExcitMemLen),stat=ierr)
!        IF(ierr.ne.0) CALL Stop_All("SetupExcitGen","Problem allocating excitation generator")
!        ExcitGen%ExcitData(1)=0
!        CALL GenSymExcitIt2(nI,NEl,G1,nBasis,nBasisMax,.TRUE.,ExcitGen%ExcitData,nJ,iMaxExcit,0,ExcitGen%nStore,3)
!
!    END SUBROUTINE SetupExitgen
!
!END MODULE FciMCMod
!
