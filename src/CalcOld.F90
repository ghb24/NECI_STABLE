! Calculate 'PATHS' using on-the-fly generated determinants
!  Determinants are generated by GENNEXTDET according to the various symmetry specifications given by the use
!  nActiveBasis will restrict the space of generated determinants to excitations from and to a given set of
!  basis functions
      SUBROUTINE CALCRHOPII3(BETA,I_P,I_HMAX,I_VMAX,NEL,NBASISMAX,G1,NBASIS,BRR,NMSH,FCK,NMAX,ALAT,UMAT,NTAY, &
     &            RHOEPS,NWHTAY,NPATHS,ILOGGING,ECORE,TNPDERIV,DBETA,DETINV,TSPN,LMS,TPARITY,SymRestrict,     &
     &            TSPECDET,SPECDET,nActiveBasis)
         use constants, only: dp
         use global_utilities
         use util_mod, only: get_free_unit, NECI_ICOPY
         use SystemData, only: BasisFN,BasisFNSize
         use legacy_data, only: irat
         use CalcData, only: tFCIMC
         use gnd_work_type
         use Determinants, only: write_det
         use mcpaths, only: mcpathsr3
         use sym_mod
         use MemoryManager, only: TagIntType
         IMPLICIT NONE
         INTEGER I_HMAX,NEL,NBASIS,I_VMAX
         INTEGER,ALLOCATABLE :: LSTE(:,:,:) !(NEL,NBASIS*NBASIS*NEL*NEL,0:I_VMAX-1)?
         INTEGER,ALLOCATABLE :: ICE(:,:)  !(NBASIS*NBASIS*NEL*NEL,0:I_VMAX-1)?
         HElement_t  UMAT(*)
         HElement_t,allocatable  :: RIJLIST(:,:)
         integer(TagIntType),save :: tagRIJList=0,tagLSTE=0,tagICE=0
         real(dp) BETA,ALAT(3),RHOEPS
         complex(dp) FCK(*)
         INTEGER NPATHS,NI(NEL),I_P,nBasisMax(5,*)
         INTEGER Work(GNDWorkSize+2*NEL)
         TYPE(BASISFN) G1(*)
         INTEGER BRR(*),NMSH,NMAX,NTAY(2),ILOGGING
         INTEGER III,NWHTAY(3,I_VMAX),IMAX,ILMAX,LMS
         TYPE(BasisFN) ISYM,SymRestrict
         LOGICAL TSPN,TPARITY,TSYM
         real(dp) DBETA,ECORE
         real(dp) WLRI,WLSI,WLRI1,WLRI2,WLSI1,WLSI2,DLWDB
         real(dp) TOT,WLRI0,WLSI0,WINORM,HElP,NORM
         LOGICAL TNPDERIV,TDONE,TFIRST
         INTEGER DETINV
         INTEGER ISTART,IEND,IDEG,iunit
         LOGICAL TSPECDET,TLOG
         INTEGER SPECDET(NEL)
         real(dp) DLWDB2,DLWDB3,DLWDB4,TOT2
         INTEGER nActiveBasis(2)
         type(timer), save :: proc_timer
         character(len=*), parameter :: thisroutine='CALCRHOPII3'
         TLOG=BTEST(ILOGGING,1)
         HElP=(I_P)
         TSYM=.TRUE.
         TOT=0.0_dp
         TOT2=0.0_dp
         NORM=0.0_dp
         IMAX=I_HMAX
         IF(I_VMAX.GT.IMAX) IMAX=I_VMAX
         proc_timer%timer_name=thisroutine
         call set_timer(proc_timer)
         WRITE(6,*) "Entering CALCRHOPII3..."
!         ILMAX=NDET
!.. We don't need to store lists for I_HMAX=-8
         ILMAX=(NBASIS-NEL)**2*NEL*NEL/4
         IF((I_HMAX.GE.-10.AND.I_HMAX.LE.-7).OR.I_HMAX.LE.-12) ILMAX=1
         allocate(LSTE(NEL,0:ILMAX,0:IMAX))
         call LogMemAlloc('LSTE',int(size(LSTE)),4/IRAT,thisroutine,tagLSTE)
         allocate(ICE(0:ILMAX,0:IMAX))
         call LogMemAlloc('ICE',int(size(ICE)),4/IRAT,thisroutine,tagICE)
         allocate(RIJList(0:ILMAX,0:IMAX*2))
         call LogMemAlloc('RIJList',(1+ILMAX)*IMAX*2,8,thisroutine, tagRIJList)
!:         CALL PRINT_MEMORY()
         IF(I_VMAX.NE.0) THEN
            WRITE(6,*) "Using Vertex approximation.  I_VMAX=",I_VMAX
            IF(I_HMAX.EQ.0) WRITE(6,*) "I_HMAX=0.  Summing all I_HMAX up to P using contour"
            IF(I_HMAX.GT.0) WRITE(6,*) "I_HMAX=",I_HMAX
         ELSEIF(I_HMAX.NE.0) THEN
            WRITE(6,*) "Using hop-restricted paths. I_HMAX:",I_HMAX
         ELSE
            WRITE(6,*) "I_HMAX=I_VMAX=0. Using rho diagonalisation."
         ENDIF
         IF(TLOG) THEN
           iunit = get_free_unit()
            IF(I_HMAX.EQ.-10) THEN
               OPEN(iunit,FILE="MCSUMMARY",STATUS="UNKNOWN")
               WRITE(iunit,*) "Calculating ",NPATHS," W_Is..."
               CLOSE(iunit)
            ELSE
               OPEN(iunit,FILE="MCPATHS",STATUS="UNKNOWN")
               WRITE(iunit,*) "Calculating ",NPATHS," W_Is..."
               CLOSE(iunit)
            ENDIF
            OPEN(iunit,FILE='RHOPII',STATUS='UNKNOWN')
         ENDIF
         IF(DETINV.NE.0) THEN
            ISTART=ABS(DETINV)
            IEND=ABS(DETINV)
         ELSEIF(TSPECDET) THEN
            WRITE(6,*) "Calculating vertex series for specific det:"
            call write_det (6, specdet, .true.) 
            ISTART=-1
            IEND=1
         ELSE
            ISTART=1
            IEND=NPATHS
         ENDIF

         III=0
         TDONE=.FALSE.
         TFIRST=.TRUE.
         IF(.NOT.TSPECDET) THEN
            CALL GENNEXTDET(NEL,NBASIS,BRR,NBASISMAX,G1,TSPN,LMS,TPARITY,SymRestrict,ISYM,NI,.TRUE.,TDONE,WORK,nActiveBasis)
         ENDIF
         DO WHILE(III.NE.IEND.AND..NOT.TDONE)
          III=III+1
          IF(TSPECDET) THEN
             TDONE=.FALSE.
             CALL NECI_ICOPY(NEL,SPECDET,1,NI,1)
             IDEG=1
          ELSE
             CALL GENNEXTDET(NEL,NBASIS,BRR,NBASISMAX,G1,TSPN,LMS,TPARITY,SymRestrict,ISYM,NI,.FALSE.,TDONE,WORK,nActiveBasis)
             CALL GETSYMDEGEN(ISYM,NBASISMAX,IDEG)
          ENDIF
          IF(III.GE.ISTART.AND..NOT.TDONE) THEN
            IF(NPATHS.EQ.1.AND..NOT.TSPECDET.AND..NOT.TFCIMC) &
                call write_det (6, nI, .true.) 
            CALL MCPATHSR3(NI,BETA,I_P,I_HMAX,I_VMAX,NEL,NBASISMAX,G1,NBASIS,BRR,NMSH,FCK,NMAX,ALAT,UMAT,NTAY, &
     &         RHOEPS,LSTE,ICE,RIJLIST,NWHTAY,ILOGGING,ECORE,ILMAX,WLRI,WLSI,DBETA,DLWDB2)
            IF(TLOG) THEN
               WRITE(iunit,"(I12)",advance='no') III
               call write_det (iunit, NI, .false.)
               WRITE(iunit,"(3G25.16)",advance='no') EXP(WLSI+HElP*WLRI),WLRI*HElP,WLSI
            ENDIF
            IF(TFIRST) THEN
               TFIRST=.FALSE.
               WLRI0=WLRI
               WLSI0=WLSI
            ENDIF  
            IF(TNPDERIV) THEN
!.. if we're calculating the derivatives too
               CALL MCPATHSR3(NI,BETA+DBETA,I_P,I_HMAX, I_VMAX,NEL,NBASISMAX,G1,NBASIS,BRR,NMSH,FCK,  &
     &            NMAX,ALAT,UMAT,NTAY,RHOEPS,LSTE,ICE,RIJLIST,NWHTAY, ILOGGING,ECORE,ILMAX,WLRI1,WLSI1,DBETA,DLWDB3)
               CALL MCPATHSR3(NI,BETA-DBETA,I_P,I_HMAX,I_VMAX,NEL,NBASISMAX,G1,NBASIS,BRR,NMSH,FCK,   &
     &            NMAX,ALAT,UMAT,NTAY,RHOEPS,LSTE,ICE,RIJLIST,NWHTAY, ILOGGING,ECORE,ILMAX,WLRI2,WLSI2,DBETA,DLWDB4)
               DLWDB=-(HElP*(WLRI1-WLRI2)+(WLSI1-WLSI2))/(2*DBETA)
            ELSE
               DLWDB=DLWDB2
            ENDIF
!.. we calculate the energy with weightings normalized to the weight of
!.. the Fermi determinant, otherwise the numbers blow up
            WINORM=EXP(HElP*(WLRI-WLRI0)+(WLSI-WLSI0))
            NORM=NORM+(IDEG)*WINORM
            TOT=TOT+(IDEG)*WINORM*DLWDB
            IF(TLOG) WRITE(iunit,"(G25.16,I5)") DLWDB,IDEG
            IF(DETINV.EQ.III) THEN
               IF(TLOG) CALL neci_flush(iunit)
               WRITE(6,*) "Investigating det ",DETINV
               CALL neci_flush(6)
               CALL WIRD_SUBSET(NI,BETA,I_P,NEL,NBASISMAX,G1,NBASIS,BRR,NMSH,FCK,NMAX,ALAT,UMAT,NTAY,ECORE)
            ENDIF
           ELSE
! Correct for overcounting
               III=III-1
           ENDIF
          ENDDO
         IF(TLOG) CLOSE(iunit)
         IF(TFIRST) THEN
            WRITE(6,*) "*** NO determinants found to calculate***"
         ELSE
            WRITE(6,*) "Total ",III," determinants summed."
         ENDIF
         WRITE(6,*) "Summed approx E(Beta)=",TOT/NORM
         deallocate(RIJList,LSTE,ICE)
         call LogMemDealloc(thisroutine,tagRIJList)
         call LogMemDealloc(thisroutine,tagLSTE)
         call LogMemDealloc(thisroutine,tagICE)
         call halt_timer(proc_timer)
         RETURN
      END SUBROUTINE CALCRHOPII3  

